--[[ Change to suit environment --]]
mqttBroker = '192.168.10.21'
mqttUsername = 'mqtt'
mqttPassword = 'password'
lighting = { ['56'] = true } -- Array of applications that are used for lighting (ramp detection only applies to lighting)
checkForChanges = true       -- When true the script will periodically check for create/update/delete of object keywords (disable to lower CPU load)
checkChanges = 30            -- Interval in seconds to check for changes to object keywords

--[[
Resident, zero sleep interval, name: 'MQTT send receive'

Manage CBus, Panasonic and Airtopia AC and environment events for MQTT, and publish discovery topics. Used with Home Assistant.

Documentation available at https://github.com/autoSteve/acMqtt

General configuration variables follow. Change as required, but probably no need to.
--]]
logging = false        -- Enable detailed logging
logms = false          -- Include timestamp in milliseconds for logs

sendHeartbeat = 5      -- Send a heartbeat to the 'Heartbeat' script every n seconds (zero to disable heartbeat)
heartbeatConditions = { ['max'] = 60, } -- At most 60 seconds without a heartbeat or else get restarted
publishNoLevel = false -- For trigger app, whether to publish a level with no tag as "Level n" or raise an error in the log
selectExact = true     -- For select, if a CBus level other than in the select levels is set then adjust the CBus level to the closest select level
blindKey = nil         -- If blind fully open is desirable instead of lastlevel, then change to a string contained in every blind object (e.g. 'Blind'), case sensitive
mqttClientId = 'nac'   -- #ditchunderscoresinvariablenames ... wherever practical please! Be kind to others, and your fingers typing...
mqttQoS = 2            -- Quality of service for MQTT messages: 0 = only once, 1 = at least once, 2 = exactly once
mqttJunk = true        -- Whether to publish junk before a blank publish message when removing topics (not necessary, but cleans up MQTT Explorer view)

--[[
Timing variables. Adjust to taste if you know what you're doing. These provide a good compromise, but your deployment may vary.
--]]
rampTimeout = 5        -- Time beyond ramp to declare a ramp orphan in seconds
socketTimeout = 0.05   -- Lower = higher CPU, but better responsiveness (0 .05 = 1/20th of a second or 50ms, 0.005 = 5ms)
mqttTimeout = 0        -- In milliseconds, go with zero unless you know what you're doing
ignoreTimeout = 2      -- Timeout for stale MQTT ignore messages in seconds (two seconds is a long time...)

--[[
Topic prefixes for read/write/publish. The mqttDiscovery topic is recommended to be set to 'homeassistant/'
for use with HA, which is the default here. The MQTT CBus topics can be called whatever you want, as discovery/subscribe
adjusts. All topic prefixes must end in '/'.
--]]
mqttCbus = 'cbus/'
mqttReadTopic = mqttCbus..'read/'
mqttWriteTopic = mqttCbus..'write/'
mqttDiscoveryTopic = 'homeassistant/'

--[[
Variables not to be messed with unless you definitely know what you're doing.
--]]
discovery = {}         -- MQTT discovery topics lookup
discoveryDelete = {}   -- If duplicate discovery topics are detected on startup then they will be removed
atDiscovery = {}       -- AT discovery topics lookup
atDiscoveryDelete = {} -- If duplicate discovery topics are detected on startup then they will be removed
mqttDevices = {}       -- CBus groups to send MQTT topics for
ac = {}                -- AC device details
acDevices = {}         -- Quick lookup to determine whether an object is an AC device
acBoards = {}          -- All physical AC boards (esp32)
at = {}                -- AT device details
atDevices = {}         -- Quick lookup to determine whether an object is an AT device
atBoards = {}          -- All physical AT boards
env = {}               -- Environment device details
envDevices = {}        -- Quick lookup to determine whether an object is an environment device
envBoards = {}         -- All physical environment boards (esp32)
cbusMessages = {}      -- Message queue
mqttMessages = {}      -- Message queue
ignoreCbus = {}        -- To prevent message loops
ignoreMqtt = {}        -- To prevent message loops
ramp = {}              -- Keeps track of ramping to ignore some zero level MQTT publish events outstandingCbusMessage()
triggers = {}          -- Trigger groups and their levels
selects = {}           -- Select groups and their options/levels
cover = {}             -- Quick lookup to determine whether an object is a cover (blind)
fan = {}               -- Quick lookup to determine whether an object is a fan (sweep fan)
bSensor = {}           -- Quick lookup to determine whether an object is a bsensor (a regular lighting group acting as status)
binarySensor = {}      -- Quick lookup to determine whether an object is a binary sensor
lightingButton = {}    -- Quick lookup to determine whether an object is a lighting group as a button
userParameter = {}     -- Quick lookup to determine whether an object is a user parameter
publishAdj = {}        -- Holds scale and decimals to apply
includeUnits = {}      -- Holds table of booleans to add sensor unit (%, $, Â°C, etc.) to MQTT value
unpublished = {}       -- The outstanding set of CBus objects to publish discovery topics for
unpublishedAt = {}     -- The outstanding set of CBus Airtopia objects to publish discovery topics for
mqttStatus = 2         -- The status of the MQTT connection. Initially disconnected 1=connected, 2=disconnected
mqttConnected = 0      -- Timestamp of MQTT connection, initially zero which will cause an immediate connection
airtopiaStates = {}    -- Current state topics in use (used for clean up)

airtopiaCmds = {'power', 'fan', 'swing', 'mode', 'target_temperature'} -- All command topics (used for clean up)
atmodes = {'auto', 'cool', 'heat', 'fan_only', 'dry', 'off'} -- Airtopia modes
atswings = {'Off', 'Horizontal only', 'Vertical only', 'Horizontal and Vertical'} -- Airtopia swing modes
atfans = {'Auto', '1', '2', '3', '4'} -- Airtopia fan speed (THIS IS UNTESTED, will result in 0, 1, 2, 3, 4 being set in the user parameter in the order of the list)

RETAIN = true          -- Boolean aliases for MQTT retain and no-retain settings
NORETAIN = false

FORCE = true           -- For logger. Use to force a log entry, regardless of the logging= value

heartbeat = socket.gettime()
started = socket.gettime()

function sleep(sec) socket.select(nil, nil, sec) end
function contains(prefix, text) local pos = text:find(prefix, 1, true); if pos then return pos >= 1 else return false end end -- Test whether a string contains a substring
function trim(s) if s ~= nil then return s:match "^%s*(.-)%s*$" else return nil end end -- Remove leading and trailing spaces
function tNetCBus(net) if net == 0 then return 254 else return net end end -- Translate AC network numbering to CBus
function tNetAC(net) if net == 254 then return 0 else return net end end -- Translate CBus network numbering to AC
function len(dict) local i = 0; local k; for k, _ in pairs(dict) do i = i + 1 end return(i) end -- Get number of dictionary members
function indexOf(array, value) for i, v in ipairs(array) do if v == value then return i end end return nil end -- Find the index number of an array member
function copy(obj, seen) -- Copy tables, 'seen' is for recursive use
  if type(obj) ~= 'table' then return obj end
  if seen and seen[obj] then return seen[obj] end
  local s = seen or {}
  local res = setmetatable({}, getmetatable(obj))
  s[obj] = res
  for k, v in pairs(obj) do res[copy(k, s)] = copy(v, s) end
  return res
end
function equals(o1, o2, ignore_mt)
  if ignoreMt == nil then ignoreMt = true end
  if o1 == o2 then return true end
  local o1Type = type(o1) local o2Type = type(o2)
  if o1Type ~= o2Type then return false end if o1Type ~= 'table' then return false end
  if not ignoreMt then local mt1 = getmetatable(o1) if mt1 and mt1.__eq then return o1 == o2 end end
  local keySet = {}
  for key1, value1 in pairs(o1) do local value2 = o2[key1] if value2 == nil or equals(value1, value2, ignore_mt) == false then return false end keySet[key1] = true end
  for key2, _ in pairs(o2) do if not keySet[key2] then return false end end
  return true
end
function logger(msg, force) -- Log helper
  if logging or force ~= nil then
    if logms then ts = string.format('%.3f ', socket.gettime()-started) else ts = '' end
    log(ts..msg)
  end
end

--[[
Register with the Heartbeat script
--]]
function isRegistered() local hbeat = storage.get('heartbeat', {}); local k; for k, _ in pairs(hbeat) do if k == _SCRIPTNAME then return true, hbeat end end return false, hbeat end
if sendHeartbeat > 0 then
  -- Check whether registration is required, and if not registered (or conditions changed) then register
  local r, hbeat = isRegistered()
  if not r or (r and not equals(hbeat[_SCRIPTNAME], heartbeatConditions)) then
    local k, v
    vals = '' for k, v in pairs(heartbeatConditions) do vals = vals..k..'='..v..' ' end
    logger('Registering '.._SCRIPTNAME..' with Heartbeat of '..vals, FORCE)
    hbeat[_SCRIPTNAME] = heartbeatConditions
    storage.set('heartbeat', hbeat)
  end
else -- Remove script from hearbeat registration
  local r, hbeat = isRegistered() if r then hbeat[_SCRIPTNAME] = nil storage.set('heartbeat', hbeat) end
end

--[[
UDP listener - receive messages from CBus level change event scripts
--]]

if server then server:close() end  -- Handle script re-entry
server = require('socket').udp()
server:settimeout(socketTimeout)
server:setsockname('127.0.0.1', 5432) -- Listen on port 5432 for CBus changes

--[[
Mosquitto client and call-backs
--]]

mqtt = require('mosquitto')
client = mqtt.new(mqttClientId)
client:will_set(mqttCbus..'status', 'offline', mqttQoS, RETAIN) -- Last will and testament is to set status offline
if mqttUsername then client:login_set(mqttUsername, mqttPassword) end

client.ON_CONNECT = function(success)
  if success then
    logger('MQTT connected', FORCE)
    client:publish(mqttCbus..'status', 'online', mqttQoS, RETAIN)
    mqttStatus = 1
    -- Subscribe to relevant topics
    client:subscribe(mqttWriteTopic..'#', mqttQoS)
    client:subscribe(mqttDiscoveryTopic..'#', mqttQoS)
    for k, _ in pairs(acBoards) do client:subscribe(k..'/#', mqttQoS) end
    for k, _ in pairs(atBoards) do client:subscribe('airtopia/'..k..'/#', mqttQoS) end
    for k, _ in pairs(envBoards) do client:subscribe(k..'/#', mqttQoS) end
  end
end

client.ON_DISCONNECT = function(...)
  logger('MQTT disconnected', FORCE)
  mqttStatus = 2
end

client.ON_MESSAGE = function(mid, topic, payload)
  -- Record discovery topics to check for duplication
  local parts = string.split(topic, '/')
  if parts[1] == string.split(mqttDiscoveryTopic, '/')[1] then
    if discovery[parts[3]] ~= nil then
      if discovery[parts[3]] ~= parts[2] then
        discoveryDelete[parts[3]..'/'..parts[2]] = true
      else
        discovery[parts[3]] = parts[2] -- Table of CBus addresses with type as the value
      end
    end
  else
    mqttMessages[#mqttMessages + 1] = { topic=topic, payload=payload } -- Queue the MQTT message
  end
end


--[[
Publish lighting and user parameter objects to MQTT 
--]]
function publish(net, app, group, level)
  if level == nil then logger('Warning: Nil CBus level for '..net..'/'..app..'/'..group, FORCE); do return end end
  local alias = net..'/'..app..'/'..group
  local aAlias = tNetAC(net)..'/'..app..'/'..group
  local state = ''
  if cover[alias] then
    state = 'stopped' -- For CBus blind controllers
  else
    state = (tonumber(level) ~= 0) and 'ON' or 'OFF'
  end
  if not userParameter[alias] then
    if not binarySensor[aAlias] then
      if bSensor[aAlias] then -- It's a bSensor
        client:publish(mqttReadTopic..alias..'/state', level, mqttQoS, RETAIN)
        logger('Publishing state '..mqttReadTopic..alias..' to '..level)
      elseif selects[aAlias] then -- It's a select
        local l
        for _, l in ipairs(selects[aAlias].allLvl) do
          if tonumber(level) <= l.lvl then
            if selectExact and tonumber(level) ~= l.lvl then
              -- Current CBus level does not match the select, so optionally adjust the CBus level
              SetCBusLevel(tNetAC(net), app, group, l.lvl, 0)
              -- Adjusting the level will result in two MQTT publish events, which could be avoided but is not
            end
            client:publish(mqttReadTopic..alias..'/select', l.sel, mqttQoS, RETAIN)
            logger('Publishing select '..mqttReadTopic..alias..' to '..l.sel..'('..l.lvl..')')
            break
          end
        end
      else -- It's a bog standard group
        client:publish(mqttReadTopic..alias..'/state', state, mqttQoS, RETAIN)
        client:publish(mqttReadTopic..alias..'/level', level, mqttQoS, RETAIN)
        logger('Publishing state and level '..mqttReadTopic..alias..' to '..state..'/'..level)
      end
    else -- It's a binary sensor
      client:publish(mqttReadTopic..alias..'/state', state, mqttQoS, RETAIN)
      logger('Publishing state '..mqttReadTopic..alias..' to '..state)
    end
  else -- It's a user parameter
    local adjust = publishAdj[alias]
    if adjust then v = tonumber(string.format('%.'..adjust.dec..'f', level * adjust.scale)) else v = level end
    client:publish(mqttReadTopic..alias..'/state', v, mqttQoS, RETAIN)
    logger('Publishing value '..mqttReadTopic..alias..' to '..v)
  end
end

--[[
Publish measurement application objects to MQTT 
--]]
function publishMeasurement(net, app, group, channel, value)
  local units, v
  local alias = net..'/'..app..'/'..group..'/'..channel
  if value == nil then logger('Warning: Nil CBus measurement value for '..net..'/'..app..'/'..group, FORCE); do return end end
  local adjust = publishAdj[alias]
  if adjust then v = tonumber(string.format('%.'..adjust.dec..'f', value * adjust.scale)) else v = value end
  if includeUnits[alias] then
    _, units = GetCBusMeasurement(net, group, channel)
    if units == '$' then
      v = units..tostring(v)
    elseif units == '%' then
      v = v..units
    else
      v = v..' '..units
    end
  end
  client:publish(mqttReadTopic..net..'/'..app..'/'..group..'_'..channel..'/state', v, mqttQoS, RETAIN)
  -- logger('Publishing measurement '..mqttReadTopic..net..'/'..app..'/'..group..'_'..channel..' to '..v)
end

--[[
Publish Panasonic ESPHome objects to MQTT 
--]]
function publishAc(net, app, group, level, select)
  if level == nil then logger('Warning: Nil AC level for '..net..'/'..app..'/'..group, FORCE); do return end end
  local alias = net..'/'..app..'/'..group
  if ac[alias].state ~= level then
    if ignoreMqtt[alias] and (socket.gettime() - ignoreMqtt[alias] > ignoreTimeout) then -- Don't worry about older 'ignore' flags
      ignoreMqtt[alias] = nil
      logger('Ignoring older MQTT ignore flag for '..alias)
    end
    if not ignoreMqtt[alias] then
      local parts = string.split(ac[alias].name, '-')
      local board = parts[1]
      local topic = ''
      if select == 'func' then
        topic = board..'/climate/panasonic/'..parts[2]..'/command'
      elseif select == 'sel' then
        topic = board..'/select/'..parts[2]..'/command'
      elseif select == 'sense' then
        logger('Warning: Not publishing sensor change for alias='..alias)
      else
        logger('Invalid AC command for alias='..alias..', select='..tostring(select), FORCE)
      end
      if topic ~= '' then client:publish(topic, level, mqttQoS, NORETAIN) end
      -- Publishing to MQTT here will result in outstandingMqttMessage() below setting the CBus state for the group.
      -- This is undesired, so ignoreCbus[alias] is used to ensure that the MQTT change received does not set CBus.
      if acState ~= ac[alias].state then ignoreCbus[alias] = socket.gettime() end
      logger('Published AC '..ac[alias].name..' to '..level)
    else
      ignoreMqtt[alias] = nil
      logger('Ignoring MQTT publish for '..alias)
    end
    ac[alias].state = level
  else
    ignoreMqtt[alias] = nil
    logger('Ignoring MQTT publish for '..alias)
  end
end

--[[
Publish Airtopia MODBUS objects to MQTT 
--]]
function publishAt(net, app, group, level)
  if level == nil then logger('Warning: Nil AT level for '..net..'/'..app..'/'..group, FORCE); do return end end
  local alias = net..'/'..app..'/'..group
  if at[alias].state ~= level then
    if ignoreMqtt[alias] and (socket.gettime() - ignoreMqtt[alias] > ignoreTimeout) then -- Don't worry about older 'ignore' flags
      ignoreMqtt[alias] = nil
      logger('Ignoring older MQTT ignore flag for '..alias)
    end
    if not ignoreMqtt[alias] then
      local parts = string.split(at[alias].name, '-')
      local board = parts[1]
      local topic = 'airtopia/'..board..'/state/'..parts[2]
      local adjust = publishAdj[alias]
      if adjust then level = tonumber(string.format('%.'..adjust.dec..'f', level * adjust.scale)) end
      client:publish(topic, level, mqttQoS, RETAIN)
      -- Publishing to MQTT here will result in outstandingMqttMessage() below setting the CBus state for the group.
      -- This is undesired, so ignoreCbus[alias] is used to ensure that the MQTT change received does not set CBus.
      if atState ~= at[alias].state then ignoreCbus[alias] = socket.gettime() end
      logger('Published AT '..at[alias].name..' to '..level)
      -- Determine whether a HomeAssistant state topic needs to be also published
      local st = nil
      local prefix = nil
      local dev = nil
      for k, v in pairs(atDevices) do
        if v == alias then prefix = string.split(k, '-')[1]; st = string.split(k, '-')[2]; break end
      end
      if st == nil then
      elseif st == 'horiz_swing' then
        -- Publish swingha
        local o = atDevices[prefix..'-vert_swing']
        if o ~= nil then
          parts = string.split(o, '/'); net = parts[1]; group = parts[3]; 
          local v = bit.lshift(GetUserParam(net, group), 1)
          local topic = 'airtopia/'..prefix..'/state/swingha'
          local s = bit.bor(tonumber(level), v) + 1
          client:publish(topic, atswings[s], mqttQoS, RETAIN)
        end
      elseif st == 'vert_swing' then
        -- Publish swingha
        local o = atDevices[prefix..'-horiz_swing']
        if o ~= nil then
          parts = string.split(o, '/'); net = parts[1]; group = parts[3]; 
          local h = GetUserParam(net, group)
          local topic = 'airtopia/'..prefix..'/state/swingha'
          local v = bit.lshift(tonumber(level), 1)
          local s = bit.bor(h, v) + 1
          client:publish(topic, atswings[s], mqttQoS, RETAIN)
        end
      elseif st == 'fan' then
        -- Publish fanha
        local fanv = atfans[level+1]
        local topic = 'airtopia/'..board..'/state/fanha'
        client:publish(topic, fanv, mqttQoS, RETAIN)
      end
    else
      ignoreMqtt[alias] = nil
      logger('Ignoring MQTT publish for '..alias)
    end
    at[alias].state = level
  else
    ignoreMqtt[alias] = nil
    logger('Ignoring MQTT publish for '..alias)
  end
end


--[[
Build and publish a CBus MQTT discovery topic
--]]
function addDiscover(net, app, group, channel, tags, name)
  local allow = {'light', 'fan', 'fan_pct', 'cover', 'select', 'sensor', 'switch', 'binary_sensor', 'bsensor', 'button'}
  local function allowed(val) local v; for _, v in ipairs(allow) do if v == val then return true end end return false end
  if not name then -- Need a name from tag lookup for everything but measurement app
    if channel == nil then
      logger('Warning: nil channel for name '..str(name)..' at '..net..'/'..app..'/'..group..'... a namne is required so ignoring', FORCE)
      do return end
    else
      name = 'measurement'
    end
  end
  local pn = name
  -- All other keywords except MQTT are optional (some exceptions), with 'light' as default discovery type. Defaults:
  local sa = ''         -- Suggested area
  local img = ''        -- Image
  local units = ''      -- Units
  local class = ''      -- HA class
  local scale = 1       -- Scale (multiplier or divider)
  local decimals = 2    -- Decimal places
  local on = 'On'       -- bsensor 'on' string
  local off = 'Off'     -- bsensor 'off' string
  local levels = {}     -- Assume lvl= keyword is blank
  local dType = 'light' -- Use light as default HA type if not specified
  local includeUnit = False
  local lvl = false
  
  -- Build an alias to refer to each group
  alias = tNetAC(net)..'/'..app..'/'..group;  if channel ~= nil then alias = alias..'/'..channel end

  -- Extract MQTT topic settings
  for _, t in ipairs(tags) do
    tp = string.split(t, '=')
    tp[1] = trim(tp[1]):lower()
    if tp[1] == 'includeunit' then includeUnit = true
    end
    if tp[2] then
      tp[2] = trim(tp[2])
      if tp[1] == 'sa' then sa = tp[2]
      elseif tp[1] == 'pn' then pn = tp[2]
      elseif tp[1] == 'img' then img = tp[2]
      elseif tp[1] == 'unit' then units = tp[2]
      elseif tp[1] == 'class' then class = tp[2]
      elseif tp[1] == 'dec' then decimals = tonumber(tp[2])
      elseif tp[1] == 'scale' then scale = tonumber(tp[2])
      elseif tp[1] == 'on' then on = tp[2]
      elseif tp[1] == 'off' then off = tp[2]
      elseif tp[1] == 'lvl' then levels = string.split(tp[2], '-'); lvl = true
      end
    else
      if allowed(tp[1]) then dType = tp[1] end
    end
    -- Any other unrecognised keywords that may be set are ignored
  end
  
  -- Default images for a lighting group
  if img == '' and lighting[tostring(app)] then
    local pnl = pn:lower()
    if contains('heat', pnl) then img = 'mdi:radiator'
    elseif contains('blind', pnl) then img = 'mdi:blinds'
    elseif contains('under floor', pnl) then if contains('enable', pnl) then img = 'mdi:radiator-disabled' else img = 'mdi:radiator' end
    elseif contains('towel rail', pnl) then if contains('enable', pnl) then img = 'mdi:radiator-disabled' else img = 'mdi:radiator' end
    elseif contains('fan', pnl) then if contains('sweep', pnl) then img = 'mdi:ceiling-fan' else img = 'mdi:fan' end
    elseif contains('gate', pnl) then if contains('open', pnl) then img = 'mdi:gate-open' else img = 'mdi:gate' end
    else img = 'mdi:lightbulb'
    end
  end

  if dtype == 'light' and app == 228 then dtype = 'sensor'; logger('Warning: publishing '..alias..' as a sensor', FORCE) end -- Measurement app sensor with incorrect/missing type
  if includeUnit then includeUnits[alias] = true log(includeUnits) else includeUnits[alias] = nil end
  if logging then
    if sa == '' then dSa = 'no preferred area' else dSa = sa end
    if dType ~= 'bsensor' then
    	logger('Publish discovery '..name..' as '..dType..':'..pn..' in area '..dSa, FORCE)
    else
    	logger('Publish discovery '..name..' as sensor:'..pn..' in area '..dSa, FORCE)
    end
  end

  -- Build an OID (measurement application gets a channel as well), also add to mqttDevices
  oid = 'cbus_mqtt_'..net..'_'.. app..'_'..group; if channel ~= nil then oid = oid..'_'..channel end;
  mqttDevices[alias].oid = oid
  if dType ~= 'bsensor' then
    mqttDevices[alias].type = dType
  else
    mqttDevices[alias].type = 'sensor'
  end
  aAlias = alias -- Automation controller numbered networks
  alias = net..'/'..app..'/'..group -- Will adjust for CBus numbered networks

  -- Build the type-specific payload to publish
  if dType == 'light' then
    payload = {
      stat_t = mqttReadTopic..alias..'/state',
      cmd_t = mqttWriteTopic..alias..'/switch',
      bri_stat_t = mqttReadTopic..alias..'/level',
      bri_cmd_t = mqttWriteTopic..alias..'/ramp',
      pl_off = 'OFF',
      on_cmd_type = 'brightness',
    }

  elseif dType == 'switch' then
    payload = {
      stat_t = mqttReadTopic..alias..'/state',
      cmd_t = mqttWriteTopic..alias..'/switch',
      pl_on = 'ON',
      pl_off = 'OFF',
    }

  elseif dType == 'fan' then
    payload = {
      stat_t = mqttReadTopic..alias..'/state',
      cmd_t = mqttWriteTopic..alias..'/ramp',
      pl_on = 'ON',
      pl_off = 'OFF',
      pr_mode_cmd_t = mqttWriteTopic..alias..'/ramp',
      pr_mode_cmd_tpl = '{% if value == "low" %} 86 {% elif value == "medium" %} 170 {% elif value == "high" %} 255 {% endif %}',
      pr_mode_stat_t = mqttReadTopic..alias..'/level',
      pr_mode_val_tpl = '{% if value == 0 %} OFF {% elif value == 86 %} low {% elif value == 170 %} medium {% elif value == 255 %} high {% endif %}',
      pr_modes = {'low', 'medium', 'high'}
    }
    fan[aAlias] = true

  elseif dType == 'fan_pct' then
    payload = {
      stat_t = mqttReadTopic..alias..'/state',
      cmd_t = mqttWriteTopic..alias..'/switch',
      pl_on = 'ON',
      pl_off = 'OFF',
      pct_cmd_t = mqttWriteTopic..alias..'/ramp',
      pct_stat_t = mqttReadTopic..alias..'/level',
      opt = true,
    }
    dType = 'fan'
    fan[aAlias] = true

  elseif dType == 'cover' then
    payload = {
      stat_t = mqttReadTopic..alias..'/state',
      cmd_t = mqttWriteTopic..alias..'/ramp',
      pos_open = 255,
      pos_clsd = 0,
      pl_open = 'OPEN',
      pl_cls = 'CLOSE',
      pos_t = mqttReadTopic..alias..'/level',
      set_pos_t = mqttWriteTopic..alias..'/ramp',
    }
    cover[alias] = true

  elseif dType == 'select' then
    if not lvl then
      logger('Error: lvl= keyword not specified for select at '..aAlias..', which is required so ignoring', FORCE)
      do return end
    end
    local level, parts
    local options = {}
    selects[aAlias] = {}
    for _, level in ipairs(levels) do
      local parts = string.split(level, '/')
      if #parts == 2 then -- A select option and level
        options[#options + 1] = parts[1]
        selects[aAlias][parts[1]] = tonumber(parts[2])
      elseif #parts == 1 and tonumber(parts[1]) then -- Level numbers only
        parts[2] = parts[1]
        parts[1] = GetCBusLevelTag(tNetAC(net), app, group, tonumber(parts[2]))
        if not parts[1] then
          logger('Error: No level tag for select '..aAlias..', level '..parts[2]..' which is required so ignoring', FORCE)
          do return end
        end
        options[#options + 1] = parts[1]
        selects[aAlias][parts[1]] = tonumber(parts[2])
      elseif #parts == 1 then -- Level tags only
        parts[2] = GetCBusLevelAddress(tNetAC(net), app, group, parts[1])
        if not parts[2] then
          logger('Error: Invalid level tag for select '..aAlias..', level '..parts[1]..', so not adding and ignoring', FORCE)
          do return end
        end
        options[#options + 1] = parts[1]
        selects[aAlias][parts[1]] = tonumber(parts[2])
      else
        logger('Error: Invalid lvl= format for select '..aAlias..', so not adding and ignoring', FORCE)
        do return end
      end
      if not selects[aAlias].allLvl then selects[aAlias].allLvl = {} end; selects[aAlias].allLvl[#selects[aAlias].allLvl + 1] = { lvl = tonumber(parts[2]), sel = parts[1] }
    end
    table.sort(selects[aAlias].allLvl, function (left, right) return left.lvl < right.lvl end)
    payload = {
      stat_t = mqttReadTopic..alias..'/select',
      cmd_t = mqttWriteTopic..alias..'/select',
      options = options,
    }

  elseif dType == 'sensor' then
    if channel ~= nil then
      payload = { stat_t = mqttReadTopic..alias..'_'..channel..'/state', }
      alias = alias..'/'..channel
    else
      payload = { stat_t = mqttReadTopic..alias..'/state', }
    end
    if class ~= '' then payload.dev_cla = class end
    if app == 250 then userParameter[alias] = true end
    if decimals ~= 2 or scale ~= 1 then publishAdj[alias] = { dec = decimals, scale = scale } end -- Scale, decimals and units only for sensors
    if units ~= '' then payload.unit_of_meas = units end

  elseif dType == 'bsensor' then
    dType = 'sensor'
    payload = {
      stat_t = mqttReadTopic..alias..'/state',
      val_tpl = '{% if value | float == 0 %} '..off..' {% else %} '..on..' {% endif %}',
    }
    bSensor[aAlias] = true

  elseif dType == 'binary_sensor' then
    payload = {
      stat_t = mqttReadTopic..alias..'/state',
      pl_on = 'ON',
      pl_off = 'OFF',
    }
    binarySensor[aAlias] = true

  elseif dType == 'button' and app == 202 then
    local i
    mqttDevices[aAlias].trigger = {}
    if #levels == 0 then for i = 0,255 do levels[#levels + 1] = i end end -- If no "lvl=" specified then scan all levels
    for _, i in ipairs(levels) do 
      tag = GetCBusLevelTag(tNetAC(net), 202, group, tonumber(i))
      if not tag then
        if publishNoLevel then
          if lvl then
            tag = 'Level '..i
            logger('Warning: Trigger '..alias..' has no level tag defined for level '..i..', setting to "'..tag..'"', FORCE)
          end
        else
          if lvl then logger('Error: Trigger '..alias..' has no level tag defined for level '..i, FORCE) end
        end
      end
      if tag then
        boid = oid..'_'..i
        action = tag:gsub("%s+", "_"):lower()
        if triggers[group] == nil then triggers[group] = {} end
        triggers[group][action] = tonumber(i)
        if pn == name then prefix = '' else prefix = pn..' ' end
        local entity = prefix..tag
        if sa ~= '' then
          local startIdx, endIdx
          repeat
            startIdx, endIdx = entity:find(sa, 1, true)
            if startIdx and startIdx == 1 then
              entity = entity:sub(endIdx + 1):match'^%s*(.*)'
            end
          until not startIdx or startIdx > 1
        end
        payload = {
          name = '',
          obj_id = boid,
          uniq_id = boid,
          cmd_t = mqttWriteTopic..alias..'/'..action..'/press',
          dev = { name=entity, ids=trim(sa..' '..entity), sa=sa, mf='Schneider Electric', mdl='CBus' },
        }
        if img ~= '' then payload.ic = img end
        -- If dType has changed for an existing discovery topic then remove the previous topic
        if discovery[boid] ~= nil and discovery[boid] ~= dType then
          client:publish(mqttDiscoveryTopic..discovery[boid]..'/'..boid..'/config', '', mqttQoS, RETAIN)
          logger('Removed discovery topic'..mqttDiscoveryTopic..discovery[boid]..'/'..boid..'/config')
        end
        -- Publish to MQTT broker
        local j = json.encode(payload)
        logger('Publishing '..mqttDiscoveryTopic..dType..'/'..boid..'/config')
        client:publish(mqttDiscoveryTopic..dType..'/'..boid..'/config', j, mqttQoS, RETAIN)
        table.insert(mqttDevices[aAlias].trigger, boid)
      end
    end
    do return end

  elseif dType == 'button' and lighting[tostring(app)] then
    -- Lighting group button
    payload = {
      cmd_t = mqttWriteTopic..alias..'/press',
    }
    lightingButton[aAlias] = true

  elseif dType == 'button' then
    logger('Error: MQTT button keyword used for unsupported application group '..aAlias..', so ignoring', FORCE)
    do return end
  end

  -- Add payload common to all
  local entity = pn
  if sa ~= '' then
    local startIdx, endIdx
    repeat
      startIdx, endIdx = entity:find(sa, 1, true)
      if startIdx and startIdx == 1 then
        entity = entity:sub(endIdx + 1):match'^%s*(.*)'
      end
    until not startIdx or startIdx > 1
  end

  payload.name = ''
  payload.obj_id = oid
  payload.uniq_id = oid
  payload.avty_t = mqttCbus..'status'
  payload.dev = { name=entity, ids=trim(sa..' '..entity), sa=sa, mf='Schneider Electric', mdl='CBus' }
  if img ~= '' then payload.ic = img end

  -- If dType has changed for an existing discovery topic then remove the previous topic
  if discovery[oid] ~= nil and discovery[oid] ~= dType then
    client:publish(mqttDiscoveryTopic..discovery[oid]..'/'..oid..'/config', '', mqttQoS, RETAIN)
    logger('Removed discovery topic '..mqttDiscoveryTopic..discovery[oid]..'/'..oid..'/config')
  end

  -- Publish to MQTT broker
  discovery[oid] = dType
  local j = json.encode(payload)
  logger('Publishing '..mqttDiscoveryTopic..dType..'/'..oid..'/config')
  client:publish(mqttDiscoveryTopic..dType..'/'..oid..'/config', j, mqttQoS, RETAIN)
end

--[[
Build and publish an Airtopia discovery topic
--]]
function addAtDiscover(name, sa, unit)
  if logging then
    if sa == '' then dSa = 'no preferred area' else dSa = sa end
    logger('Publish discovery '..name..' in area '..dSa, FORCE)
  end
  if unit == nil then unit = 'A' end

  -- Build an OID and name prefix
  local sao = ''; if sa ~= '' then sao = string.lower(sa:gsub("% ", "_"))..'_' end
  local oid = 'cbus_mqtt_'..sao..string.lower(name:gsub("% ", "_"))

  payload = {
    name = '',
    obj_id = oid,
    uniq_id = oid,
    avty_t = mqttCbus..'status',
    dev = { name=name, ids=sa..' '..name, sa=sa, mf='Schneider Electric', mdl='Airtopia' },
    mode_cmd_t = 'airtopia/'..sao..name..'/cmd/mode',
    mode_stat_t = 'airtopia/'..sao..name..'/state/modeha',
    pow_cmd_t = 'airtopia/'..sao..name..'/cmd/power',
    temp_cmd_t = 'airtopia/'..sao..name..'/cmd/target_temperature',
    temp_stat_t = 'airtopia/'..sao..name..'/state/target_temperature',
    curr_temp_t = 'airtopia/'..sao..name..'/state/current_temperature',
    swing_modes = atswings,
    swing_mode_cmd_t = 'airtopia/'..sao..name..'/cmd/swing',
    swing_mode_stat_t = 'airtopia/'..sao..name..'/state/swingha',
    fan_modes = atfans,
    fan_mode_cmd_t = 'airtopia/'..sao..name..'/cmd/fan',
    fan_mode_stat_t = 'airtopia/'..sao..name..'/state/fanha',
    temp_unit = "C",
    opt = false,
    pl_on = 'ON',
    pl_off = 'OFF',
    precision = 1.0,
  }

  -- Publish to MQTT broker
  local j = json.encode(payload)
  logger('Publishing '..mqttDiscoveryTopic..'climate/'..oid..'/config')
  client:publish(mqttDiscoveryTopic..'climate/'..oid..'/config', j, mqttQoS, RETAIN)

  -- Add a power consumption sensor discovery topic
  payload = {
    name = '',
    obj_id = oid..'_power',
    uniq_id = oid..'_power',
    avty_t = mqttCbus..'status',
    dev = { name=name..' Power Consumption', ids=sa..' '..name..' Power Consumption', sa=sa, mf='Schneider Electric', mdl='Airtopia' },
    stat_t = 'airtopia/'..sao..name..'/state/power_consumption',
    unit_of_meas = unit,
  }
  local j = json.encode(payload)
  logger('Publishing'..mqttDiscoveryTopic..'sensor/'..oid..'_power'..'/config')
  client:publish(mqttDiscoveryTopic..'sensor/'..oid..'_power'..'/config', j, mqttQoS, RETAIN)
end


--[[
Add Airtopia objects 
--]]
atLog = {}
atLogGrp = {}
function addAt(grps, found)
  local atArea = {}
  local atDevs = {}
  local k, v
  local addition = false
  local scan = {}
  local found = {}
  for k, v in pairs(grps) do
    local net = v.address[1]; local app = v.address[2]; local group = v.address[3]
    local pn = v.name
    local alias = table.concat(v.address, '/')
    local unit = 'A'
    local scale = 1
    local decimals = 2

    local dev = ''; local func = ''; local sense = ''; local sa = ''; local tags = v.keywords
    for _, t in ipairs(tags) do
      tp = string.split(t, '=')
      tp[1] = trim(tp[1])
      if tp[2] then
        tp[2] = trim(tp[2])
        if tp[1] == 'dev' then dev = tp[2]; atDevs[dev] = true -- Device
        elseif tp[1] == 'func' then func = tp[2] -- Function
        elseif tp[1] == 'sense' then sense = tp[2] -- Sensor
        elseif tp[1] == 'dec' then decimals = tonumber(tp[2])
        elseif tp[1] == 'scale' then scale = tonumber(tp[2])
        elseif tp[1] == 'unit' then unit = tp[2]
        elseif tp[1] == 'sa' then
          sa = tp[2] -- Suggested area
          if atArea[dev] == nil then
            atArea[dev] = sa  -- The suggested area found is noted as being applicable for all user params of the device; only one is needed
            atLog[dev] = nil
          end
        end
      end
    end
    if sense ~= '' then
      if scale ~= 1 or decimals ~= 2 then publishAdj[alias] = { dec=decimals, scale=scale } end
    end
    scan[#scan+1] = {alias=alias, dev=dev, func=func, sense=sense, unit=unit}
  end

  for _, v in ipairs(scan) do
    if v['dev'] ~= '' then
      if atLog[v['dev']] == nil and atArea[v['dev']] == nil then
        logger('Error: No suggested area set for Airtopia device '..v['dev']..'. At least one user parameter needs "sa="', FORCE)
        atLog[v['dev']] = true -- Logged for the device, so do not log any further related user param issues for the device
        goto nextAt
      end
      if at[v['alias']] == nil and atArea[v['dev']] ~= nil then
        local sa = atArea[v['dev']]; if sa == nil then sa = '' end
        local sao = ''; if sa ~= '' then sao = string.lower(sa:gsub("% ", "_"))..'_' end
        local parts = string.split(v['alias'], '/')
        local net = parts[1]; local app = parts[2]; local group = parts[3]
        if v['func'] ~= '' then
          if not at[v['alias']] then
            at[v['alias']] = {}; addition = true
            at[v['alias']].name = sao..v['dev']..'-'..v['func']; at[v['alias']].select = 'func'; atDevices[sao..v['dev']..'-'..v['func']] = v['alias'];
            if atBoards[sao..v['dev']] == nil and v['func'] == 'power' then atBoards[sao..v['dev']] = {alias=v['alias'], dev=v['dev'], sa=sa} end
            publishAt(net, app, group, GetUserParam(net, group))
            atLog[v['dev']] = nil
            atLogGrp[v['alias']] = nil
          end
        elseif sense ~= '' then
          if not at[v['alias']] then
            if atBoards[sao..v['dev']] ~= nil then
              at[v['alias']] = {}; addition = true
              at[v['alias']].name = sao..v['dev']..'-'..v['sense']; at[v['alias']].select = 'sense'; at[v['alias']].sense = v['sense']; atDevices[sao..v['dev']..'-'..v['sense']] = v['alias']
              atBoards[sao..v['dev']]['unit'] = v['unit']
              publishAt(net, app, group, GetUserParam(net, group))
              atLog[v['dev']] = nil
              atLogGrp[v['alias']] = nil
            end
          end
        end
      end
    else
      if not atLogGrp[v['alias']] then logger('Error: No device specified for Airtopia group '..v['alias'], FORCE); atLogGrp[v['alias']] = true end
    end
    ::nextAt::
    if at[v['alias']] ~= nil and atArea[v['dev']] ~= nil then
      table.insert(found, v['alias']) -- Valid, having a sa=, so found (otherwise removed elsewhere if an existing device)
    end
  end
  return addition, found
end

--[[
Queue up initial discovery and current state CBus objects, plus Airtopia if used
--]]
function publishCurrent()
  -- CBus
  mqttDevices = {}
  local grps = GetCBusByKW('MQTT', 'or')
  local n = 0
  local i, v
  for _, v in pairs(grps) do
    n = n + 1
    local alias = table.concat(v.address, '/')
    table.sort(v.keywords)
    local name; if v.name then name = v.name else name = GetCBusGroupTag(v.address[1], v.address[2], v.address[3]) end
    unpublished[n] = {net=v.address[1], app=v.address[2], group=v.address[3], channel=v.address[4], tags=v.keywords, name=name}
    if not mqttDevices[alias] then mqttDevices[alias] = {}; mqttDevices[alias].tags = table.concat(v.keywords,',') end
  end
  if n > 0 then logger('Queued '..n..' objects with keyword MQTT for publication') end

  -- Airtopia
  atDevices = {}
  grps = GetCBusByKW('AT', 'or')
  addAt(grps)
  local raw = {}
  local dev
  for k, v in ipairs(grps) do
    local tags = v['keywords']
    dev = ''; local sa = nil
    for _, tag in ipairs(tags) do
      local parts = string.split(tag, '=')
      if parts[1] == 'dev' then
        dev = parts[2]
      elseif parts[1] == 'sa' then
        sa = parts[2]
      end
    end
    if dev ~= '' then
      if sa ~= nil then raw[dev] = sa end
    else
      if not atLogGrp[table.concat(v['address'], '/')] then
        logger('Error: No device specified for Airtopia group '..table.concat(v['address'], '/'), FORCE)
        atLogGrp[table.concat(v['address'], '/')] = true
      end
    end
  end
  n = 0
  for k, v in pairs(raw) do
    n = n + 1
    unpublishedAt[n] = {name=k, sa=v}
  end
  if n > 0 then logger('Queued '..n..' objects with keyword AT for publication') end
end


--[[
Create / update / delete AC devices
--]]
acLogGrp = {}
function cudAc(initial)
  local grps = GetCBusByKW('AC', 'or')
  local found = {}
  local addition = false
  local k, v

  for k, v in pairs(grps) do
    local net = v.address[1]; local app = v.address[2]; local group = v.address[3]
    local pn = v.name
    local alias = table.concat(v.address, '/')

    table.insert(found, alias)

    local dev=''; local func = ''; local sel = ''; local sense = ''; local topic = 'sensor'; local tags = v.keywords
    for _, t in ipairs(tags) do
      tp = string.split(t, '=')
      tp[1] = trim(tp[1])
      if tp[2] then
        tp[2] = trim(tp[2])
        if tp[1] == 'dev' then dev = tp[2] -- Device
        elseif tp[1] == 'func' then func = tp[2] -- Function
        elseif tp[1] == 'sel' then sel = tp[2] -- Select
        elseif tp[1] == 'sense' then sense = tp[2] -- Sensor
        elseif tp[1] == 'topic' then topic = tp[2] -- Topic for sensor
        end
      end
    end
    if dev ~= '' then
      if func ~= '' then
        if not ac[alias] then ac[alias] = {}; addition = true end
      	ac[alias].name = dev..'-'..func; ac[alias].select = 'func'; acDevices[dev..'-'..func] = alias; acBoards[dev] = true
      elseif sel ~= '' then
        if not ac[alias] then ac[alias] = {}; addition = true end
      	ac[alias].name = dev..'-'..sel; ac[alias].select = 'sel'; acDevices[dev..'-'..sel] = alias; acBoards[dev] = true
      elseif sense ~= '' then
        if not ac[alias] then ac[alias] = {}; addition = true end
      	ac[alias].name = dev..'-'..sel; ac[alias].select = 'sense'; ac[alias].sense = sense; ac[alias].topic = topic; acDevices[dev..'-'..sense] = alias; acBoards[dev] = true
      end
      acLogGrp[alias] = nil
    else
      if not acLogGrp[alias] then logger('Error: No device specified for Panasonic '..alias, FORCE); acLogGrp[alias] = true end
    end
  end
    
  -- Handle deletions
  for k, _ in pairs(ac) do
    local f = false; for _, v in ipairs(found) do if k == v then f = true; break end end
    if not f then kill = ac[k].name; ac[k] = nil; acDevices[kill] = nil end
  end
  -- Handle additions, and re-subscribe all board topics to get status of newly added devices
  if addition then
    if not initial then
      -- Ensure that newly tagged/removed groups with the AC keyword send updates.
      logger('AC object keywords added, restarting event script', FORCE)
      script.disable('AC'); script.enable('AC')
    end
    for k, _ in pairs(acBoards) do client:subscribe(k..'/#', 2) end
  end
end


--[[
Publish the state of Airtopia devices
--]]
function publishAtState()
  for k, _ in pairs(atBoards) do
    local parts
    mode = atDevices[k..'-mode']
    power = atDevices[k..'-power']
    if mode ~= nil and power ~= nil then
      parts = string.split(mode, '/'); local mnet = tonumber(parts[1]); local mgroup = tonumber(parts[3])
      parts = string.split(power, '/'); local pnet = tonumber(parts[1]); local pgroup = tonumber(parts[3])
      local topic = 'airtopia/'..k..'/state/modeha'
      local level
      if GetUserParam(pnet, pgroup) == 0 then
        level = 'off'
      else
        level = atmodes[GetUserParam(mnet, mgroup)]
      end
      client:publish(topic, level, mqttQoS, RETAIN)
    end
    local hswing = atDevices[k..'-horiz_swing']
    local vswing = atDevices[k..'-vert_swing']
    if hswing ~= nil and vswing ~= nil then
      parts = string.split(hswing, '/'); local hnet = tonumber(parts[1]); local hgroup = tonumber(parts[3])
      parts = string.split(vswing, '/'); local vnet = tonumber(parts[1]); local vgroup = tonumber(parts[3])
      local topic = 'airtopia/'..k..'/state/swingha'
      local level
      local h = GetUserParam(hnet, hgroup)
      local v = bit.lshift(GetUserParam(vnet, vgroup), 1)
      local s = bit.bor(h, v) + 1
      client:publish(topic, atswings[s], mqttQoS, RETAIN)
    end
    local fan = atDevices[k..'-fan']
    if fan ~= nil then
      parts = string.split(fan, '/'); local fnet = tonumber(parts[1]); local fgroup = tonumber(parts[3])
      local topic = 'airtopia/'..k..'/state/fanha'
      local level
      local f = GetUserParam(fnet, fgroup)
      client:publish(topic, atfans[f+1], mqttQoS, RETAIN)
    end
    client:subscribe('airtopia/'..k..'/#', 2)
  end
end


--[[
Create / update / delete Airtopia devices
--]]
function cudAt(initial)
  local grps = GetCBusByKW('AT', 'or')
  local boards = copy(atBoards)
  local k, v
  unpublishedAt = {}
  
  local addition, found = addAt(grps)

  -- Handle deletions
  local kill
  for k, _ in pairs(at) do
    local f = false; for _, v in ipairs(found) do if k == v then f = true; break end end
    if not f then kill = at[k].name; at[k] = nil; atDevices[kill] = nil end
  end
  local newBoards = {}
  for k, _ in pairs(atDevices) do
    local parts = string.split(k, '-')
    newBoards[parts[1]] = true
  end
  kill = {} for k, _ in pairs(atBoards) do if newBoards[k] == nil then table.insert(kill, k) end end
  for _, k in ipairs(kill) do
    atBoards[k] = nil;
    -- Clean up discovery topics
    topic = mqttDiscoveryTopic..'climate/'..'cbus_mqtt_'..k..'/config'; client:publish(topic, '', mqttQoS, RETAIN); logger('Removed discovery topic '..topic, FORCE)
    topic = mqttDiscoveryTopic..'sensor/'..'cbus_mqtt_'..k..'_power/config'; client:publish(topic, '', mqttQoS, RETAIN);  logger('Removed discovery topic '..topic, FORCE)
    -- Clean up state and cmd topics under airtopia/device
    for _, v in ipairs(airtopiaStates) do client:publish('airtopia/'..k..'/state/'..v, '', mqttQoS, RETAIN) end
    for _, v in ipairs(airtopiaCmds) do client:publish('airtopia/'..k..'/cmd/'..v, '', mqttQoS, RETAIN) end
    logger('Removed device command and state topics', FORCE)
  end

  -- Handle additions, and re-subscribe all board topics to get status of newly added devices
  local n = 0
  for k, v in pairs(atBoards) do
    if boards[k] == nil then
      if v['sa'] ~= nil then
        n = n + 1
        unpublishedAt[n] = {name=v['dev'], sa=v['sa'], unit=v['unit']}
      else
        logger('Error publishing Airtopia '..k..'. No suggested area given', FORCE)
      end
    end
  end
      
  if addition then
    if not initial then
      -- Ensure that newly tagged/removed groups with the AT keyword send updates.
      logger('AT object keywords added, restarting event script', FORCE)
      script.disable('AT'); script.enable('AT')
    end
    publishAtState()
  end
end

--[[
Create / update / delete ENV (environment) devices
--]]
envLogGrp = {}
function cudEnv(initial)
  local grps = GetCBusByKW('ENV', 'or')
  local found = {}
  local addition = false
  local k, v

  for k, v in pairs(grps) do
    local net = v.address[1]; local app = v.address[2]; local group = v.address[3]
    local alias = table.concat(v.address, '/')

    table.insert(found, alias)

    local dev=''; local func = ''; local sel = ''; local tags = v.keywords
    for _, t in ipairs(tags) do
      tp = string.split(t, '=')
      tp[1] = trim(tp[1])
      if tp[2] then
        tp[2] = trim(tp[2])
        if tp[1] == 'dev' then dev = tp[2] -- Device
        elseif tp[1] == 'func' then func = tp[2] -- Function
        end
      end
    end
    if dev ~= '' then
      if func == '' then
        if v.name then n = v.name else n = GetCBusGroupTag(net, app, group) end
        func = n:lower():gsub("%s+", "_")
      end
      if not env[alias] then env[alias] = {}; addition = true end
      env[alias].name = dev..'-'..func; envDevices[dev..'-'..func] = alias; envBoards[dev] = true
      envLogGrp[alias] = nil
    else
      if not envLogGrp[alias] then logger('Error: No device specified for environment sensor '..alias, FORCE); envLogGrp[alias] = true end
    end
  end
    
  -- Handle deletions
  for k, _ in pairs(env) do
    local f = false; for _, v in ipairs(found) do if k == v then f = true; break end end
    if not f then kill = env[k].name; env[k] = nil; envDevices[kill] = nil end
  end
  -- Handle additions, and re-subscribe all board topics to get status of newly added devices
  if addition then
    if not initial then logger('ENV object keyword added', FORCE) end
    for k, _ in pairs(envBoards) do client:subscribe(k..'/#', 2) end
  end
end

--[[
Create / update / delete CBus MQTT discovery topics
--]]
function cudCBusTopics()
  local grps = GetCBusByKW('MQTT', 'or')
  local found = {}
  local lvlDelete = {}
  local n = 0
  unpublished = {}
  local queued = {}
  local k, v, alias, lvl

  for k, v in pairs(grps) do
    local change = false
    local net = v.address[1]; local app = v.address[2]; local group = v.address[3]; local channel = nil; if v.address[4] then channel = v.address[4] end
    alias = table.concat(v.address, '/')

    table.insert(found, alias)
    local tags = v.keywords
    table.sort(tags)
    local curr = table.concat(tags,',')
    if not mqttDevices[alias] then -- New group
      change = true
      mqttDevices[alias] = {}
      mqttDevices[alias].tags = curr
    else
      if mqttDevices[alias].tags ~= curr then -- Modified group
        lvl = nil; local i; for i = 1,#tags do local parts = string.split(tags[i], '='); if parts[1] == 'lvl' then lvl = parts[2]; break end end
        if app == 202 and lvl ~= nil then -- Check for levels being removed
          
          local function difference(a, b)
            local aa = {}; for _, v in ipairs(a) do aa[v] = true end; for _, v in ipairs(b) do aa[v] = nil end
            local ret = {}; for _, v in ipairs(a) do if aa[v] then ret[#ret+1]=v end end
            return ret
          end
          
          local oldTags = string.split(mqttDevices[alias].tags, ',')
          local i, olvl = ''; for i = 1,#oldTags do local parts = string.split(oldTags[i], '='); if parts[1] == 'lvl' then olvl = parts[2]; break end end
          local diff = difference(string.split(olvl, '-'), string.split(lvl, '-'))
          if #diff > 0 then lvlDelete[alias] = diff end
        end
        mqttDevices[alias].tags = curr
        change = true
      end
    end
    if change then
      if v.name then name = v.name else name = GetCBusGroupTag(net, app, group) end
      n = n + 1
      unpublished[n] = {net=net, app=app, group=group, channel=channel, tags=tags, name=name}
      queued[#queued + 1] = alias
    end
  end
  if n > 0 then logger('Queued '..n..' object'..(n ~= 1 and 's' or '')..' with keyword MQTT for publication: '..table.concat(queued, ', '), FORCE) end

  -- Handle deletions
  kill = {}
  for k, v in pairs(mqttDevices) do
    local topic, oid, trigger
    local f = false; for _, vv in ipairs(found) do if k == vv then f = true; break end end
    if not f then
      table.insert(kill, k)
      local parts = string.split(k, '/')
      if parts[2] == '202' then
        for _, trigger in ipairs(v.trigger) do
          topic = mqttDiscoveryTopic..v.type..'/'..trigger..'/config'
      	  client:publish(topic, '', mqttQoS, RETAIN); logger('Removed discovery topic '..topic, FORCE)
          local t = tonumber(string.match(trigger, '_(%w+)$'))
          local act
          local tk, tv
          for tk, tv in pairs(triggers[tonumber(parts[3])]) do
            if t == tv then act = tk break end
          end
          t = mqttWriteTopic..tNetCBus(tonumber(parts[1]))..'/'..parts[2]..'/'..parts[3]..'/'..act..'/press'
          if mqttJunk then client:publish(t, 'junk', mqttQoS, RETAIN) end -- Publish junk to all topics to be deleted to ensure that they are actually deleted (some topics may not have been written yet)
          client:publish(t, '', mqttQoS, RETAIN)
        end
      else
        topic = mqttDiscoveryTopic..v.type..'/'..v.oid..'/config'
      	client:publish(topic, '', mqttQoS, RETAIN); logger('Removed discovery topic '..topic, FORCE)
      end
      if parts[2] ~= '202' then
        local count
        _, count = k:gsub('/','')
        if count == 3 then -- Measurement application
          t = tNetCBus(tonumber(parts[1]))..'/'..parts[2]..'/'..parts[3]..'/'..parts[4]
          t = t:gsub('/', '_'); t = t:gsub('_', '/', 2) -- Convert the last slash to an underscore
          topic = mqttReadTopic..t;
        else
          topic = mqttReadTopic..tNetCBus(tonumber(parts[1]))..'/'..parts[2]..'/'..parts[3]
        end
        if mqttJunk then client:publish(topic..'/state', 'junk', mqttQoS, RETAIN) end
        client:publish(topic..'/state', '', mqttQoS, RETAIN)
        if count ~= 3 or bSensor[k] or binarySensor[k] then  -- Level not set for measurement and binary sensors
          if mqttJunk then client:publish(topic..'/level', 'junk', mqttQoS, RETAIN) end
          client:publish(topic..'/level', '', mqttQoS, RETAIN)
        end
        includeUnits[alias] = nil
      end
    else
      -- Handle trigger level removal
      if lvlDelete[k] ~= nil then
        for _, lvl in ipairs(lvlDelete[k]) do
          local parts = string.split(k, '/')
          local group = tonumber(parts[3])
          local a, t, act; for a, t in pairs(triggers[group]) do if t == tonumber(lvl) then act = a; break end end
          trigger = nil
          for _, t in ipairs(v.trigger) do if lvl == string.match(t, '_(%w+)$') then trigger = t; break end end
          if trigger then
            topic = mqttDiscoveryTopic..v.type..'/'..trigger..'/config'
            client:publish(topic, '', mqttQoS, RETAIN); logger('Remove discovery topic '..topic, FORCE)
            t = mqttWriteTopic..tNetCBus(tonumber(parts[1]))..'/'..parts[2]..'/'..parts[3]..'/'..act..'/press'
            if mqttJunk then client:publish(t, 'junk', mqttQoS, RETAIN) end -- Publish junk to topic to be deleted (some topics may not have been written yet)
            client:publish(t, '', mqttQoS, RETAIN)
          end
        end
      end
    end
  end
  for _, k in ipairs(kill) do mqttDevices[k] = nil end
end


--[[
Publish queued CBus discovery topics
--]]
function outstandingPublish()
  local nClock = socket.gettime()
  local u
  for _, u in ipairs(unpublished) do
    addDiscover(tNetCBus(u.net), u.app, u.group, u.channel, u.tags, u.name)
    local alias = u.net..'/'..u.app..'/'..u.group
    -- storage.set('pre'..alias, nil) -- Un-comment to clear out all previous values for testing
    -- Measurement application
    if u.app == 228 then
      local level = nil; pcall(function () level = GetCBusMeasurement(u.net, u.group, u.channel) end)
      if level ~= nil then publishMeasurement(tNetCBus(u.net), u.app, u.group, u.channel, level) end
    -- User parameters
    elseif u.app == 250 then publish(tNetCBus(u.net), u.app, u.group, GetUserParam(u.net, u.group))
    -- Trigger control
    elseif u.app == 202 then -- Do nothing
    -- Lighting and other
    else
      if not lightingButton[alias] then -- Do nothing for lighting buttons
        local level = nil; pcall(function () level = GetCBusLevel(u.net, u.app, u.group) end)
        if level ~= nil then publish(tNetCBus(u.net), u.app, u.group, level) end
      end
    end
  end
  if #unpublished > 0 then
    -- Ensure that newly tagged/removed groups with the MQTT keyword send updates
    if script.status('MQTT') ~= nil then script.disable('MQTT'); script.enable('MQTT') end
    logger('Published '..#unpublished..' CBus discovery and current level topic'..(#unpublished ~= 1 and 's' or '')..' in '..string.format('%.3f', socket.gettime()-nClock)..' seconds, event scripts restarted', FORCE)
    unpublished = {}
  end
end


--[[
Publish queued Airtopia topics
--]]
function outstandingAtPublish()
  local nClock = socket.gettime()
  local u
  for _, u in ipairs(unpublishedAt) do addAtDiscover(u['name'], u['sa'], nil) end
  if #unpublishedAt > 0 then
    -- Ensure that newly tagged/removed groups with the AT keyword send updates
    if script.status('AT') ~= nil then script.disable('AT'); script.enable('AT') end
    logger('Published '..#unpublishedAt..' Airtopia discovery and current level topic'..(#unpublishedAt ~= 1 and 's' or '')..' in '..string.format('%.3f', socket.gettime()-nClock)..' seconds, event scripts restarted', FORCE)
    unpublishedAt = {}
  end
  publishAtState()
end


--[[
Publish the next queued messages for CBus
--]]
function outstandingMqttMessage()
  local msg, k, v
  for _, msg in ipairs(mqttMessages) do
    topic = msg.topic
    payload = msg.payload

    local parts = string.split(topic, '/')

    -- Messages from CBus
    if parts[1] == 'cbus' and parts[2] == 'write' then

      local net = tNetAC(tonumber(parts[3])); local app = tonumber(parts[4]); local group = tonumber(parts[5])
      local alias = net..'/'..app..'/'..group
      logger(topic..' to '..payload)

      local lastLevel = storage.get('lastlvl', {})

      if not parts[6] then
        logger('MQTT error: Invalid message format: '..topic, FORCE)

      elseif parts[6] == 'switch' then
        if payload == 'ON' then      SetCBusLevel(net, app, group, 255, 0); logger('Payload is ON for '..alias)
        elseif payload == 'OFF' then SetCBusLevel(net, app, group, 0, 0);   logger('Payload is OFF for '..alias)
        end
        
      elseif parts[6] == 'select' then
        SetCBusLevel(net, app, group, selects[alias][payload], 0); logger('Payload is '..payload..' ('..selects[alias][payload]..') for '..alias)

      elseif contains('press', parts[6]) and payload == 'PRESS' then -- Lighting group press
        PulseCBusLevel(net, app, group, 255, 0, 1, 0); logger('Payload is PRESS')

      elseif parts[7] ~= nil and contains('press', parts[7]) and payload == 'PRESS' then -- Trigger level press
        level = triggers[group][parts[6]]
        if level ~= nil then
          SetTriggerLevel(group, level); logger('Payload is PRESS')
        else
          logger('Warning: MQTT trigger level received that is not published', FORCE)
        end
    
      elseif parts[6] == 'measurement' then SetCBusMeasurement(net, app, group, payload, 0)

      elseif parts[6] == 'ramp' then
        if payload == 'OPEN' then      payload = '255'; logger("Payload is OPEN, so using RAMP instead")
        elseif payload == 'CLOSE' then payload = '0';   logger("Payload is CLOSE, so using RAMP instead")
        elseif payload == 'STOP' then
          -- Once a blind level has been set for CBus it is set regardless of the current blind
          -- position, which is not updated like a ramp, so a stop command is nonsensical
          logger("Payload for '..alias..' is STOP, which is incompatible with CBus... ignoring")
          goto next
        elseif payload == 'ON' then
          if fan[alias] then
            if lastLevel[alias] then
              payload = lastLevel[alias]; logger("Payload is fan ON, so using lastlevel instead")
            else
              payload = '255'; logger("Payload is fan ON, so using RAMP instead")
            end
          else
            logger('Payload for '..alias..' is ON')
            SetCBusLevel(net, app, group, 255, 0)
            goto next
          end
        end
        if payload == 'OFF' then
          logger('Payload for '..alias..' is OFF')
          SetCBusLevel(net, app, group, 0, 0)
        else -- Ramp
          parts = string.split(payload, ',')
          local lev = tonumber(parts[1])
          local num
          if lev ~= nil then num = math.floor(lev + 0.5) else logger('Warning: non-numeric CBus level for '..alias..', level='..parts[1], FORCE); num = nil end
          if num ~= nil and num < 256 then
            logger('Payload for '..alias..' is RAMP '..payload)
            local toSet = 0
            local ramp = 0
            if not fan[alias] then 
              if lastLevel[alias] then logger('Last level '..lastLevel[alias]) end
              if lastLevel[alias] and num == 255 then
                if blindKey and contains(blindKey, GetCBusGroupTag(net, app, group)) then
                  toSet = num; logger("Payload is 'Blind' ramp on, so ignoring lastlevel")
                else
                  toSet = lastLevel[alias]
                end
              else
                toSet = num
              end
            else
              logger("Payload is 'Fan' ramp, so ignoring lastlevel")
              toSet = num
            end
            if parts[2] ~= nil then ramp = tonumber(parts[2]) else ramp = 0 end
            SetCBusLevel(net, app, group, toSet, ramp)
          end
        end
      end

    -- Messages from AC boards
    elseif parts[2] == 'climate' or parts[2] == 'select' or parts[2] == 'sensor' then
      local sel = 'func'
      -- for loop finding items parts[2] or parts[3] matches a 'sense'... is topic important??? Prolly not...
      for _, a in pairs(ac) do
        if a.sense and (a.sense == parts[3] or a.sense == parts[4]) and a.topic == parts[2] then
          sel = 'sense'
          if a.sense == parts[3] then device = parts[1]..'-'..parts[3]
          elseif a.sense == parts[4] then device = parts[1]..'-'..parts[4] end
          break
        end
      end
      if parts[2] == 'select' then sel = 'sel' end
      if sel == 'func' then device = parts[1]..'-'..parts[4] elseif sel == 'select' then device = parts[1]..'-'..parts[3] end
      local net, app, group
      if acDevices[device] then
        alias = acDevices[device]
        local p = string.split(alias, '/'); net = tonumber(p[1]); app = tonumber(p[2]); group = tonumber(p[3])
        if (sel == 'func' and parts[5] == 'state') or (sel == 'sel' and parts[4] == 'state') or sel == 'sense' then
          if ignoreCbus[alias] and socket.gettime() - ignoreCbus[alias] > ignoreTimeout then -- Don't worry about older 'ignore' flags
            ignoreCbus[alias] = nil
            logger('Ignoring older CBus ignore flag for '..alias)
          end
          if not ignoreCbus[alias] then -- Only set the CBus status/level if this script did not initiate the change, and if it is different to the current value
            local set = false
            local extant = GetUserParam(net, group)
            local e = tonumber(extant)
            if e ~= nil then
              if string.format('%.3f', e) ~= string.format('%.3f', tonumber(payload)) then SetUserParam(net, group, payload); set = true end
            else
              if extant ~= payload then SetUserParam(net, group, payload); set = true end
            end
            -- Setting CBus here will result in the AC event script requesting publication of the state using publishAc() above.
            -- This is undesired, so ignoreMqtt[alias] is used to ensure that the CBus change received does not publish to MQTT.
            if set then ignoreMqtt[alias] = socket.gettime() logger('Setting ignoreMqtt for '..alias..', oldState='..extant..' payload='..payload) end
          else
            ignoreCbus[alias] = nil
            logger('Ignoring CBus publish for '..alias)
          end
          ac[alias].state = payload
        end
      end
    
    -- Messages from AT boards
    elseif parts[1] == 'airtopia' and parts[3] == 'cmd' then
      device = parts[2]..'-'..parts[4]
      local net, app, group
      
      function pub(alias, payload) -- State publish to MQTT
        local parts = string.split(at[alias].name, '-')
        local board = parts[1]
        local topic = 'airtopia/'..board..'/state/'..parts[2]
        client:publish(topic, payload, mqttQoS, RETAIN)
      end

      if parts[4] == 'mode' then
        if atDevices[device] then
          alias = atDevices[device]
          local p = string.split(alias, '/'); net = tonumber(p[1]); app = tonumber(p[2]); group = tonumber(p[3])
          i = indexOf(atmodes, payload)
          if i ~= nil then
            local set = false
            local pwrgrp = tonumber(string.split(atBoards[parts[2]]['alias'], '/')[3]) -- Get the power user parameter
            local extant = GetUserParam(net, pwrgrp)
            local pld = nil
            if payload ~= 'off' then
              pub(alias, i)
              pub(atBoards[parts[2]]['alias'], 1) -- Power on
              if extant ~= 1 then set = true; pld = 1 end
            else
              pub(atBoards[parts[2]]['alias'], 0) -- Power off
              if extant ~= 0 then set = true; pld = 0 end
            end
            if set and pld ~= nil then
              -- Send to CBus, ensuring MQTT ignore is set...
              local alias = atBoards[parts[2]]['alias']
              ignoreMqtt[alias] = socket.gettime(); logger('Setting ignoreMqtt for '..alias..', oldState='..extant..' payload='..pld)
              SetUserParam(net, pwrgrp, pld)
            end
            -- publish to CBus
            local extant = GetUserParam(net, group)
            if i ~= extant and payload ~= 'off' then -- Set mode, but not if it is 'off'
              ignoreMqtt[alias] = socket.gettime(); logger('Setting ignoreMqtt for '..alias..', oldState='..extant..' payload='..payload)
              SetUserParam(net, group, i)
            end
          end
          -- Publish state to broker
          local parts = string.split(at[alias].name, '-')
          local board = parts[1]
          local topic = 'airtopia/'..board..'/state/modeha'
          client:publish(topic, payload, mqttQoS, RETAIN)
        end

      elseif parts[4] == 'swing' then
        local hswing = atDevices[parts[2]..'-horiz_swing']
        local vswing = atDevices[parts[2]..'-vert_swing']
        if hswing ~= nil and vswing ~= nil then
          local i, h, v
          local s = 0; for i, v in ipairs(atswings) do if v == payload then s = i - 1; break; end end -- Get the swing index
          h = bit.band(s, 1)
          v = bit.rshift(bit.band(s, 2), 1)
          local board = parts[2]
          local topic = 'airtopia/'..board..'/state/swingha'
          client:publish(topic, payload, mqttQoS, RETAIN)
          parts = string.split(hswing, '/'); SetUserParam(parts[1], parts[3], h)
          parts = string.split(vswing, '/'); SetUserParam(parts[1], parts[3], v)
        end
        
      elseif parts[4] == 'fan' then
        local fan = atDevices[parts[2]..'-fan']
        if fan ~= nil then
          local i, f
          local f = 0; for i, v in ipairs(atfans) do if v == payload then f = i - 1; break; end end -- Get the fan index
          local board = parts[2]
          local topic = 'airtopia/'..board..'/state/fanha'
          client:publish(topic, payload, mqttQoS, RETAIN)
          parts = string.split(fan, '/'); SetUserParam(parts[1], parts[3], f)
        end
        
      else -- Set target temp
        if atDevices[device] then
          alias = atDevices[device]
          local p = string.split(alias, '/'); net = tonumber(p[1]); app = tonumber(p[2]); group = tonumber(p[3])
          pub(alias, payload)
          -- publish to CBus
          local extant = GetUserParam(net, group)
          if payoad ~= extant then
            ignoreMqtt[alias] = socket.gettime(); logger('Setting ignoreMqtt for '..alias..', oldState='..extant..' payload='..payload)
            SetUserParam(net, group, payload)
          end
        end
      end
    elseif parts[1] == 'airtopia' and parts[3] == 'state' then
      if indexOf(airtopiaStates, parts[4]) == nil then table.insert(airtopiaStates, parts[4]) end
    end
    
    -- Messages from ENV boards - simpler, only messages inbound
    if parts[2] == 'sensor' and parts[4] == 'state' then
      device = parts[1]..'-'..parts[3]
      if envDevices[device] then
        parts = string.split(envDevices[device], '/')
        local net = parts[1]; local app = parts[2]; local group = parts[3]
        local alias = net..'/'..app..'/'..group
        local extant = GetUserParam(net, group)
        if type(extant) == 'number' then
          -- Deal with real number imprecision, assuming three decimal places for change detection
          if string.format('%.3f', extant) ~= string.format('%.3f', tonumber(payload)) then SetUserParam(net, group, payload) end
        else
          if extant ~= payload then SetUserParam(net, group, payload) end
        end
        env[alias].state = payload
      end
    end
    ::next::
  end
  mqttMessages = {}
end


--[[
Publish the next queued messages for MQTT
--]]
function outstandingCbusMessage()
  local cmd
  for _, cmd in ipairs(cbusMessages) do
    local parts = string.split(cmd, '/')
    local alias = parts[1]..'/'..parts[2]..'/'..parts[3]
    
    if ac[alias] then -- AC message to MQTT (no ramping involved for AC groups)
      publishAc(parts[1], parts[2], parts[3], parts[4], ac[alias].select)
    elseif at[alias] then -- AT message to MQTT (no ramping involved for AT groups)
      publishAt(parts[1], parts[2], parts[3], parts[4])
    else -- CBus message to MQTT
      local net = tonumber(parts[1]); local app = tonumber(parts[2]); local group = tonumber(parts[3]);
      if app ~= 228
        then -- i.e. not measurement application
        local setting = true
        local payload = tonumber(parts[4]) -- Always a number for lighting app, but payload could be nil for user param at this point if a string
        if lighting[parts[2]] then -- Lighting application, so check for ramp
          local lastLevel = storage.get('lastlvl', {})
          logger('Alias: '..alias..', payload: '..tostring(payload)..', ramp rate: '..tostring(GetCBusRampRate(net, app, group))..', target level: '..tostring(GetCBusTargetLevel(net, app, group)))
          -- A CBus ramp up and down can annoyingly begin with a zero level, then steadily converge to the target level. This initial
          -- zero should not be published to MQTT so it is ignored. If an initial zero is not seen then the ramp will be orphaned (and
          -- ultimately cleaned up/published, albeit a bit late after rampTimeout seconds).
          if not ramp[alias] then
            if GetCBusRampRate(net, app, group) > 0 then
              if lastLevel[alias] ~= GetCBusTargetLevel(net, app, group) or not lastLevel[alias] then
                ramp[alias] = { ts=socket.gettime(), ramp=GetCBusRampRate(net, app, group), target=GetCBusTargetLevel(net, app, group) }
              end
              if payload == 0 then
                setting = false
                if ramp[alias] then logger('Set ramp for '..alias..' and suppress zero send') end
              else
                if ramp[alias] then logger('Set ramp for '..alias) end
              end
            end
          else
            if ramp[alias].target ~= GetCBusTargetLevel(net, app, group) then -- Target level has changed so cancel ramp
              ramp[alias] = nil
              logger('Cancel ramp for '..alias)
              if payload == 0 and GetCBusRampRate(net, app, group) > 0 then setting = false end -- Ignore initial zero if ramp on
            end
          end
        else -- Possibly a string payload for user parameter
          if payload == nil then
            payload = parts[4]
            local pt = 5 -- Accommodate an unlimited number of slashes in a string payload
            while parts[pt] ~= nil do
              payload = payload..'/'..parts[pt]
              pt = pt + 1
            end
          end
          -- Groups other than lighting are never ramped, so setting is always true
        end
        if setting then
          if ramp[alias] then
            if payload == ramp[alias].target then
              ramp[alias] = nil
              logger('Clear ramp for '..alias)
              -- Only update MQTT at the end of a ramp, not during it (avoids HomeAssistant remembering an implausible level)
              publish(tNetCBus(net), app, group, payload)
            end
          else
            publish(tNetCBus(net), app, group, payload)
          end
          if app ~= 202 then -- Not trigger
            sKey = 'pre'..alias
            local p = payload
            if tonumber(payload) ~= nil then p = string.format('%.3f', payload) end
            storage.set(sKey, p) -- Save payload as 'previous' for use in the MQTT event-based script
          end
        end
      else -- Special case for measurement app
        publishMeasurement(tNetCBus(tonumber(parts[1])), tonumber(parts[2]), tonumber(parts[3]), tonumber(parts[4]), tonumber(parts[5]))
        if tonumber(parts[5]) ~= nil then
          sKey = 'pre'..parts[1]..'/'..parts[2]..'/'..parts[3]..'/'..parts[4]
          local p = string.format('%.3f', tonumber(parts[5]))
          storage.set(sKey, p)
        end
      end
    end
  end
  cbusMessages = {}
end

--[[
Remove any orphaned ramp flags
--]]
function checkRampOrphans()
  local k, v; local orphan = {}
  for k, v in pairs(ramp) do
    if socket.gettime() > v.ts + v.ramp + rampTimeout then
      -- Is an older ramp timestamp beyond ramp duration plus margin (should never occur, but does occasionally)
      -- Remove the orphan, and publish the final target, which will be zero
      -- Occurs when a ramp to off does not begin with a zero level during the ramp, or if a ramp to zero starts
      -- when the group is already at zero.
      table.insert(orphan, k)
      parts = string.split(k, '/')
      local net = tonumber(parts[1]); local app = tonumber(parts[2]); local group = tonumber(parts[3]);
      publish(tNetCBus(net), app, group, v.target)
    end
  end
  for _, k in ipairs(orphan) do ramp[k] = nil; logger('Removing orphaned ramp for '..k) end
end

--[[
Duplicate discovery delete
--]]
function dupDelete()
  -- If duplicate discovery topics are detected then remove them (discoveryDelete is set in broker ON_MESSAGE call-back)
  logger('Warning: Removing '..len(discoveryDelete)..' duplicate discovery topics', FORCE)
  for toDelete, _ in pairs(discoveryDelete) do
    local parts = string.split(toDelete, '/')
    local oid = parts[1]
    local dType = parts[2]
    client:publish(mqttDiscoveryTopic..dType..'/'..oid..'/config', '', mqttQoS, RETAIN)
    logger('Removed discovery topic '..mqttDiscoveryTopic..dType..'/'..oid..'/config', FORCE)
  end
  discoveryDelete = {}
end


--[[
Main loop
--]]

-- Create/update/delete functions spread evenly over the period 'trackChanges'
cud = {
  { func = cudCBusTopics, init = false },
  { func = cudAc, init = true, script = 'AC' },
  { func = cudEnv, init = true },
  { func = cudAt, init = false, script = 'AT' },
}
for i, c in ipairs(cud) do c.t = socket.gettime() - checkChanges * 1/#cud * i + checkChanges/#cud end -- Set the time to next discover for each function

-- Initial load of devices excluding CBus, suppressing MQTT re-subscribe
for _, c in ipairs(cud) do if c.init then c.func(true); if c.script and script.status(c.script) ~= nil then script.disable(c.script); script.enable(c.script) end end end

function validateIncoming(cmd) -- Reject any weird socket messages received
  local _, count = cmd:gsub("/", ''); if count < 3 or count > 4 then return false end
  local parts = string.split(cmd, '/')
  local dstC, payload
  if parts[2] and parts[2] == '228' then dstC = 4; payload = parts[5] else dstC = 3; payload = parts[4] end -- Measurement app is four dest parts, else three
  if payload == nil then return false end
  for i = 1,dstC,1 do n = tonumber(parts[i], 10); if n == nil then return false end end -- Test whether any dst parts are not whole decimal numbers
  return true
end


while true do
  -- Check for new messages from CBus. The entire socket buffer is collected each iteration for efficiency.
  local stat, err
  local more = false
  stat, err = pcall(function ()
    ::checkAgain::
    local cmd = nil
	  cmd = server:receive()
    if cmd and type(cmd) == 'string' then
      if validateIncoming(cmd) then
        cbusMessages[#cbusMessages + 1] = cmd -- Queue the new message
      else
        logger('Invalid command received: '..cmd, FORCE)
      end
      server:settimeout(0); more = true; goto checkAgain -- Immediately check for more buffered inbound messages to queue
    else
      if more then server:settimeout(socketTimeout) end
    end
  end)
  if not stat then logger('Socket receive error: '..err, FORCE) end

  -- Process MQTT message buffers synchronously - sends and receives
  client:loop(mqttTimeout)

  if mqttStatus == 1 then
    -- When connected to the broker
    if #mqttMessages > 0 then
      -- Send outstanding messages to CBus
      stat, err = pcall(outstandingMqttMessage)
      if not stat then logger('Error processing outstanding MQTT messages: '..err, FORCE); mqttMessages = {} end -- Log error and clear the queue
    end
    if #cbusMessages > 0 then
      -- Send outstanding messages to MQTT
      stat, err = pcall(outstandingCbusMessage)
      if not stat then logger('Error processing outstanding CBus messages: '..err, FORCE); cbusMessages = {} end -- Log error and clear the queue, continue
    end
    if #unpublished > 0 then
      -- Publish outstanding CBus discovery topics
      stat, err = pcall(outstandingPublish)
      if not stat then logger('Error publishing outstanding CBus discovery topics: '..err, FORCE); unpublished = {} end -- Log error and clear the queue, continue
    end
    if #unpublishedAt > 0 then
      -- Publish outstanding Airtopia discovery topics
      stat, err = pcall(outstandingAtPublish)
      if not stat then logger('Error publishing outstanding Airtopia discovery topics: '..err, FORCE); unpublishedAt = {} end -- Log error and clear the queue, continue
    end
    if len(ramp) > 0 then
      -- Some scenarios can create ramp orphans
      stat, err = pcall(checkRampOrphans)
      if not stat then logger('Error checking ramp orphans: '..err, FORCE) end -- Log and continue
    end
    if len(discoveryDelete) > 0 then
      stat, err = pcall(dupDelete)
      if not stat then logger('Error processing delete discovery duplicates: '..err, FORCE) end -- Log and continue
    end
    if checkForChanges then
      -- Periodically create/update/delete device items that change
      stat, err = pcall(function () for _, c in ipairs(cud) do if socket.gettime() - c.t >=checkChanges then c.t = socket.gettime(); c.func() end end end)
      if not stat then logger('Error checking create/update/delete: '..err, FORCE) end -- Log and continue
    end
  elseif mqttStatus == 2 then
    -- MQTT is disconnected, so attempt a connection, waiting up to five seconds. If fail to connect then exit and await script re-entry
    local timeout = 5
    mqttConnected = socket.gettime()
    stat, err = pcall(function (b, p, k) client:connect(b, p, k) end, mqttBroker, 1883, 25) -- Requested keep-alive 25 seconds, broker at port 1883
    if not stat then logger('Error connecting to broker: '..err, FORCE) do return end end -- Log and abort
    while mqttStatus ~= 1 do
      client:loop(0) -- Service the client
      if socket.gettime() - mqttConnected > timeout then
        logger('Failed to connect to the MQTT broker within '..timeout..' seconds', FORCE)
        do return end
      end
    end
    -- Connected...
    -- Full publish CBus topics
    stat, err = pcall(publishCurrent)
    if not stat then logger('Error publishing current values: '..err, FORCE) end -- Log and continue
  end

  --[[
  Send a heartbeat periodically to port 5433, listened to by the heartheat script.
  If execution is disrupted by any error or lockup then this script will be re-started.
  If sending the heartbeat faults, then the loop is exited, which will also re-start this
  script (it being resident/sleep zero).
  --]]
  
  if sendHeartbeat > 0 then
    local stat, err = pcall(function ()
      if socket.gettime() - heartbeat >= sendHeartbeat then
        heartbeat = socket.gettime(); require('socket').udp():sendto(_SCRIPTNAME..'+'..heartbeat, '127.0.0.1', 5433)
      end
    end)
    if not stat then logger('A fault occurred sending heartbeat. Restarting...', FORCE); do return end end
  end
end