--[[ CHANGE TO SUIT ENVIRONMENT --]]
local mqttBroker = '192.168.10.21'
local mqttUsername = 'mqtt'
local mqttPassword = 'password'
local lighting = { ['56'] = true, } -- Array of applications that are used for lighting
local checkForChanges = true       -- When true the script will periodically check for create/update/delete of object keywords (disable to lower CPU load)
local checkChanges = 30            -- Interval in seconds to check for changes to object keywords

--[[ SET AS APPROPRIATE TO SUIT ENVIRONMENT --]]
local airtopiaSupport = false      -- Monitor keyword 'AT' for Airtopia devices - set to true if support is desired
local panasonicSupport = false     -- Monitor keyword 'AC' for Panasonic devices - set to true if support is desired
local environmentSupport = false   -- Monitor keyword 'ENV' for ESPHome environment sensors - set to true if support is desired

--[[ NOTE: !!!+++BREAKING CHANGE+++!!! Keywords for the lvl= tag have CHANGED. Use '/' instead of '-', and ':' where '/' was previously used. See the README for updated examples. --]]

--[[
Resident, zero sleep interval, name: 'MQTT send receive'

Manage CBus, Panasonic and Airtopia AC and environment events for MQTT, and publish discovery topics. Used with Home Assistant.

Documentation available at https://github.com/autoSteve/acMqtt
--]]

--[[
General configuration variables follow. Change as required, but probably no need to.
--]]
local logging = false        -- Enable detailed logging
local logms = false          -- Include timestamp in milliseconds for logs

local sendHeartbeat = 5      -- Send a heartbeat to the 'Heartbeat' script every n seconds (zero to disable heartbeat)
local heartbeatConditions = { ['max'] = 60, } -- At most 60 seconds without a heartbeat or else get restarted
local publishNoLevel = false -- For trigger app, whether to publish a level with no tag as "Level n" or raise an error in the log
local selectExact = true     -- For select, if a CBus level other than in the select levels is set then adjust the CBus level to the closest select level
local blindKey               -- If blind fully open is desirable instead of lastlevel, then change to a string contained in every blind object (e.g. 'Blind'), case sensitive
local mqttClientId = 'nac'   -- #ditchunderscoresinvariablenames ... wherever practical please! Be kind to others, and your fingers typing...
local mqttQoS = 2            -- Quality of service for MQTT messages: 0 = only once, 1 = at least once, 2 = exactly once
local mqttJunk = true        -- Whether to publish junk before a blank publish message when removing topics (not necessary, but cleans up MQTT Explorer view)

--[[
Timing variables. Adjust to taste if you know what you're doing. These provide a good compromise, but your deployment may vary.
--]]
local rampTimeout = 5        -- Time beyond ramp to declare a ramp orphan in seconds
local socketTimeout = 0.1    -- Lower = higher CPU, but better responsiveness (0 .05 = 1/20th of a second or 50ms, 0.005 = 5ms)
local mqttTimeout = 0        -- In milliseconds, go with zero unless you know what you're doing
local ignoreTimeout = 2      -- Timeout for stale MQTT ignore messages in seconds (two seconds is a long time...)

--[[
Topic prefixes for read/write/publish. The mqttDiscovery topic is recommended to be set to 'homeassistant/'
for use with HA, which is the default here. The MQTT CBus topics can be called whatever you want, as discovery/subscribe
adjusts. All topic prefixes must end in '/'.
--]]
local mqttCbus = 'cbus/'
local mqttReadTopic = mqttCbus..'read/'
local mqttWriteTopic = mqttCbus..'write/'
local mqttDiscoveryTopic = 'homeassistant/'

--[[
Variables not to be messed with unless you definitely know what you're doing.
--]]
local EVENTVERSION = 2       -- MQTT/MQTT final event script compatible version
local discovery = {}         -- MQTT discovery topics lookup
local discoveryDelete = {}   -- If duplicate discovery topics are detected on startup then they will be removed
local atDiscovery = {}       -- AT discovery topics lookup
local atDiscoveryDelete = {} -- If duplicate discovery topics are detected on startup then they will be removed
local mqttDevices = {}       -- CBus groups to send MQTT topics for
local ac = {}                -- AC device details
local acDevices = {}         -- Quick lookup to determine whether an object is an AC device
local acBoards = {}          -- All physical AC boards (esp32)
local at = {}                -- AT device details
local atDevices = {}         -- Quick lookup to determine whether an object is an AT device
local atBoards = {}          -- All physical AT boards
local env = {}               -- Environment device details
local envDevices = {}        -- Quick lookup to determine whether an object is an environment device
local envBoards = {}         -- All physical environment boards (esp32)
local cbusMessages = {}      -- Message queue
local mqttMessages = {}      -- Message queue
local ignoreCbus = {}        -- To prevent message loops
local ignoreMqtt = {}        -- To prevent message loops
local ramp = {}              -- Keeps track of ramping to ignore some zero level MQTT publish events outstandingCbusMessage()
local triggers = {}          -- Trigger groups and their levels
local selects = {}           -- Select groups and their options/levels
local cover = {}             -- Quick lookup to determine whether an object is a cover (blind)
local fan = {}               -- Quick lookup to determine whether an object is a fan (sweep fan)
local bSensor = {}           -- Quick lookup to determine whether an object is a bsensor (a regular lighting group acting as status)
local binarySensor = {}      -- Quick lookup to determine whether an object is a binary sensor
local lightingButton = {}    -- Quick lookup to determine whether an object is a lighting group as a button
local userParameter = {}     -- Quick lookup to determine whether an object is a user parameter
local unitParameter = {}     -- Quick lookup to determine whether an object is a user parameter
local publishAdj = {}        -- Holds scale and decimals to apply
local includeUnits = {}      -- Holds table of booleans to add sensor unit (%, $, Â°C, etc.) to MQTT value
local unpublished = {}       -- The outstanding set of CBus objects to publish discovery topics for
local unpublishedAt = {}     -- The outstanding set of CBus Airtopia objects to publish discovery topics for
local mqttStatus = 2         -- The status of the MQTT connection. Initially disconnected, which will cause an immediate connection. 1=connected, 2=disconnected
local mqttConnected = 0      -- Timestamp of MQTT connection
local imgDefault = {         -- Defaults for images - Simple image name, or a table of 'also contains' keywords (which must include an #else entry)
  ['heat']        = 'mdi:radiator',
  ['blind']       = 'mdi:blinds',
  ['under floor'] = {['enable'] = 'mdi:radiator-disabled', ['#else'] = 'mdi:radiator'},
  ['towel rail']  = {['enable'] = 'mdi:radiator-disabled', ['#else'] = 'mdi:radiator'},
  ['fan']         = {['sweep'] = 'mdi:ceiling-fan', ['#else'] = 'mdi:fan'},
  ['gate']        = {['open'] = 'mdi:gate-open', ['#else'] = 'mdi:gate'},
}

local airtopiaCmds = {'power', 'fan', 'swing', 'mode', 'target_temperature'} -- All command topics (used for clean up)
local atmodes = {'auto', 'cool', 'heat', 'fan_only', 'dry', 'off'} -- Airtopia modes
local atswings = {'Off', 'Horizontal only', 'Vertical only', 'Horizontal and Vertical'} -- Airtopia swing modes
local atfans = {'Auto', '1', '2', '3', '4'} -- Airtopia fan speed (THIS IS UNTESTED, will result in 0, 1, 2, 3, 4 being set in the user parameter in the order of the table)
local airtopiaStates = {}    -- Current state topics in use (used for clean up)

local RETAIN = true          -- Boolean aliases for MQTT retain and no-retain settings
local NORETAIN = false
local FORCE = true           -- For logger. Use to force a log entry, regardless of the logging= value

local started = socket.gettime()
local heartbeat = started

-- Runtime global variable checking. Globals must be explicitly declared, which will catch variable name typos
local declaredNames = {['vprint'] = true, ['vprinthex'] = true, ['maxgroup'] = true, ['mosquitto'] = true, ['rr'] = true, ['_'] = true, }
local function declare(name, initval) rawset(_G, name, initval) declaredNames[name] = true end
local exclude = {['ngx'] = true, }
setmetatable(_G, {
  __newindex = function (t, n, v) if not declaredNames[n] then log('Warning: Write to undeclared global variable "'..n..'"') end rawset(t, n, v) end,
  __index = function (_, n) if not exclude[n] and not declaredNames[n] then log('Warning: Read undeclared global variable "'..n..'"') end return nil end,
})

local function sleep(sec) socket.select(nil, nil, sec) end
local function contains(prefix, text) local pos = text:find(prefix, 1, true); if pos then return pos >= 1 else return false end end -- Test whether a string contains a substring
local function trim(s) if s ~= nil then return s:match "^%s*(.-)%s*$" else return nil end end -- Remove leading and trailing spaces
local function tNetCBus(net) if net == 0 then return 254 else return net end end -- Translate AC network numbering to CBus
local function tNetAC(net) if net == 254 then return 0 else return net end end -- Translate CBus network numbering to AC
local function len(dict) local i = 0; local k; for k, _ in pairs(dict) do i = i + 1 end return i end -- Get number of dictionary members
local function indexOf(array, value) for i, v in ipairs(array) do if v == value then return i end end return nil end -- Find the index number of an array member
local function copy(obj, seen) -- Copy tables, 'seen' is for recursive use
  if type(obj) ~= 'table' then return obj end
  if seen and seen[obj] then return seen[obj] end
  local s = seen or {}
  local res = setmetatable({}, getmetatable(obj))
  s[obj] = res
  for k, v in pairs(obj) do res[copy(k, s)] = copy(v, s) end
  return res
end
local function equals(o1, o2, ignoreMt) -- Compare two variables (simple, tables, anything). Default ignore metatables.
  if ignoreMt == nil then ignoreMt = true end
  if o1 == o2 then return true end
  local o1Type = type(o1) local o2Type = type(o2)
  if o1Type ~= o2Type then return false end if o1Type ~= 'table' then return false end
  if not ignoreMt then local mt1 = getmetatable(o1) if mt1 and mt1.__eq then return o1 == o2 end end
  local keySet = {}
  for key1, value1 in pairs(o1) do local value2 = o2[key1] if value2 == nil or equals(value1, value2, ignoreMt) == false then return false end keySet[key1] = true end
  for key2, _ in pairs(o2) do if not keySet[key2] then return false end end
  return true
end
local function logger(msg, force) -- Log helper
  local ts
  if logging or force ~= nil then
    if logms then ts = string.format('%.3f ', socket.gettime()-started) else ts = '' end
    log(ts..msg)
  end
end


--[[
Register with the Heartbeat script
--]]
local function isRegistered() local hbeat = storage.get('heartbeat', {}); local k; for k, _ in pairs(hbeat) do if k == _SCRIPTNAME then return true, hbeat end end return false, hbeat end
if sendHeartbeat > 0 then
  -- Check whether registration is required, and if not registered (or conditions changed) then register
  local r, hbeat = isRegistered()
  if not r or (r and not equals(hbeat[_SCRIPTNAME], heartbeatConditions)) then
    local k, v, vals
    vals = '' for k, v in pairs(heartbeatConditions) do vals = vals..k..'='..v..' ' end
    logger('Registering '.._SCRIPTNAME..' with heartbeat of '..vals, FORCE)
    hbeat[_SCRIPTNAME] = heartbeatConditions
    storage.set('heartbeat', hbeat)
  end
else -- Remove script from hearbeat registration
  local r, hbeat = isRegistered() if r then hbeat[_SCRIPTNAME] = nil storage.set('heartbeat', hbeat) end
end


--[[
Warn for >= 1.15.0 that using MQTT final is preferred, and also halt regarding settings for execute during ramping / missing scripts / wrong version
--]]
local eventScripts = db:getall("SELECT name FROM scripting WHERE type = 'event'")
local eventName, finalName, s = nil, nil, nil
for _, s in ipairs(eventScripts) do
  if s.name:lower() == 'mqtt' then eventName = s.name end
  if s.name:lower() == 'mqtt final' then finalName = s.name end
end

local version = string.split(io.readfile('/lib/genohm-scada/version'):trim(), '.')
local finalInstalled = finalName ~= nil and not (script.status(finalName) == nil or script.status(finalName) == false)
local eventInstalled = eventName ~= nil and not (script.status(eventName) == nil or script.status(eventName) == false)

if eventInstalled and finalInstalled then
  logger("Error: Use script 'MQTT' or 'MQTT final', not both. Not starting.", FORCE)
  while true do sleep(1) end
end

if not eventInstalled and not finalInstalled then
  logger("Error: The event script 'MQTT' or 'MQTT final' is not installed or enabled. Not starting.", FORCE)
  while true do sleep(1) end
end

local compatibleEvent = false
if eventInstalled then compatibleEvent = contains('VERSION: '..EVENTVERSION, db:getall("SELECT script FROM scripting WHERE name = '"..eventName.."'")[1]['script']) end
if finalInstalled then compatibleEvent = contains('VERSION: '..EVENTVERSION, db:getall("SELECT script FROM scripting WHERE name = '"..finalName.."'")[1]['script']) end
if not compatibleEvent then
  local scriptInUse = ''
  if finalInstalled then scriptInUse = finalName end
  if eventInstalled then scriptInUse = eventName end
  logger("Error: Incompatible '"..scriptInUse.."' script version detected, so please update it. Not starting.", FORCE)
  while true do sleep(1) end
end

local legacyFirmware = false
if tonumber(version[1]) >= 1 and tonumber(version[2]) >= 15 and tonumber(version[3]) >= 0 then
  if not finalInstalled then
    logger('Warning firmware > 1.15.0: Script MQTT final is not installed, or is disabled. This script improves ramp detection reliability.', FORCE)
    legacyFirmware = true
  end

  local edr
  if eventInstalled then
    edr = db:getall("SELECT subparams FROM scripting WHERE name = '"..eventName.."'")
    edr = edr[1] if edr ~= nil then edr = edr['subparams'] end
    if edr ~= '1' then
      logger("Error firmware > 1.15.0: Event script 'MQTT' is not set to execute during ramping. Not starting. Consider using 'MQTT final' instead.", FORCE)
      while true do sleep(1) end
    end
  end
  if finalInstalled then
    edr = db:getall("SELECT subparams FROM scripting WHERE name = '"..finalName.."'")
    edr = edr[1] if edr ~= nil then edr = edr['subparams'] end
    if edr ~= '0' then
      logger("Error firmware > 1.15.0: Event script 'MQTT final' is set to execute during ramping. Turn this off. Not starting.", FORCE)
      while true do sleep(1) end
    end
  end
else
  legacyFirmware = true

  logger('Warning: An upgrade to firmware 1.15.0+ is recommended. See the README at https://github.com/autoSteve/acMqtt.', FORCE)
  if finalInstalled then
    logger("Error: The script 'MQTT final' is only for firmware 1.15.0+. Not starting.", FORCE)
    while true do sleep(1) end
  end
end

--[[
UDP listener - receive messages from CBus level change event scripts
--]]
declare('server')
pcall(function () server:close() end)
server = require('socket').udp()
server:settimeout(socketTimeout)
server:setsockname('127.0.0.1', 5432) -- Listen on port 5432 for CBus changes


--[[
Mosquitto client and call-backs
--]]

local mqtt = require('mosquitto')
local client = mqtt.new(mqttClientId)
client:will_set(mqttCbus..'status', 'offline', mqttQoS, RETAIN) -- Last will and testament is to set status offline
if mqttUsername then client:login_set(mqttUsername, mqttPassword) end

client.ON_CONNECT = function(success)
  local k
  if success then
    logger('Connected to Mosquitto broker', FORCE)
    client:publish(mqttCbus..'status', 'online', mqttQoS, RETAIN)
    mqttStatus = 1
  end
end

client.ON_DISCONNECT = function(...)
  logger('Mosquitto broker disconnected', FORCE)
  mqttStatus = 2
end

client.ON_MESSAGE = function(mid, topic, payload)
  if contains('/cbus_mqtt_', topic) then
    -- Record discovery topics to check for duplication
    local parts = string.split(topic, '/')
    if parts[1] == string.split(mqttDiscoveryTopic, '/')[1] then
      if payload ~= '' and discovery[parts[3]] ~= nil then
        if discovery[parts[3]] ~= parts[2] then
          discoveryDelete[parts[3]..'/'..parts[2]] = true
        else
          discovery[parts[3]] = parts[2] -- Table of CBus addresses with type as the value
        end
      end
    end
  else
    mqttMessages[#mqttMessages + 1] = { topic=topic, payload=payload } -- Queue the message
  end
end


--[[
Publish lighting and user parameter objects to MQTT 
--]]
local function publish(net, app, group, level)
  if level == nil then logger('Warning: Nil CBus level for '..net..'/'..app..'/'..group, FORCE); do return end end
  local alias = net..'/'..app..'/'..group
  local aAlias = tNetAC(net)..'/'..app..'/'..group
  local state = ''
  if cover[alias] then
    -- For CBus blind controllers report level unless it is 5, which is a preset for stop in level translation mode
    state = 'stopped'
    if level == 5 then level = -1 end
  else
    state = (tonumber(level) ~= 0) and 'ON' or 'OFF'
  end
  if not userParameter[alias] then
    if not binarySensor[aAlias] then
      if bSensor[aAlias] then -- It's a bSensor
        client:publish(mqttReadTopic..alias..'/state', level, mqttQoS, RETAIN)
        logger('Publishing state '..mqttReadTopic..alias..' to '..level)
      elseif selects[aAlias] then -- It's a select
        local l
        for _, l in ipairs(selects[aAlias].allLvl) do
          if tonumber(level) <= l.lvl then
            if selectExact and tonumber(level) ~= l.lvl then
              -- Current CBus level does not match the select, so optionally adjust the CBus level
              logger('Warning: Forcing level to set for select '..alias..' to nearest level '..l.lvl..' ('..tonumber(level)..' requested, but selectExact=true)', FORCE)
              SetCBusLevel(tNetAC(net), app, group, l.lvl, 0)
              -- Adjusting the level will result in two MQTT publish events, which could be avoided but is not
            end
            client:publish(mqttReadTopic..alias..'/select', l.sel, mqttQoS, RETAIN)
            logger('Publishing select '..mqttReadTopic..alias..' to '..l.sel..'('..l.lvl..')')
            break
          end
        end
      else -- It's a bog standard group
        client:publish(mqttReadTopic..alias..'/state', state, mqttQoS, RETAIN)
        if level ~= -1 then client:publish(mqttReadTopic..alias..'/level', level, mqttQoS, RETAIN) end
        logger('Publishing state and level '..mqttReadTopic..alias..' to '..state..'/'..level)
      end
    else -- It's a binary sensor
      client:publish(mqttReadTopic..alias..'/state', state, mqttQoS, RETAIN)
      logger('Publishing state '..mqttReadTopic..alias..' to '..state)
    end
  else -- It's a user parameter
    local v
    local adjust = publishAdj[alias]
    if adjust then v = tonumber(string.format('%.'..adjust.dec..'f', level * adjust.scale)) else v = level end
    client:publish(mqttReadTopic..alias..'/state', v, mqttQoS, RETAIN)
    logger('Publishing value '..mqttReadTopic..alias..' to '..v)
  end
end

--[[
Publish measurement application objects to MQTT 
--]]
local function publishMeasurement(net, app, group, channel, value)
  local units, v
  local alias = net..'/'..app..'/'..group..'/'..channel
  if value == nil then logger('Warning: Nil CBus measurement value for '..net..'/'..app..'/'..group, FORCE); do return end end
  local adjust = publishAdj[alias]
  if adjust then v = tonumber(string.format('%.'..adjust.dec..'f', value * adjust.scale)) else v = value end
  if includeUnits[alias] then
    _, units = GetCBusMeasurement(net, group, channel)
    if units == '$' then
      v = units..tostring(v)
    elseif units == '%' then
      v = v..units
    else
      v = v..' '..units
    end
  end
  client:publish(mqttReadTopic..net..'/'..app..'/'..group..'_'..channel..'/state', v, mqttQoS, RETAIN)
  -- logger('Publishing measurement '..mqttReadTopic..net..'/'..app..'/'..group..'_'..channel..' to '..v)
end

--[[
Publish unit parameter objects to MQTT 
--]]
local function publishUnitParam(net, app, group, channel, value)
  local units, v
  local alias = net..'/'..app..'/'..group..'/'..channel
  if value == nil then logger('Warning: Nil unit parameter value for '..net..'/'..app..'/'..group, FORCE); do return end end
  local adjust = publishAdj[alias]
  if adjust then v = tonumber(string.format('%.'..adjust.dec..'f', value * adjust.scale)) else v = value end
  client:publish(mqttReadTopic..net..'/'..app..'/'..group..'_'..channel..'/state', v, mqttQoS, RETAIN)
  logger('Publishing unit parameter '..mqttReadTopic..net..'/'..app..'/'..group..'_'..channel..' to '..v)
end

--[[
Publish Panasonic ESPHome objects to MQTT 
--]]
local function publishAc(net, app, group, level, select)
  if level == nil then logger('Warning: Nil AC level for '..net..'/'..app..'/'..group, FORCE); do return end end
  local alias = net..'/'..app..'/'..group
  if ac[alias].state ~= level then
    if ignoreMqtt[alias] and (socket.gettime() - ignoreMqtt[alias] > ignoreTimeout) then -- Don't worry about older 'ignore' flags
      ignoreMqtt[alias] = nil
      logger('Ignoring older MQTT ignore flag for '..alias)
    end
    if not ignoreMqtt[alias] then
      local parts = string.split(ac[alias].name, '-')
      local board = parts[1]
      local topic = ''
      if select == 'func' then
        topic = board..'/climate/panasonic/'..parts[2]..'/command'
      elseif select == 'sel' then
        topic = board..'/select/'..parts[2]..'/command'
      elseif select == 'sense' then
        logger('Warning: Not publishing sensor change for alias='..alias)
      else
        logger('Invalid AC command for alias='..alias..', select='..tostring(select), FORCE)
      end
      if topic ~= '' then client:publish(topic, level, mqttQoS, NORETAIN) end
      -- Publishing to MQTT here will result in outstandingMqttMessage() below setting the CBus state for the group.
      -- This is undesired, so ignoreCbus[alias] is used to ensure that the MQTT change received does not set CBus.
      ignoreCbus[alias] = socket.gettime()
      logger('Published AC '..ac[alias].name..' to '..level)
    else
      ignoreMqtt[alias] = nil
      -- logger('Intentionally ignoring MQTT publish for '..alias)
    end
    ac[alias].state = level
  else
    ignoreMqtt[alias] = nil
    logger('Ignoring MQTT publish for '..alias..' because already at level '..level)
  end
end

--[[
Publish Airtopia MODBUS objects to MQTT 
--]]
local function publishAt(net, app, group, level)
  if level == nil then logger('Warning: Nil AT level for '..net..'/'..app..'/'..group, FORCE); do return end end
  local alias = net..'/'..app..'/'..group
  if at[alias].state ~= level then
    if ignoreMqtt[alias] and (socket.gettime() - ignoreMqtt[alias] > ignoreTimeout) then -- Don't worry about older 'ignore' flags
      ignoreMqtt[alias] = nil
      logger('Ignoring older MQTT ignore flag for '..alias)
    end
    if not ignoreMqtt[alias] then
      local parts = string.split(at[alias].name, '-')
      local board = parts[1]
      local topic = 'airtopia/'..board..'/state/'..parts[2]
      local adjust = publishAdj[alias]
      if adjust then level = tonumber(string.format('%.'..adjust.dec..'f', level * adjust.scale)) end
      client:publish(topic, level, mqttQoS, RETAIN)
      -- Publishing to MQTT here will result in outstandingMqttMessage() below setting the CBus state for the group.
      -- This is undesired, so ignoreCbus[alias] is used to ensure that the MQTT change received does not set CBus.
      if level ~= at[alias].state then ignoreCbus[alias] = socket.gettime() end
      logger('Published AT '..at[alias].name..' to '..level)
      -- Determine whether a HomeAssistant state topic needs to be also published
      local st = nil
      local prefix = nil
      local dev = nil
      for k, v in pairs(atDevices) do
        if v == alias then prefix = string.split(k, '-')[1]; st = string.split(k, '-')[2]; break end
      end
      if st == nil then
      elseif st == 'horiz_swing' then
        -- Publish swingha
        local o = atDevices[prefix..'-vert_swing']
        if o ~= nil then
          parts = string.split(o, '/'); net = parts[1]; group = parts[3]; 
          local v = bit.lshift(GetUserParam(net, group), 1)
          local topic = 'airtopia/'..prefix..'/state/swingha'
          local s = bit.bor(tonumber(level), v) + 1
          client:publish(topic, atswings[s], mqttQoS, RETAIN)
        end
      elseif st == 'vert_swing' then
        -- Publish swingha
        local o = atDevices[prefix..'-horiz_swing']
        if o ~= nil then
          parts = string.split(o, '/'); net = parts[1]; group = parts[3]; 
          local h = GetUserParam(net, group)
          local topic = 'airtopia/'..prefix..'/state/swingha'
          local v = bit.lshift(tonumber(level), 1)
          local s = bit.bor(h, v) + 1
          client:publish(topic, atswings[s], mqttQoS, RETAIN)
        end
      elseif st == 'fan' then
        -- Publish fanha
        local fanv = atfans[level+1]
        local topic = 'airtopia/'..board..'/state/fanha'
        client:publish(topic, fanv, mqttQoS, RETAIN)
      end
    else
      ignoreMqtt[alias] = nil
      logger('Intentionally ignoring MQTT publish for '..alias)
    end
    at[alias].state = level
  else
    ignoreMqtt[alias] = nil
    logger('Ignoring MQTT publish for '..alias..' because already at level '..level)
  end
end


--[[
Get level name and value
--]]
local function decodeLevel(alias, level, default)
  local lvl, net, app, group
  local parts = string.split(alias, '/'); net = parts[1]; app = parts[2]; group = parts[3]
  if contains('/', level) then logger('Error: Legacy separator "/" being used for '..alias..'! Use ":" instead', FORCE) return nil, nil end
  local parts = string.split(level, ':')
  if #parts == 2 then -- A select option and level
    lvl = tonumber(parts[2])
    if lvl < 0 or lvl > 255 then logger('Error: Invalid level for '..alias..', level '..lvl..', ignoring', FORCE) return nil, nil end
    return parts[1], lvl
  elseif #parts == 1 and tonumber(parts[1]) then -- Level numbers only
    lvl = tonumber(parts[1])
    if lvl < 0 or lvl > 255 then logger('Error: Invalid level for '..alias..', level '..lvl..', ignoring', FORCE) return nil, nil end
    parts[1] = GetCBusLevelTag(tNetAC(net), app, group, lvl)
    if parts[1] == nil then
      if default == nil then
        logger('Error: No level tag for '..alias..', level '..lvl..' which is required when specifying numeric level only, so ignoring', FORCE) return nil, nil
      else
        parts[1] = default
        logger('Warning: Trigger '..alias..' has no level tag defined for level '..level..', setting to "'..default..'"', FORCE)
      end
    end
    return parts[1], lvl
  elseif #parts == 1 then -- Level tags only
    lvl = GetCBusLevelAddress(net, app, group, parts[1])
    if lvl == nil then logger('Error: Invalid level tag for '..alias..', level '..parts[1]..', so not adding and ignoring', FORCE) return nil end
    return parts[1], lvl
  end
end


--[[
Build and publish a CBus MQTT discovery topic
--]]
local function addDiscover(net, app, group, channel, tags, name)
  if not name then -- Need a name from tag lookup for everything but measurement app
    if channel == nil then
      logger('Warning: nil channel for name '..str(name)..' at '..net..'/'..app..'/'..group..'... a name is required so ignoring', FORCE)
      return false
    else
      if app ~= 255 then
        name = 'Measurement'
      else
        name = 'Unit parameter'
      end
    end
  end
  -- All keywords except MQTT are optional (some exceptions), with 'light' as default discovery type. Defaults:
  local _L = {
    ['pn'] = name,      -- Preferred name
    ['sa'] = '',        -- Suggested area
    ['img'] = '',       -- Image
    ['unit'] = '',      -- Units
    ['class'] = '',     -- HomeAssistant class
    ['dec'] = 2,        -- Decimal places
    ['scale'] = 1,      -- Scale (multiplier or divider)
    ['on'] = 'On',      -- bsensor 'on' string
    ['off'] = 'Off',    -- bsensor 'off' string
    ['lvl'] = {},       -- Levels
  }
  local dType = 'light' -- Use light as default HomeAssistant type if not specified
  local includeUnit = false
  local lvl = false
  local action, boid, dSa, payload, prefix, tag
  
  -- Build an alias to refer to each group
  local aAlias = tNetAC(net)..'/'..app..'/'..group; if channel ~= nil then aAlias = aAlias..'/'..channel end -- Automation controller numbered networks
  local alias = net..'/'..app..'/'..group -- CBus numbered networks

  local allow = {
    ['light'] = {['getPayload'] = function()
      return {stat_t = mqttReadTopic..alias..'/state', cmd_t = mqttWriteTopic..alias..'/switch', bri_stat_t = mqttReadTopic..alias..'/level', bri_cmd_t = mqttWriteTopic..alias..'/ramp', pl_off = 'OFF', on_cmd_type = 'brightness',}
      end },
    ['switch'] = {['getPayload'] = function()
      return {stat_t = mqttReadTopic..alias..'/state', cmd_t = mqttWriteTopic..alias..'/switch', pl_on = 'ON', pl_off = 'OFF',}
      end },
    ['cover'] = {['getPayload'] = function()
      cover[alias] = true
      return {stat_t = mqttReadTopic..alias..'/state', cmd_t = mqttWriteTopic..alias..'/ramp', pos_open = 255, pos_clsd = 0, pl_open = 'OPEN', pl_cls = 'CLOSE', pos_t = mqttReadTopic..alias..'/level', set_pos_t = mqttWriteTopic..alias..'/ramp',}
      end },
    ['fan'] = {['getPayload'] = function() return {
      stat_t = mqttReadTopic..alias..'/state', cmd_t = mqttWriteTopic..alias..'/ramp', pl_on = 'ON', pl_off = 'OFF', pr_modes = {'low', 'medium', 'high'},
      pr_mode_cmd_t = mqttWriteTopic..alias..'/ramp', pr_mode_cmd_tpl = '{% if value == "low" %} 86 {% elif value == "medium" %} 170 {% elif value == "high" %} 255 {% endif %}',
      pr_mode_stat_t = mqttReadTopic..alias..'/level', pr_mode_val_tpl = '{% if value == 0 %} OFF {% elif value == 86 %} low {% elif value == 170 %} medium {% elif value == 255 %} high {% endif %}'
    } end },
    ['fan_pct'] = {['getPayload'] = function()
      dType = 'fan' fan[aAlias] = true
      return {stat_t = mqttReadTopic..alias..'/state', cmd_t = mqttWriteTopic..alias..'/switch', pl_on = 'ON', pl_off = 'OFF', pct_cmd_t = mqttWriteTopic..alias..'/ramp', pct_stat_t = mqttReadTopic..alias..'/level', opt = true,}
      end },
    ['sensor'] = {['getPayload'] = function()
      local payload
      if channel ~= nil then payload = { stat_t = mqttReadTopic..alias..'_'..channel..'/state', } alias = alias..'/'..channel else payload = { stat_t = mqttReadTopic..alias..'/state', } end
      if _L.class ~= '' then payload.dev_cla = class end
      if app == 250 then userParameter[alias] = true end
      if app == 255 then unitParameter[alias] = true end
      if _L.dec ~= 2 or _L.scale ~= 1 then publishAdj[alias] = { dec = _L.dec, scale = _L.scale } end -- Scale, decimals and units only for sensors
      if _L.unit ~= '' then payload.unit_of_meas = _L.unit end
      return payload
      end },
    ['binary_sensor'] = {['getPayload'] = function()
      binarySensor[aAlias] = true
      return {stat_t = mqttReadTopic..alias..'/state', pl_on = 'ON', pl_off = 'OFF',}
      end },
    ['bsensor'] = {['getPayload'] = function()
      bSensor[aAlias] = true dType = 'sensor'
      return {stat_t = mqttReadTopic..alias..'/state', val_tpl = '{% if value | float == 0 %} '..off..' {% else %} '..on..' {% endif %}',}
      end },
    ['button'] = {['getPayload'] = function()
      if lighting[tostring(app)] then lightingButton[aAlias] = true return {cmd_t = mqttWriteTopic..alias..'/press',} else return nil end
      end },
    ['select'] = {['getPayload'] = function()
      if #_L.lvl == 0 then logger('Error: lvl= keyword not specified for select at '..aAlias..', which is required so ignoring', FORCE) return nil end
      local level
      local options = {}
      selects[aAlias] = {}
      for _, level in ipairs(_L.lvl) do
        local opt, sel = decodeLevel(aAlias, level)
        if opt ~= nil then
          options[#options + 1] = opt
          selects[aAlias][opt] = sel
          if not selects[aAlias].allLvl then selects[aAlias].allLvl = {} end; selects[aAlias].allLvl[#selects[aAlias].allLvl + 1] = { lvl = sel, sel = opt }
        else
          logger('Error: Invalid lvl= for select '..aAlias..', so not adding and ignoring', FORCE) return nil
        end
        -- if not selects[aAlias].allLvl then selects[aAlias].allLvl = {} end; selects[aAlias].allLvl[#selects[aAlias].allLvl + 1] = { lvl = tonumber(parts[2]), sel = parts[1] }
      end
      table.sort(selects[aAlias].allLvl, function (left, right) return left.lvl < right.lvl end)
      return {stat_t = mqttReadTopic..alias..'/select', cmd_t = mqttWriteTopic..alias..'/select', options = options,}
      end },
  }

  -- Extract MQTT topic settings
  for _, t in ipairs(tags) do
    local tp = string.split(t, '=')
    local k = trim(tp[1]):lower()
    if k == 'includeunit' then includeUnit = true end
    if tp[2] then
      local v = trim(tp[2])
      if _L[k] then
        if type(_L[k]) == 'number' then _L[k] = tonumber(v)
        elseif type(_L[k]) == 'table' then
          if contains('-', v) then logger('Error: Legacy separator "-" being used to separate list members '..aAlias..'! Use "/" instead', FORCE) return false end
          _L[k] = string.split(v, '/')
          local tv for _, tv in ipairs(_L[k]) do tv = trim(tv) end
        else _L[k] = v end
      end
    else
      if allow[k] then dType = k end
    end
    -- Any other unrecognised keywords that may be set are ignored, as they likely have an unrelated use
  end
  
  -- Default images for a lighting group
  if _L.img == '' and lighting[tostring(app)] then
    local pnl = _L.pn:lower()
    for k, v in pairs(imgDefault) do
      if contains(k, pnl) then
        if type(v) == 'string' then _L.img = v
        else
          local ik, iv, theElse
          for ik, iv in pairs(v) do if ik ~= '#else' then if contains(ik, pnl) then _L.img = iv end else theElse = v['#else'] end end
          if _L.img == '' then _L.img = theElse end
        end
      end
    end
    if _L.img == '' then _L.img = 'mdi:lightbulb' end
  end

  if dType == 'light' and app == 228 then dType = 'sensor'; logger('Warning: publishing '..aAlias..' as a sensor', FORCE) end -- Measurement app sensor with incorrect/missing type
  if includeUnit then includeUnits[aAlias] = true logger('Including units for '..aAlias) else includeUnits[aAlias] = nil end

  -- Build an OID (measurement application gets a channel as well), also add to mqttDevices
  local oid = 'cbus_mqtt_'..net..'_'.. app..'_'..group; if channel ~= nil then oid = oid..'_'..channel end;
  mqttDevices[aAlias].oid = oid

  -- Handle the typical single device payload build
  payload = allow[dType].getPayload()

  if payload ~= nil then
    mqttDevices[aAlias].type = dType -- If payload recieved than set the mqttDevices type, then move on to publish
  else
    -- Or if a nil payload so far then build and publish the trigger app buttons if applicable on all specific levels and publish as separate devices, and then return
    if dType == 'button' and app == 202 then
      local i
      mqttDevices[aAlias].trigger = {}
      mqttDevices[aAlias].type = 'button'
      if #_L.lvl == 0 then for i = 0,255 do _L.lvl[#_L.lvl + 1] = i end end -- If no "lvl=" specified then scan all levels
      for _, i in ipairs(_L.lvl) do
        local tag, lvl = decodeLevel(aAlias, i, publishNoLevel and 'Level '..i or nil)
        if tag then
          boid = oid..'_'..lvl
          action = tag:gsub("%s+", "_"):lower()
          if triggers[group] == nil then triggers[group] = {} end
          triggers[group][action] = lvl
          if _L.pn == name then prefix = '' else prefix = _L.pn..' ' end
          local entity = prefix..tag
          if _L.sa ~= '' then
            local startIdx, endIdx
            repeat
              startIdx, endIdx = entity:find(_L.sa, 1, true)
              if startIdx and startIdx == 1 then
                entity = entity:sub(endIdx + 1):match'^%s*(.*)'
              end
            until not startIdx or startIdx > 1
          end
          payload = {
            name = '',
            obj_id = boid,
            uniq_id = boid,
            cmd_t = mqttWriteTopic..alias..'/'..action..'/press',
            dev = { name=entity, ids=trim(_L.sa..' '..entity), sa=_L.sa, mf='Schneider Electric', mdl='CBus' },
          }
          if _L.img ~= '' then payload.ic = _L.img end
          local oldDiscovery = discovery[boid]
          discovery[boid] = dType
          -- If dType has changed for an existing discovery topic then remove the previous topic
          if oldDiscovery ~= nil and oldDiscovery ~= dType then
            client:publish(mqttDiscoveryTopic..oldDiscovery..'/'..boid..'/config', '', mqttQoS, RETAIN)
            logger('Removed discovery topic'..mqttDiscoveryTopic..oldDiscovery..'/'..boid..'/config')
          end
          -- Publish to MQTT broker
          local j = json.encode(payload)
          if _L.sa == '' then dSa = 'no preferred area' else dSa = _L.sa end
          logger('Publishing '..mqttDiscoveryTopic..dType..'/'..boid..'/config as '.._L.pn..' in area '..dSa)
          client:publish(mqttDiscoveryTopic..dType..'/'..boid..'/config', j, mqttQoS, RETAIN)
          table.insert(mqttDevices[aAlias].trigger, boid)
        end
      end
      return true

    elseif dType == 'button' then
      logger('Warning: MQTT button keyword used for unsupported application group '..aAlias..', so ignoring', FORCE)
      return false
    end
  end

  if payload ~= nil then
    -- Add payload common to all
    local entity = _L.pn
    if _L.sa ~= '' then
      local startIdx, endIdx
      repeat
        startIdx, endIdx = entity:find(_L.sa, 1, true)
        if startIdx and startIdx == 1 then
          entity = entity:sub(endIdx + 1):match'^%s*(.*)'
        end
      until not startIdx or startIdx > 1
    end 
    payload.name = ''
    payload.obj_id = oid
    payload.uniq_id = oid
    payload.avty_t = mqttCbus..'status'
    payload.dev = { name=entity, ids=trim(_L.sa..' '..entity), sa=_L.sa, mf='Schneider Electric', mdl='CBus' }
    if _L.img ~= '' then payload.ic = _L.img end

    local oldDiscovery = discovery[oid]
    discovery[oid] = dType

    -- If dType has changed for an existing discovery topic then remove the previous topic
    if oldDiscovery ~= nil and oldDiscovery ~= dType then
      client:publish(mqttDiscoveryTopic..oldDiscovery..'/'..oid..'/config', '', mqttQoS, RETAIN)
      logger('Removed discovery topic '..mqttDiscoveryTopic..oldDiscovery..'/'..oid..'/config')
    end

    -- Publish to MQTT broker
    local j = json.encode(payload)
    if _L.sa == '' then dSa = 'no preferred area' else dSa = _L.sa end
    logger('Publishing '..mqttDiscoveryTopic..dType..'/'..oid..'/config as '.._L.pn..' in area '..dSa)
    client:publish(mqttDiscoveryTopic..dType..'/'..oid..'/config', j, mqttQoS, RETAIN)
    return true
  else
    logger('Warning: a publish payload for '..name..' could not be built, so not published', FORCE)
  end
end

--[[
Build and publish an Airtopia discovery topic
--]]
local function addAtDiscover(name, sa, unit)
  local dSa, payload

  if logging then
    if sa == '' then dSa = 'no preferred area' else dSa = sa end
    logger('Publish discovery '..name..' in area '..dSa)
  end
  if unit == nil then unit = 'A' end

  -- Build an OID and name prefix
  local sao = ''; if sa ~= '' then sao = string.lower(sa:gsub("% ", "_"))..'_' end
  local oid = 'cbus_mqtt_'..sao..string.lower(name:gsub("% ", "_"))

  payload = {
    name = '',
    obj_id = oid,
    uniq_id = oid,
    avty_t = mqttCbus..'status',
    dev = { name=name, ids=sa..' '..name, sa=sa, mf='Schneider Electric', mdl='Airtopia' },
    mode_cmd_t = 'airtopia/'..sao..name..'/cmd/mode',
    mode_stat_t = 'airtopia/'..sao..name..'/state/modeha',
    pow_cmd_t = 'airtopia/'..sao..name..'/cmd/power',
    temp_cmd_t = 'airtopia/'..sao..name..'/cmd/target_temperature',
    temp_stat_t = 'airtopia/'..sao..name..'/state/target_temperature',
    curr_temp_t = 'airtopia/'..sao..name..'/state/current_temperature',
    swing_modes = atswings,
    swing_mode_cmd_t = 'airtopia/'..sao..name..'/cmd/swing',
    swing_mode_stat_t = 'airtopia/'..sao..name..'/state/swingha',
    fan_modes = atfans,
    fan_mode_cmd_t = 'airtopia/'..sao..name..'/cmd/fan',
    fan_mode_stat_t = 'airtopia/'..sao..name..'/state/fanha',
    temp_unit = "C",
    opt = false,
    pl_on = 'ON',
    pl_off = 'OFF',
    precision = 1.0,
  }

  -- Publish to MQTT broker
  local j = json.encode(payload)
  logger('Publishing '..mqttDiscoveryTopic..'climate/'..oid..'/config')
  client:publish(mqttDiscoveryTopic..'climate/'..oid..'/config', j, mqttQoS, RETAIN)

  -- Add a power consumption sensor discovery topic
  payload = {
    name = '',
    obj_id = oid..'_power',
    uniq_id = oid..'_power',
    avty_t = mqttCbus..'status',
    dev = { name=name..' Power Consumption', ids=sa..' '..name..' Power Consumption', sa=sa, mf='Schneider Electric', mdl='Airtopia' },
    stat_t = 'airtopia/'..sao..name..'/state/power_consumption',
    unit_of_meas = unit,
  }
  local j = json.encode(payload)
  logger('Publishing'..mqttDiscoveryTopic..'sensor/'..oid..'_power'..'/config')
  client:publish(mqttDiscoveryTopic..'sensor/'..oid..'_power'..'/config', j, mqttQoS, RETAIN)
end


--[[
Add Airtopia objects 
--]]
local atLog = {}
local atLogGrp = {}
local function addAt(grps, found)
  local atArea = {}
  local atDevs = {}
  local k, v
  local addition = false
  local scan = {}
  local found = {}
  for k, v in pairs(grps) do
    local net = v.address[1]; local app = v.address[2]; local group = v.address[3]
    local pn = v.name
    local alias = table.concat(v.address, '/')
    local unit = 'A'
    local scale = 1
    local decimals = 2

    local dev = ''; local func = ''; local sense = ''; local sa = ''; local tags = v.keywords
    for _, t in ipairs(tags) do
      tp = string.split(t, '=')
      tp[1] = trim(tp[1]):lower()
      if tp[2] then
        tp[2] = trim(tp[2])
        if tp[1] == 'dev' then dev = tp[2]; atDevs[dev] = true -- Device
        elseif tp[1] == 'func' then func = tp[2] -- Function
        elseif tp[1] == 'sense' then sense = tp[2] -- Sensor
        elseif tp[1] == 'dec' then decimals = tonumber(tp[2])
        elseif tp[1] == 'scale' then scale = tonumber(tp[2])
        elseif tp[1] == 'unit' then unit = tp[2]
        elseif tp[1] == 'sa' then
          sa = tp[2] -- Suggested area
          if atArea[dev] == nil then
            atArea[dev] = sa  -- The suggested area found is noted as being applicable for all user params of the device; only one is needed
            atLog[dev] = nil
          end
        end
      end
    end
    if sense ~= '' then
      if scale ~= 1 or decimals ~= 2 then publishAdj[alias] = { dec=decimals, scale=scale } end
    end
    scan[#scan+1] = {alias=alias, dev=dev, func=func, sense=sense, unit=unit}
  end

  for _, v in ipairs(scan) do
    if v['dev'] ~= '' then
      if atLog[v['dev']] == nil and atArea[v['dev']] == nil then
        logger('Error: No suggested area set for Airtopia device '..v['dev']..'. At least one user parameter needs "sa="', FORCE)
        atLog[v['dev']] = true -- Logged for the device, so do not log any further related user param issues for the device
        goto nextAt
      end
      if at[v['alias']] == nil and atArea[v['dev']] ~= nil then
        local sa = atArea[v['dev']]; if sa == nil then sa = '' end
        local sao = ''; if sa ~= '' then sao = string.lower(sa:gsub("% ", "_"))..'_' end
        local parts = string.split(v['alias'], '/')
        local net = parts[1]; local app = parts[2]; local group = parts[3]
        if v['func'] ~= '' then
          if not at[v['alias']] then
            at[v['alias']] = {}; addition = true
            at[v['alias']].name = sao..v['dev']..'-'..v['func']; at[v['alias']].select = 'func'; atDevices[sao..v['dev']..'-'..v['func']] = v['alias'];
            if atBoards[sao..v['dev']] == nil and v['func'] == 'power' then atBoards[sao..v['dev']] = {alias=v['alias'], dev=v['dev'], sa=sa} end
            publishAt(net, app, group, GetUserParam(net, group))
            atLog[v['dev']] = nil
            atLogGrp[v['alias']] = nil
          end
        elseif sense ~= '' then
          if not at[v['alias']] then
            if atBoards[sao..v['dev']] ~= nil then
              at[v['alias']] = {}; addition = true
              at[v['alias']].name = sao..v['dev']..'-'..v['sense']; at[v['alias']].select = 'sense'; at[v['alias']].sense = v['sense']; atDevices[sao..v['dev']..'-'..v['sense']] = v['alias']
              atBoards[sao..v['dev']]['unit'] = v['unit']
              publishAt(net, app, group, GetUserParam(net, group))
              atLog[v['dev']] = nil
              atLogGrp[v['alias']] = nil
            end
          end
        end
      end
    else
      if not atLogGrp[v['alias']] then logger('Error: No device specified for Airtopia group '..v['alias'], FORCE); atLogGrp[v['alias']] = true end
    end
    ::nextAt::
    if at[v['alias']] ~= nil and atArea[v['dev']] ~= nil then
      table.insert(found, v['alias']) -- Valid, having a sa=, so found (otherwise removed elsewhere if an existing device)
    end
  end
  return addition, found
end


--[[
Queue up initial discovery and current state CBus objects, plus Airtopia if used
--]]
local function publishCurrent()
  -- CBus
  mqttDevices = {}
  local grps = GetCBusByKW('MQTT', 'or')
  local n = 0
  local i, k, v
  for _, v in pairs(grps) do
    n = n + 1
    local alias = table.concat(v.address, '/')
    table.sort(v.keywords)
    local name; if v.name then name = v.name else name = GetCBusGroupTag(v.address[1], v.address[2], v.address[3]) end
    unpublished[n] = {net=v.address[1], app=v.address[2], group=v.address[3], channel=v.address[4], tags=v.keywords, name=name}
    if not mqttDevices[alias] then mqttDevices[alias] = {}; mqttDevices[alias].tags = table.concat(v.keywords,',') end
  end
  if n > 0 then logger('Queued '..n..' objects with keyword MQTT for publication') end

  if airtopiaSupport then
    -- Airtopia
    atDevices = {}
    grps = GetCBusByKW('AT', 'or')
    addAt(grps)
    local raw = {}
    local dev
    for k, v in ipairs(grps) do
      local tags = v['keywords']
      dev = ''; local sa = nil
      for _, tag in ipairs(tags) do
        local parts = string.split(tag, '=')
        if parts[1] == 'dev' then
          dev = parts[2]
        elseif parts[1] == 'sa' then
          sa = parts[2]
        end
      end
      if dev ~= '' then
        if sa ~= nil then raw[dev] = sa end
      else
        if not atLogGrp[table.concat(v['address'], '/')] then
          logger('Error: No device specified for Airtopia group '..table.concat(v['address'], '/'), FORCE)
          atLogGrp[table.concat(v['address'], '/')] = true
        end
      end
    end
    n = 0
    for k, v in pairs(raw) do
      n = n + 1
      unpublishedAt[n] = {name=k, sa=v}
    end
    if n > 0 then logger('Queued '..n..' objects with keyword AT for publication') end
  end
end


--[[
Create / update / delete AC devices
--]]
local acLogGrp = {}
local function cudAc(initial)
  local grps = GetCBusByKW('AC', 'or')
  local found = {}
  local addition = false
  local k, v

  for k, v in pairs(grps) do
    local net = v.address[1]; local app = v.address[2]; local group = v.address[3]
    local pn = v.name
    local alias = table.concat(v.address, '/')

    table.insert(found, alias)

    local dev=''; local func = ''; local sel = ''; local sense = ''; local topic = 'sensor'; local tags = v.keywords
    for _, t in ipairs(tags) do
      local tp = string.split(t, '=')
      tp[1] = trim(tp[1])
      if tp[2] then
        tp[2] = trim(tp[2])
        if tp[1] == 'dev' then dev = tp[2] -- Device
        elseif tp[1] == 'func' then func = tp[2] -- Function
        elseif tp[1] == 'sel' then sel = tp[2] -- Select
        elseif tp[1] == 'sense' then sense = tp[2] -- Sensor
        elseif tp[1] == 'topic' then topic = tp[2] -- Topic for sensor
        end
      end
    end
    if dev ~= '' then
      if func ~= '' then
        if not ac[alias] then ac[alias] = {}; addition = true end
      	ac[alias].name = dev..'-'..func; ac[alias].select = 'func'; acDevices[dev..'-'..func] = alias; acBoards[dev] = true
      elseif sel ~= '' then
        if not ac[alias] then ac[alias] = {}; addition = true end
      	ac[alias].name = dev..'-'..sel; ac[alias].select = 'sel'; acDevices[dev..'-'..sel] = alias; acBoards[dev] = true
      elseif sense ~= '' then
        if not ac[alias] then ac[alias] = {}; addition = true end
      	ac[alias].name = dev..'-'..sense; ac[alias].select = 'sense'; ac[alias].sense = sense; ac[alias].topic = topic; acDevices[dev..'-'..sense..'-sense'] = alias; acBoards[dev] = true
      end
      acLogGrp[alias] = nil
    else
      if not acLogGrp[alias] then logger('Error: No device specified for Panasonic '..alias, FORCE); acLogGrp[alias] = true end
    end
  end
    
  -- Handle deletions
  for k, _ in pairs(ac) do
    local f = false; for _, v in ipairs(found) do if k == v then f = true; break end end
    if not f then kill = ac[k].name; ac[k] = nil; acDevices[kill] = nil end
  end
  -- Handle additions, and re-subscribe all board topics to get status of newly added devices
  if addition then
    if not initial then
      -- Ensure that newly tagged/removed groups with the AC keyword send updates.
      logger('AC object keywords added, restarting event script', FORCE)
      script.disable('AC'); script.enable('AC')
    end
    for k, _ in pairs(acBoards) do client:subscribe(k..'/#', 2) end
  end
end


--[[
Publish the state of Airtopia devices
--]]
local function publishAtState()
  local k
  for k, _ in pairs(atBoards) do
    local parts, topic, level
    
    local mode = atDevices[k..'-mode']
    local power = atDevices[k..'-power']
    if mode ~= nil and power ~= nil then
      parts = string.split(mode, '/'); local mnet = tonumber(parts[1]); local mgroup = tonumber(parts[3])
      parts = string.split(power, '/'); local pnet = tonumber(parts[1]); local pgroup = tonumber(parts[3])
      topic = 'airtopia/'..k..'/state/modeha'
      if GetUserParam(pnet, pgroup) == 0 then
        level = 'off'
      else
        level = atmodes[GetUserParam(mnet, mgroup)]
      end
      client:publish(topic, level, mqttQoS, RETAIN)
    end
    local hswing = atDevices[k..'-horiz_swing']
    local vswing = atDevices[k..'-vert_swing']
    if hswing ~= nil and vswing ~= nil then
      parts = string.split(hswing, '/'); local hnet = tonumber(parts[1]); local hgroup = tonumber(parts[3])
      parts = string.split(vswing, '/'); local vnet = tonumber(parts[1]); local vgroup = tonumber(parts[3])
      topic = 'airtopia/'..k..'/state/swingha'
      local h = GetUserParam(hnet, hgroup)
      local v = bit.lshift(GetUserParam(vnet, vgroup), 1)
      local s = bit.bor(h, v) + 1
      client:publish(topic, atswings[s], mqttQoS, RETAIN)
    end
    local fan = atDevices[k..'-fan']
    if fan ~= nil then
      parts = string.split(fan, '/'); local fnet = tonumber(parts[1]); local fgroup = tonumber(parts[3])
      topic = 'airtopia/'..k..'/state/fanha'
      local f = GetUserParam(fnet, fgroup)
      client:publish(topic, atfans[f+1], mqttQoS, RETAIN)
    end
    client:subscribe('airtopia/'..k..'/#', 2)
  end
end


--[[
Create / update / delete Airtopia devices
--]]
local function cudAt(initial)
  local grps = GetCBusByKW('AT', 'or')
  local boards = copy(atBoards)
  local k, v, topic
  unpublishedAt = {}
  
  local addition = false
  local found = addAt(grps)

  -- Handle deletions
  for k, _ in pairs(at) do
    local f = false; for _, v in ipairs(found) do if k == v then f = true; break end end
    if not f then kill = at[k].name; at[k] = nil; atDevices[kill] = nil end
  end
  local newBoards = {}
  for k, _ in pairs(atDevices) do
    local parts = string.split(k, '-')
    newBoards[parts[1]] = true
  end
  local kill = {} for k, _ in pairs(atBoards) do if newBoards[k] == nil then table.insert(kill, k) end end
  for _, k in ipairs(kill) do
    atBoards[k] = nil;
    -- Clean up discovery topics
    topic = mqttDiscoveryTopic..'climate/'..'cbus_mqtt_'..k..'/config'; client:publish(topic, '', mqttQoS, RETAIN); logger('Removed discovery topic '..topic, FORCE)
    topic = mqttDiscoveryTopic..'sensor/'..'cbus_mqtt_'..k..'_power/config'; client:publish(topic, '', mqttQoS, RETAIN);  logger('Removed discovery topic '..topic, FORCE)
    -- Clean up state and cmd topics under airtopia/device
    for _, v in ipairs(airtopiaStates) do client:publish('airtopia/'..k..'/state/'..v, '', mqttQoS, RETAIN) end
    for _, v in ipairs(airtopiaCmds) do client:publish('airtopia/'..k..'/cmd/'..v, '', mqttQoS, RETAIN) end
    logger('Removed device command and state topics', FORCE)
  end

  -- Handle additions
  local n = 0
  for k, v in pairs(atBoards) do
    if boards[k] == nil then
      if v['sa'] ~= nil then
        n = n + 1
        unpublishedAt[n] = {name=v['dev'], sa=v['sa'], unit=v['unit']}
        addition = true
      else
        logger('Error publishing Airtopia '..k..'. No suggested area given', FORCE)
      end
    end
  end
      
  if addition then
    if not initial then
      -- Ensure that newly tagged/removed groups with the AT keyword send updates.
      logger('AT object keywords added, restarting event script', FORCE)
      script.disable('AT'); script.enable('AT')
    end
  end
end

--[[
Create / update / delete ENV (environment) devices
--]]
local envLogGrp = {}
local function cudEnv(initial)
  local grps = GetCBusByKW('ENV', 'or')
  local found = {}
  local addition = false
  local k, v

  for k, v in pairs(grps) do
    local net = v.address[1]; local app = v.address[2]; local group = v.address[3]
    local alias = table.concat(v.address, '/')

    table.insert(found, alias)

    local dev=''; local func = ''; local sel = ''; local tags = v.keywords
    for _, t in ipairs(tags) do
      local tp = string.split(t, '=')
      tp[1] = trim(tp[1])
      if tp[2] then
        tp[2] = trim(tp[2])
        if tp[1] == 'dev' then dev = tp[2] -- Device
        elseif tp[1] == 'func' then func = tp[2] -- Function
        end
      end
    end
    if dev ~= '' then
      if func == '' then
        local n
        if v.name then n = v.name else n = GetCBusGroupTag(net, app, group) end
        func = n:lower():gsub("%s+", "_")
      end
      if not env[alias] then env[alias] = {}; addition = true end
      env[alias].name = dev..'-'..func; envDevices[dev..'-'..func] = alias; envBoards[dev] = true
      envLogGrp[alias] = nil
    else
      if not envLogGrp[alias] then logger('Error: No device specified for environment sensor '..alias, FORCE); envLogGrp[alias] = true end
    end
  end
    
  -- Handle deletions
  for k, _ in pairs(env) do
    local f = false; for _, v in ipairs(found) do if k == v then f = true; break end end
    if not f then kill = env[k].name; env[k] = nil; envDevices[kill] = nil end
  end
  -- Handle additions, and re-subscribe all board topics to get status of newly added devices
  if addition then
    if not initial then logger('ENV object keyword added', FORCE) end
    for k, _ in pairs(envBoards) do client:subscribe(k..'/#', 2) end
  end
end

--[[
Create / update / delete CBus MQTT discovery topics
--]]
local function cudCBusTopics()
  local grps = GetCBusByKW('MQTT', 'or')
  local found = {}
  local lvlDelete = {}
  local n = 0
  unpublished = {}
  local queued = {}
  local k, v, alias, lvl, name

  for k, v in pairs(grps) do
    local change = false
    local net = v.address[1]; local app = v.address[2]; local group = v.address[3]; local channel = nil; if v.address[4] then channel = v.address[4] end
    alias = table.concat(v.address, '/')

    table.insert(found, alias)
    table.sort(v.keywords)
    local curr = table.concat(v.keywords,',')
    if not mqttDevices[alias] then -- New group
      change = true
      mqttDevices[alias] = {}
      mqttDevices[alias].tags = curr
    else
      if mqttDevices[alias].tags ~= curr then -- Modified group
        lvl = nil; local i; for i = 1,#v.keywords do local parts = string.split(v.keywords[i], '=');
          if parts[1] == 'lvl' then
            -- lvl = parts[2];
            local pp = {} local l local p = string.split(parts[2], '/') for _, l in ipairs(p) do _, l = decodeLevel(alias, l) pp[#pp+1] = l end table.sort(pp) lvl = table.concat(pp,'/')
            break
          end
        end
        if app == 202 and lvl ~= nil then -- Check for levels being changed
          
          local function difference(a, b)
            local lvl
            local aa = {}; for _, v in ipairs(a) do aa[v] = true end; for _, v in ipairs(b) do aa[v] = nil end
            local ret = {}; for _, v in ipairs(a) do if aa[v] then ret[#ret+1]=v end end
            return ret
          end
          
          local oldTags = string.split(mqttDevices[alias].tags, ',')
          local i, olvl = ''; for i = 1,#oldTags do local parts = string.split(oldTags[i], '=')
            if parts[1] == 'lvl' then
              -- olvl = parts[2]
              local pp = {} local l local p = string.split(parts[2], '/') for _, l in ipairs(p) do _, l = decodeLevel(alias, l) pp[#pp+1] = l end table.sort(pp) olvl = table.concat(pp,'/')
              break
            end
          end
          local diff = difference(string.split(olvl, '/'), string.split(lvl, '/'))
          if #diff > 0 then lvlDelete[alias] = diff end
          if len(string.split(lvl,'/')) > len(string.split(olvl,'/')) then change = true end
        end
        if app ~= 202 then change = true end
        mqttDevices[alias].tags = curr
      end
    end
    if change then
      if v.name then name = v.name else name = GetCBusGroupTag(net, app, group) end
      n = n + 1
      unpublished[n] = {net=net, app=app, group=group, channel=channel, tags=v.keywords, name=name}
      queued[#queued + 1] = alias
    end
  end
  if n > 0 then logger('Queued '..n..' object'..(n ~= 1 and 's' or '')..' with keyword MQTT for publication: '..table.concat(queued, ', '), FORCE) end

  -- Handle deletions
  local kill = {}
  for k, v in pairs(mqttDevices) do
    local topic, oid, trigger
    local f = false; for _, vv in ipairs(found) do if k == vv then f = true; break end end
    if not f then
      table.insert(kill, k)
      local parts = string.split(k, '/')
      if parts[2] == '202' then
        for _, trigger in ipairs(v.trigger) do
          topic = mqttDiscoveryTopic..v.type..'/'..trigger..'/config'
      	  client:publish(topic, '', mqttQoS, RETAIN); logger('Removed discovery topic '..topic, FORCE)
          local t = tonumber(string.match(trigger, '_(%w+)$'))
          local act
          local tk, tv
          for tk, tv in pairs(triggers[tonumber(parts[3])]) do
            if t == tv then act = tk break end
          end
          t = mqttWriteTopic..tNetCBus(tonumber(parts[1]))..'/'..parts[2]..'/'..parts[3]..'/'..act..'/press'
          if mqttJunk then client:publish(t, 'junk', mqttQoS, RETAIN) end -- Publish junk to all topics to be deleted to ensure that they are actually deleted (some topics may not have been written yet)
          client:publish(t, '', mqttQoS, RETAIN)
        end
      else
        topic = mqttDiscoveryTopic..v.type..'/'..v.oid..'/config'
      	client:publish(topic, '', mqttQoS, RETAIN); logger('Removed discovery topic '..topic, FORCE)
      end
      if parts[2] ~= '202' then
        local count, topic
        _, count = k:gsub('/','')
        if count == 3 then -- Measurement application
          local t = tNetCBus(tonumber(parts[1]))..'/'..parts[2]..'/'..parts[3]..'/'..parts[4]
          t = t:gsub('/', '_'); t = t:gsub('_', '/', 2) -- Convert the last slash to an underscore
          topic = mqttReadTopic..t;
        else
          topic = mqttReadTopic..tNetCBus(tonumber(parts[1]))..'/'..parts[2]..'/'..parts[3]
        end
        if mqttJunk then client:publish(topic..'/state', 'junk', mqttQoS, RETAIN) end
        client:publish(topic..'/state', '', mqttQoS, RETAIN)
        if count ~= 3 or bSensor[k] or binarySensor[k] then  -- Level not set for measurement and binary sensors
          if mqttJunk then client:publish(topic..'/level', 'junk', mqttQoS, RETAIN) end
          client:publish(topic..'/level', '', mqttQoS, RETAIN)
        end
        includeUnits[alias] = nil
      end
    else
      -- Handle trigger level removal
      if lvlDelete[k] ~= nil then
        local parts = string.split(k, '/')
        local group = tonumber(parts[3])
        if triggers[group] then
          for _, lvl in ipairs(lvlDelete[k]) do
            local a, i, t, act = nil
            for a, t in pairs(triggers[group]) do if t == tonumber(lvl) then act = a; break end end
            local remove = nil
            if act then
              trigger = nil
              for i, t in ipairs(v.trigger) do if lvl == string.match(t, '_(%w+)$') then trigger = t; remove = i; break end end
              if trigger then
                topic = mqttDiscoveryTopic..v.type..'/'..trigger..'/config'
                client:publish(topic, '', mqttQoS, RETAIN); logger('Remove discovery topic for '..topic..' (trigger level '..lvl..')', FORCE)
                t = mqttWriteTopic..tNetCBus(tonumber(parts[1]))..'/'..parts[2]..'/'..parts[3]..'/'..act..'/press'
                if mqttJunk then client:publish(t, 'junk', mqttQoS, RETAIN) end -- Publish junk to topic to be deleted (some topics may not have been written yet)
                client:publish(t, '', mqttQoS, RETAIN)
                triggers[group][act] = nil
              end
              if remove then table.remove(v.trigger, remove) end
            end
          end
        end
      end
    end
  end
  for _, k in ipairs(kill) do mqttDevices[k] = nil end
end


--[[
Publish queued CBus discovery topics
--]]
local function outstandingPublish()
  local nClock = socket.gettime()
  local u
  local failed = 0
  for _, u in ipairs(unpublished) do
    if not addDiscover(tNetCBus(u.net), u.app, u.group, u.channel, u.tags, u.name) then failed = failed + 1 end
    local alias = u.net..'/'..u.app..'/'..u.group
    -- storage.set('pre'..alias, nil) -- Un-comment to clear out all previous values for testing
    -- Measurement application
    if u.app == 228 then
      local level = nil; pcall(function () level = GetCBusMeasurement(u.net, u.group, u.channel) end)
      if level ~= nil then publishMeasurement(tNetCBus(u.net), u.app, u.group, u.channel, level) end
    -- User parameters
    elseif u.app == 250 then publish(tNetCBus(u.net), u.app, u.group, GetUserParam(u.net, u.group))
    elseif u.app == 255 then
      local level = nil; pcall(function () level = GetUnitParameter(u.net, u.group, u.channel) end)
      if level ~= nil then publishUnitParam(tNetCBus(u.net), u.app, u.group, u.channel, level) end
    -- Trigger control
    elseif u.app == 202 then -- Do nothing
    -- Lighting and other
    else
      if not lightingButton[alias] then -- Do nothing for lighting buttons
        local level = nil; pcall(function () level = GetCBusLevel(u.net, u.app, u.group) end)
        if level ~= nil then publish(tNetCBus(u.net), u.app, u.group, level) end
      end
    end
  end
  if #unpublished > 0 then
    -- Ensure that newly tagged/removed groups with the MQTT keyword send updates
    if eventInstalled then if script.status(eventName) ~= nil then script.disable(eventName); script.enable(eventName) end end
    if finalInstalled then if script.status(finalName) ~= nil then script.disable(finalName); script.enable(finalName) end end
    logger('Published '..#unpublished - failed..' CBus discovery and current level topic'..(#unpublished - failed ~= 1 and 's' or '')..' in '..string.format('%.3f', socket.gettime()-nClock)..' seconds, event scripts restarted', FORCE)
    unpublished = {}
  end
end


--[[
Publish queued Airtopia topics
--]]
local function outstandingAtPublish()
  local nClock = socket.gettime()
  local u
  for _, u in ipairs(unpublishedAt) do addAtDiscover(u['name'], u['sa'], nil) end
  if #unpublishedAt > 0 then
    -- Ensure that newly tagged/removed groups with the AT keyword send updates
    if script.status('AT') ~= nil then script.disable('AT'); script.enable('AT') end
    logger('Published '..#unpublishedAt..' Airtopia discovery and current level topic'..(#unpublishedAt ~= 1 and 's' or '')..' in '..string.format('%.3f', socket.gettime()-nClock)..' seconds, event scripts restarted', FORCE)
    unpublishedAt = {}
  end
  publishAtState()
end


--[[
Publish the next queued messages for CBus
--]]
local function outstandingMqttMessage()
  local msg, k, v, device
  for _, msg in ipairs(mqttMessages) do
    local topic = msg.topic
    local payload = msg.payload

    local parts = string.split(topic, '/')

    -- Messages from CBus write topics
    if parts[1] == 'cbus' and parts[2] == 'write' then

      local net = tNetAC(tonumber(parts[3])); local app = tonumber(parts[4]); local group = tonumber(parts[5])
      local alias = net..'/'..app..'/'..group
      logger(topic..' to '..payload)

      local lastLevel = storage.get('lastlvl', {})

      if not parts[6] then
        logger('MQTT error: Invalid message format: '..topic, FORCE)

      elseif parts[6] == 'switch' then
        if payload == 'ON' then      SetCBusLevel(net, app, group, 255, 0); logger('Payload is ON for '..alias)
        elseif payload == 'OFF' then SetCBusLevel(net, app, group, 0, 0);   logger('Payload is OFF for '..alias)
        end
        
      elseif parts[6] == 'select' then
        SetCBusLevel(net, app, group, selects[alias][payload], 0); logger('Payload is '..payload..' ('..selects[alias][payload]..') for '..alias)

      elseif contains('press', parts[6]) and payload == 'PRESS' then -- Lighting group press
        PulseCBusLevel(net, app, group, 255, 0, 1, 0); logger('Payload is PRESS')

      elseif parts[7] ~= nil and contains('press', parts[7]) and payload == 'PRESS' then -- Trigger level press
        local level = triggers[group][parts[6]]
        if level ~= nil then
          SetTriggerLevel(group, level); logger('Payload is PRESS')
        else
          logger('Warning: MQTT trigger level received that is not published', FORCE)
        end
    
      elseif parts[6] == 'measurement' then SetCBusMeasurement(net, app, group, payload, 0)

      elseif parts[6] == 'ramp' then
        if payload == 'OPEN' then
          SetCBusLevel(net, app, group, 255, 0)
          goto next
        elseif payload == 'CLOSE' then
          SetCBusLevel(net, app, group, 0, 0)
          goto next
        elseif payload == 'STOP' then
          SetCBusLevel(net, app, group, 5, 0)
          goto next
        elseif payload == 'ON' then
          if fan[alias] then
            if lastLevel[alias] then
              payload = lastLevel[alias]; logger("Payload is fan ON, so using lastlevel instead")
            else
              payload = '255'; logger("Payload is fan ON, so using RAMP instead")
            end
          else
            logger('Payload for '..alias..' is ON')
            SetCBusLevel(net, app, group, 255, 0)
            goto next
          end
        end
        if payload == 'OFF' then
          logger('Payload for '..alias..' is OFF')
          SetCBusLevel(net, app, group, 0, 0)
        else -- Ramp
          parts = string.split(payload, ',')
          local lev = tonumber(parts[1])
          local num
          if lev ~= nil then num = math.floor(lev + 0.5) else logger('Warning: non-numeric CBus level for '..alias..', level='..parts[1], FORCE); num = nil end
          if num ~= nil and num < 256 then
            logger('Payload for '..alias..' is RAMP '..payload)
            local toSet = 0
            local ramp = 0
            if not fan[alias] then 
              if lastLevel[alias] then logger('Last level '..lastLevel[alias]) end
              if lastLevel[alias] and num == 255 then
                if blindKey and contains(blindKey, GetCBusGroupTag(net, app, group)) then
                  toSet = num; logger("Payload is 'Blind' ramp on, so ignoring lastlevel")
                else
                  toSet = lastLevel[alias]
                end
              else
                toSet = num
              end
            else
              logger("Payload is 'Fan' ramp, so ignoring lastlevel")
              toSet = num
            end
            if parts[2] ~= nil then ramp = tonumber(parts[2]) else ramp = 0 end
            SetCBusLevel(net, app, group, toSet, ramp)
          end
        end
      end

    -- Messages from AC board select/sensor topics
    elseif panasonicSupport and parts[2] == 'climate' or parts[2] == 'select' or parts[2] == 'sensor' then
      local sel = 'func'
      -- for loop finding items parts[2] or parts[3] matches a 'sense'... is topic important??? Prolly not...
      for _, a in pairs(ac) do
        if a.sense and (a.sense == parts[3] or a.sense == parts[4]) and a.topic == parts[2] then
          sel = 'sense'
          if a.sense == parts[3] then device = parts[1]..'-'..parts[3]..'-sense'
          elseif a.sense == parts[4] then device = parts[1]..'-'..parts[4]..'-sense' end
          break
        end
      end
      if parts[2] == 'select' then sel = 'sel' end
      if sel == 'func' then device = parts[1]..'-'..parts[4] elseif sel == 'select' then device = parts[1]..'-'..parts[3] end
      local net, app, group
      if acDevices[device] then
        local alias = acDevices[device]
        local p = string.split(alias, '/'); net = tonumber(p[1]); app = tonumber(p[2]); group = tonumber(p[3])
        if (sel == 'func' and parts[5] == 'state') or (sel == 'sel' and parts[4] == 'state') or sel == 'sense' then
          if ignoreCbus[alias] and socket.gettime() - ignoreCbus[alias] > ignoreTimeout then -- Don't worry about older 'ignore' flags
            ignoreCbus[alias] = nil
            logger('Ignoring older CBus ignore flag for '..alias)
          end
          if not ignoreCbus[alias] then -- Only set the CBus status/level if this script did not initiate the change, and if it is different to the current value
            local set = false
            if payload ~= nil then
              local extant = GetUserParam(net, group)
              local e = tonumber(extant)
              local p = tonumber(payload)
              if e ~= nil and p ~= nil then
                if string.format('%.3f', e) ~= string.format('%.3f', p) then SetUserParam(net, group, p); set = true end
              elseif p ~= nil then
                if e ~= string.format('%.3f', p) then SetUserParam(net, group, p); set = true end
              elseif e ~= nil then
                if string.format('%.3f', e) ~= payload then SetUserParam(net, group, payload); set = true end
              else
                if extant ~= payload then SetUserParam(net, group, payload); set = true end
              end
            else
              logger('Warning: nil payload for '..alias..', ignoring', FORCE)
            end
            -- Setting CBus here will result in the AC event script requesting publication of the state using publishAc() above.
            -- This is undesired, so ignoreMqtt[alias] is used to ensure that the CBus change received does not publish to MQTT.
            if set then
              ignoreMqtt[alias] = socket.gettime()
              -- logger('Setting ignoreMqtt for '..alias..', oldState='..extant..' payload='..payload)
            end
          else
            ignoreCbus[alias] = nil
            logger('Ignoring CBus publish for '..alias)
          end
          ac[alias].state = payload
        end
      end
    
    -- Messages from AT board cmd topics
    elseif airtopiaSupport and parts[1] == 'airtopia' and parts[3] == 'cmd' then
      device = parts[2]..'-'..parts[4]
      local net, app, group
      
      function pub(alias, payload) -- State publish to MQTT
        local parts = string.split(at[alias].name, '-')
        local board = parts[1]
        local topic = 'airtopia/'..board..'/state/'..parts[2]
        client:publish(topic, payload, mqttQoS, RETAIN)
      end

      if parts[4] == 'mode' then
        if atDevices[device] then
          alias = atDevices[device]
          local p = string.split(alias, '/'); net = tonumber(p[1]); app = tonumber(p[2]); group = tonumber(p[3])
          i = indexOf(atmodes, payload)
          if i ~= nil then
            local set = false
            local pwrgrp = tonumber(string.split(atBoards[parts[2]]['alias'], '/')[3]) -- Get the power user parameter
            local extant = GetUserParam(net, pwrgrp)
            local pld = nil
            if payload ~= 'off' then
              pub(alias, i)
              pub(atBoards[parts[2]]['alias'], 1) -- Power on
              if extant ~= 1 then set = true; pld = 1 end
            else
              pub(atBoards[parts[2]]['alias'], 0) -- Power off
              if extant ~= 0 then set = true; pld = 0 end
            end
            if set and pld ~= nil then
              -- Send to CBus, ensuring MQTT ignore is set...
              local alias = atBoards[parts[2]]['alias']
              ignoreMqtt[alias] = socket.gettime(); logger('Setting ignoreMqtt for '..alias..', oldState='..extant..' payload='..pld)
              SetUserParam(net, pwrgrp, pld)
            end
            -- publish to CBus
            local extant = GetUserParam(net, group)
            if i ~= extant and payload ~= 'off' then -- Set mode, but not if it is 'off'
              ignoreMqtt[alias] = socket.gettime(); logger('Setting ignoreMqtt for '..alias..', oldState='..extant..' payload='..payload)
              SetUserParam(net, group, i)
            end
          end
          -- Publish state to broker
          local parts = string.split(at[alias].name, '-')
          local board = parts[1]
          local topic = 'airtopia/'..board..'/state/modeha'
          client:publish(topic, payload, mqttQoS, RETAIN)
        end

      elseif parts[4] == 'swing' then
        local hswing = atDevices[parts[2]..'-horiz_swing']
        local vswing = atDevices[parts[2]..'-vert_swing']
        if hswing ~= nil and vswing ~= nil then
          local i, h, v
          local s = 0; for i, v in ipairs(atswings) do if v == payload then s = i - 1; break; end end -- Get the swing index
          h = bit.band(s, 1)
          v = bit.rshift(bit.band(s, 2), 1)
          local board = parts[2]
          local topic = 'airtopia/'..board..'/state/swingha'
          client:publish(topic, payload, mqttQoS, RETAIN)
          parts = string.split(hswing, '/'); SetUserParam(parts[1], parts[3], h)
          parts = string.split(vswing, '/'); SetUserParam(parts[1], parts[3], v)
        end
        
      elseif parts[4] == 'fan' then
        local fan = atDevices[parts[2]..'-fan']
        if fan ~= nil then
          local i, f
          local f = 0; for i, v in ipairs(atfans) do if v == payload then f = i - 1; break; end end -- Get the fan index
          local board = parts[2]
          local topic = 'airtopia/'..board..'/state/fanha'
          client:publish(topic, payload, mqttQoS, RETAIN)
          parts = string.split(fan, '/'); SetUserParam(parts[1], parts[3], f)
        end
        
      else -- Set target temp
        if atDevices[device] then
          alias = atDevices[device]
          local p = string.split(alias, '/'); net = tonumber(p[1]); app = tonumber(p[2]); group = tonumber(p[3])
          pub(alias, payload)
          -- publish to CBus
          local extant = GetUserParam(net, group)
          if payoad ~= extant then
            ignoreMqtt[alias] = socket.gettime(); logger('Setting ignoreMqtt for '..alias..', oldState='..extant..' payload='..payload)
            SetUserParam(net, group, payload)
          end
        end
      end
    elseif airtopiaSupport and parts[1] == 'airtopia' and parts[3] == 'state' then
      if indexOf(airtopiaStates, parts[4]) == nil then table.insert(airtopiaStates, parts[4]) end
    end
    
    -- Messages from ENV board sensor topics - simpler, only messages inbound
    if environmentSupport and parts[2] == 'sensor' and parts[4] == 'state' then
      device = parts[1]..'-'..parts[3]
      if envDevices[device] then
        parts = string.split(envDevices[device], '/')
        local net = parts[1]; local app = parts[2]; local group = parts[3]
        local alias = net..'/'..app..'/'..group
        local extant = GetUserParam(net, group)
        if type(extant) == 'number' then
          -- Deal with real number imprecision, assuming three decimal places for change detection
          if string.format('%.3f', extant) ~= string.format('%.3f', tonumber(payload)) then SetUserParam(net, group, payload) end
        else
          if extant ~= payload then SetUserParam(net, group, payload) end
        end
        env[alias].state = payload
      end
    end
    ::next::
  end
  mqttMessages = {}
end


--[[
Publish the next queued messages for MQTT
--]]
local function outstandingCbusMessage()
  local cmd
  local final = false

  local lastLevel = storage.get('lastlvl', {})
  for _, cmd in ipairs(cbusMessages) do
    if not legacyFirmware then
      -- Check for final levels
      if contains('>', cmd) then
        cmd = cmd:gsub('>', '/')
        final = true
      end
    end

    local parts = string.split(cmd, '/')
    local alias = parts[1]..'/'..parts[2]..'/'..parts[3]
    
    if panasonicSupport and ac[alias] then -- AC message to MQTT (no ramping involved for AC groups)
      publishAc(parts[1], parts[2], parts[3], parts[4], ac[alias].select)
    elseif airtopiaSupport and at[alias] then -- AT message to MQTT (no ramping involved for AT groups)
      publishAt(parts[1], parts[2], parts[3], parts[4])
    else -- CBus message to MQTT
      local net = tonumber(parts[1]); local app = tonumber(parts[2]); local group = tonumber(parts[3]);
      if app ~= 228
        then -- i.e. not measurement application
        local setting = true
        local payload = tonumber(parts[4]) -- Always a number for lighting app, but payload could be nil for user param at this point if a string
        if lighting[parts[2]] then -- Lighting application, so check for ramp
          if legacyFirmware then
            logger('Alias: '..alias..', payload: '..tostring(payload)..', ramp rate: '..tostring(GetCBusRampRate(net, app, group))..', target level: '..tostring(GetCBusTargetLevel(net, app, group)))
            -- A CBus ramp up and down can annoyingly begin with a zero level, then steadily converge to the target level. This initial
            -- zero should not be published to MQTT so it is ignored. If an initial zero is not seen then the ramp will be orphaned (and
            -- ultimately cleaned up/published, albeit a bit late after rampTimeout seconds).
            if not ramp[alias] then
              if GetCBusRampRate(net, app, group) > 0 then
                -- if lastLevel[alias] ~= GetCBusTargetLevel(net, app, group) or not lastLevel[alias] then
                  ramp[alias] = { ts=socket.gettime(), ramp=GetCBusRampRate(net, app, group), target=GetCBusTargetLevel(net, app, group) }
                -- end
                if payload == 0 then
                  setting = false
                  if ramp[alias] then logger('Set ramp for '..alias..' and suppress zero send') end
                else
                  if ramp[alias] then logger('Set ramp for '..alias) end
                end
              end
            else
              if ramp[alias].target ~= GetCBusTargetLevel(net, app, group) then -- Target level has changed so cancel ramp
                ramp[alias] = nil
                logger('Cancel ramp for '..alias)
                if payload == 0 and GetCBusRampRate(net, app, group) > 0 then setting = false end -- Ignore initial zero if ramp on
              end
            end
          end
        else -- Possibly a string payload for user parameter
          if payload == nil then
            payload = parts[4]
            local pt = 5 -- Accommodate an unlimited number of slashes in a string payload
            while parts[pt] ~= nil do
              payload = payload..'/'..parts[pt]
              pt = pt + 1
            end
          end
          -- Groups other than lighting are never ramped, so setting is always true
        end
        if setting then
          if legacyFirmware then
            if ramp[alias] then
              if final or payload == ramp[alias].target then
                ramp[alias] = nil
                logger('Clear ramp for '..alias)
                -- Only update MQTT at the end of a ramp, not during it (avoids HomeAssistant remembering an implausible level)
                publish(tNetCBus(net), app, group, payload)
                if app ~= 202 then -- Not trigger
                  local p = payload
                  if tonumber(payload) ~= nil then p = string.format('%.3f', payload) end
                  storage.set('pre'..alias, p) -- Save payload as 'previous' for use in the MQTT event-based script
                end
              end
            else
              publish(tNetCBus(net), app, group, payload)
              if app ~= 202 then -- Not trigger
                local p = payload
                if tonumber(payload) ~= nil then p = string.format('%.3f', payload) end
                storage.set('pre'..alias, p) -- Save payload as 'previous' for use in the MQTT event-based script
              end
            end
          else
            publish(tNetCBus(net), app, group, payload)
            if app ~= 202 then -- Not trigger
              local p = payload
              if tonumber(payload) ~= nil then p = string.format('%.3f', payload) end
              storage.set('pre'..alias, p) -- Save payload as 'previous' for use in the MQTT event-based script
            end
          end
        end
      else -- Special case for measurement app
        publishMeasurement(tNetCBus(tonumber(parts[1])), tonumber(parts[2]), tonumber(parts[3]), tonumber(parts[4]), tonumber(parts[5]))
        if tonumber(parts[5]) ~= nil then
          local p = string.format('%.3f', tonumber(parts[5]))
          storage.set('pre'..parts[1]..'/'..parts[2]..'/'..parts[3]..'/'..parts[4], p)
        end
      end
    end
  end
  cbusMessages = {}
end


--[[
Remove any orphaned ramp flags
--]]
local function checkRampOrphans()
  local k, v; local orphan = {}
  for k, v in pairs(ramp) do
    if socket.gettime() > v.ts + v.ramp + rampTimeout then
      -- Is an older ramp timestamp beyond ramp duration plus margin (should never occur, but does occasionally when set up for firmware < 1.15.0).
      -- Remove the orphan, and publish the final target, which will be zero.
      -- Will occur when a ramp to off does not begin with a zero level during the ramp, or if a ramp to zero starts when the group is already at zero.
      table.insert(orphan, k)
      local parts = string.split(k, '/')
      local net = tonumber(parts[1]); local app = tonumber(parts[2]); local group = tonumber(parts[3]);
      publish(tNetCBus(net), app, group, v.target)
      local p = v.target
      if tonumber(p) ~= nil then p = string.format('%.3f', p) end
      storage.set('pre'..k, p) -- Save payload as 'previous' for use in the MQTT event-based script
    end
  end
  for _, k in ipairs(orphan) do ramp[k] = nil; logger('Removing orphaned ramp for '..k) end
end


--[[
Duplicate discovery delete
--]]
local function dupDelete()
  -- If duplicate discovery topics are detected then remove them (discoveryDelete is set in broker ON_MESSAGE call-back)
  logger('Warning: Removing '..len(discoveryDelete)..' duplicate discovery topics', FORCE)
  local toDelete
  for toDelete, _ in pairs(discoveryDelete) do
    local parts = string.split(toDelete, '/')
    local oid = parts[1]
    local dType = parts[2]
    client:publish(mqttDiscoveryTopic..dType..'/'..oid..'/config', '', mqttQoS, RETAIN)
    logger('Removed discovery topic '..mqttDiscoveryTopic..dType..'/'..oid..'/config', FORCE)
  end
  discoveryDelete = {}
end


local function checkHeartbeat()
  if sendHeartbeat > 0 then
    local stat, err = pcall(function ()
      if socket.gettime() - heartbeat >= sendHeartbeat then
        heartbeat = socket.gettime(); require('socket').udp():sendto(_SCRIPTNAME..'+'..heartbeat, '127.0.0.1', 5433)
      end
    end)
    if not stat then
      logger('A fault occurred sending heartbeat. Restarting...', FORCE)
      pcall(function () server:close() end)
      return false
    else
      return true
    end
  end
  return True
end


--[[
Main loop
--]]

-- Create/update/delete functions spread evenly over the period 'trackChanges'
local cud = {
  { func = cudCBusTopics, init = false },
}
if panasonicSupport then table.insert(cud, { func = cudAc, init = true, script = 'AC' }) end
if environmentSupport then table.insert(cud, { func = cudEnv, init = true }) end
if airtopiaSupport then table.insert(cud, { func = cudAt, init = false, script = 'AT' }) end

local i, c
for i, c in ipairs(cud) do c.t = socket.gettime() - checkChanges * 1/#cud * i + checkChanges/#cud end -- Set the time to next discover for each function

-- Initial load of devices excluding CBus, suppressing MQTT re-subscribe
for _, c in ipairs(cud) do if c.init then c.func(true); if c.script and script.status(c.script) ~= nil then script.disable(c.script); script.enable(c.script) end end end

local function validateIncoming(cmd) -- Reject any weird socket messages received
  if contains('>', cmd) then
    local incoming = string.split(cmd, '>')
    local _, count = incoming[1]:gsub('/', ''); if count < 2 or count > 3 then return false end
    local parts = string.split(incoming[1], '/')
    local payload = incoming[2]
    local dstC, n
    if parts[2] and parts[2] == '228' then dstC = 4 else dstC = 3 end -- Measurement app is four dest parts, else three
    if payload == nil then return false end
    for i = 1,dstC,1 do n = tonumber(parts[i], 10); if n == nil then return false end end -- Test whether any dst parts are not whole decimal numbers
    return true
  else
    local _, count = cmd:gsub('/', ''); if count < 3 or count > 4 then return false end
    local parts = string.split(cmd, '/')
    local dstC, payload, n
    if parts[2] and parts[2] == '228' then dstC = 4; payload = parts[5] else dstC = 3; payload = parts[4] end -- Measurement app is four dest parts, else three
    if payload == nil then return false end
    for i = 1,dstC,1 do n = tonumber(parts[i], 10); if n == nil then return false end end -- Test whether any dst parts are not whole decimal numbers
    return true
  end
  return false
end


while true do
  -- Check for new messages from CBus. The entire socket buffer is collected each iteration for efficiency.
  local stat, err
  local more = false
  stat, err = pcall(function ()
    ::checkAgain::
    local cmd = nil
	  cmd = server:receive()
    if cmd and type(cmd) == 'string' then
      if validateIncoming(cmd) then
        cbusMessages[#cbusMessages + 1] = cmd -- Queue the new message
      else
        logger('Invalid command received: '..cmd, FORCE)
      end
      server:settimeout(0); more = true; goto checkAgain -- Immediately check for more buffered inbound messages to queue
    else
      if more then server:settimeout(socketTimeout) end
    end
  end)
  if not stat then logger('Socket receive error: '..err, FORCE) end

  -- Process MQTT message buffers synchronously - sends and receives
  client:loop(mqttTimeout)

  if mqttStatus == 1 then
    -- When connected to the broker
    if #mqttMessages > 0 then
      -- Send outstanding messages to CBus
      stat, err = pcall(outstandingMqttMessage)
      if not stat then logger('Error processing outstanding MQTT messages: '..err, FORCE); mqttMessages = {} end -- Log error and clear the queue
    end
    if #cbusMessages > 0 then
      -- Send outstanding messages to MQTT
      stat, err = pcall(outstandingCbusMessage)
      if not stat then logger('Error processing outstanding CBus messages: '..err, FORCE); cbusMessages = {} end -- Log error and clear the queue, continue
    end
    if #unpublished > 0 then
      -- Publish outstanding CBus discovery topics
      stat, err = pcall(outstandingPublish)
      if not stat then logger('Error publishing outstanding CBus discovery topics: '..err, FORCE); unpublished = {} end -- Log error and clear the queue, continue
    end
    if #unpublishedAt > 0 then
      -- Publish outstanding Airtopia discovery topics
      stat, err = pcall(outstandingAtPublish)
      if not stat then logger('Error publishing outstanding Airtopia discovery topics: '..err, FORCE); unpublishedAt = {} end -- Log error and clear the queue, continue
    end
    if len(ramp) > 0 then
      -- Some scenarios can create ramp orphans
      stat, err = pcall(checkRampOrphans)
      if not stat then logger('Error checking ramp orphans: '..err, FORCE) end -- Log and continue
    end
    if len(discoveryDelete) > 0 then
      -- A type has changed for existing topics, so clean up discovery for the old topics
      stat, err = pcall(dupDelete)
      if not stat then logger('Error processing delete discovery duplicates: '..err, FORCE); discoveryDelete = {} end -- Log error and clear the queue, continue
    end
    if checkForChanges then
      -- Periodically create/update/delete device items that change
      stat, err = pcall(function () for _, c in ipairs(cud) do if socket.gettime() - c.t >=checkChanges then c.t = socket.gettime(); c.func() end end end)
      if not stat then logger('Error checking create/update/delete: '..err, FORCE) end -- Log and continue
    end
  elseif mqttStatus == 2 or not mqttStatus then
    -- MQTT is disconnected, so attempt a connection, waiting. If fail to connect then retry.
    local warningTimeout = 60
    local timeout = 1
    local timeoutStart = socket.gettime()
    local connectStart = timeoutStart
    logger('Connecting to Mosquitto broker', FORCE)
    ::reconnect::
    stat, err = pcall(function (b, p, k) client:connect(b, p, k) end, mqttBroker, 1883, 25) -- Requested keep-alive 25 seconds, broker at port 1883
    if not stat then -- Log and abort
      logger('Error calling connect to broker: '..err, FORCE)
      pcall(function () server:close() end)
      do return end
    end
    while mqttStatus ~= 1 do
      client:loop(1) -- Service the client with a generous timeout
      if socket.gettime() - timeoutStart > warningTimeout then
        logger('Failed to connect to the Mosquitto broker, retrying continuously', FORCE)
        timeoutStart = socket.gettime()
      end
      checkHeartbeat()
      if socket.gettime() - connectStart > timeout then
        connectStart = socket.gettime()
        goto reconnect
      end
    end
    mqttConnected = socket.gettime()
    -- Subscribe to relevant topics
    client:subscribe(mqttWriteTopic..'#', mqttQoS)
    client:subscribe(mqttDiscoveryTopic..'#', mqttQoS)
    if panasonicSupport then for k, _ in pairs(acBoards) do client:subscribe(k..'/#', mqttQoS) end end
    if airtopiaSupport then for k, _ in pairs(atBoards) do client:subscribe('airtopia/'..k..'/#', mqttQoS) end end
    if environmentSupport then for k, _ in pairs(envBoards) do client:subscribe(k..'/#', mqttQoS) end end
    -- Connected... Now loop briefly to allow retained value retrieval for subscribed topics because synchronous
    while socket.gettime() - mqttConnected < 0.5 do client:loop(0) end
    -- Full publish CBus topics
    stat, err = pcall(publishCurrent)
    if not stat then logger('Error publishing current values: '..err, FORCE) end -- Log and continue
  else
    logger('Error: Invalid mqttStatus: '..mqttStatus, FORCE)
    pcall(function () server:close() end)
    do return end
  end

  --[[
  Send a heartbeat periodically to port 5433, listened to by the heartheat script.
  If execution is disrupted by any error or lockup then this script will be re-started.
  If sending the heartbeat faults, then the loop is exited, which will also re-start this
  script (it being resident/sleep zero).
  --]]
  if not checkHeartbeat() then do return end end
end