mqttBroker = '192.168.10.21' -- Obviously change to suit environment
mqttUsername = 'mqtt'
mqttPassword = 'password'
lighting = { ['56'] = true } -- Array of applications that are used for lighting (ramp detection only applies to lighting)
checkForChanges = true -- When true the script will periodically check for create/update/delete of object keywords (disable to lower CPU load)

--[[
Resident, zero sleep interval, name: 'MQTT send receive'

Manage CBus, Panasonic AC and environment events for MQTT, and publish discovery topics. Used
with Home Assistant.

>>> CBUS <-> MQTT

Lighting, measurement, user parameter and trigger applications are implemented.

Add the keyword 'MQTT' to groups for CBus discovery, plus...

  One of  light, fan, fan_pct, cover, select, sensor, switch, binary_sensor, bsensor or button, plus...  (default if not specified is 'light')
  Note that these device types are case sensitive. Other keywords are ignored.
  sa=     Suggested area
  img=    Image
  pn=     Preferred name (defaults to CBus tag, prepended to a trigger level tag for trigger control)
  class=  Device class to use in Home Assistant (User param/sensor only, see https://www.home-assistant.io/integrations/sensor/#device-class)
  dec=    Decimal places (User param/sensor only)
  unit=   Unit of measurement (User param/sensor only)
  scale=  Multiplier / divider (User param/sensor only)
  lvl=    List of applicable levels, separated by "-' (Trigger button and select only)
  on=     Alias for a 'bsensor' ON value (bsensor only)
  off=    Alias for a 'bsensor' OFF value (bsensor only)

Using lvl= for trigger control buttons is highly recommended. This will attempt to publish only certain levels, 
greatly improving discovery performance. If not specified the script will publish all levels having a tag.

Using lvl= for select is mandatory. This defines the selection name and its corresponding CBus level for the group.
There are three options for lvl=:
- Using the format: lvl=Option 1/0-Option 2/255, for any name and a level number
- The level numbers: lvl=0-255, which will use the level tag
- The level tags: lvl=Option 1-Option 2, which will look up the level number
If it is desirable to allow CBus levels other than the select levels to be set then alter the selectExact variable,
otherwise this script will force the level to be set to the nearest select level.

For trigger control buttons the preferred name is used as an optional prefix to the trigger level tag to name the
button. Button can be used for both lighting and trigger control, with lighting group buttons not getting a prefix.
Lighting group buttons operate by pulsing the CBus group for one second, acting as a bell press.

Keyword examples:

MQTT, light, sa=Outside, pn=Outside Laundry Door Light, img=mdi:lightbulb, 
MQTT, switch, sa=Bathroom 1, img=mdi:radiator, 
MQTT, fan, sa=Hutch, img=mdi:ceiling-fan, 
MQTT, cover, sa=Bathroom 2, img=mdi:blinds, 
MQTT, select, sa=Bathroom 2, img=mdi:blinds, lvl=0-137-255, 
MQTT, select, sa=Bathroom 2, img=mdi:blinds, lvl=Closed-Half open-Open, 
MQTT, select, sa=Bathroom 2, img=mdi:blinds, lvl=Closed/0-Half open/137-Open/255, 
MQTT, sensor, sa=Pool, pn=Pool Pool Temperature, unit= Â°C, dec=1, 
MQTT, sensor, sa=Pool, pn=Pool Level, unit= mm, dec=0, scale=1000, 
MQTT, button, lvl=0-1-2-5-127, pn=Inside,       (a trigger control group with various levels)
MQTT, bsensor, sa=Carport, on=Motion detected, off=No motion
MQTT, button, sa=Outside, img=mdi:gate-open,    (a lighting group button to open a gate)

>>> PANASONIC A/C

For Panasonic air conditioners connected to MQTT via ESPHome, add the keyword 'AC' to user parameters, plus...

  dev=   ESPHome device name, required, and one of:

  func=  Function (mode, target_temperature, fan_mode, swing_mode, which results in {dev}/climate/panasonic/{func}/#)
... or
  sel=   Select (vertical_swing_mode, horizontal_swing_mode, which results in {dev}/select/{sel}/#)
... or
  sense= A read only sensor like current_temperature, plus topic= (e.g. climate or sensor) with sensor as default

Mode strings = ("off", "heat", "cool", "heat_cool", "dry", "fan_only")
Horizontal swing mode strings = ("auto", "left", "left_center", "center", "right_center", "right")
Vertical swing mode strings = ("auto", "up", "up_center", "center", "down_center", "down")

Note: target_temperature and sensors are an integer user parameter, while all others are strings.
Note: Set all device names to 'Panasonic' in the 'climate' section, and make the 'esphome' name unique to
identify the devices (this is the 'dev' keyword').

Panasonic keyword examples:

AC, dev=storeac, func=mode, 
AC, dev=storeac, func=target_temperature
AC, dev=storeac, sel=vertical_swing_mode
AC, dev=storeac, sense=current_temperature, topic=climate
AC, dev=storeac, sense=outside_temperature

>>> AIRTOPIA A/C IR BLASTER

For Airtopia devices, add the keyword 'AT' to user parameters, plus...

  dev=   Airtopia device name (you choose, lowercase word, no spaces), required
  sa=    Suggested area (to at least one user parameter)
And one or more of:
  func=  Function (power, mode, vert_swing, horiz_swing, target_temperature, fan, which results in airtopia/{dev}/state/{func}/#, commands issued to airtopia/{dev}/cmd/{func}/#)
... or
  sense= A read only sensor like current_temperature, power_consumption, which results in airtopia/{dev}/state/{sense}/#)

Swing mode strings = ("off", "horiz_vert", "horiz_only", "vert_only")

>>> ENVIRONMENT SENSORS

Environment monitors can pass sensor data to CBus (using ESPHome devices). Add the 'ENV' keyword, plus...

  dev=  Device (the name of the ESPHome board)
  func= Function (the sensor name configured in ESPHome) defaults to the User Parameter name in lowercase,
        spaces replaced with underscore

Environment examples:

ENV, dev=outsideenv, func=outside humidity

https://github.com/autoSteve/acMqtt
--]]

--[[
General variables. Change as required, but probably no need to.
--]]
logging = false        -- Enable detailed logging
logms = false          -- Include timestamp in milliseconds for logs

checkChanges = 30      -- Interval in seconds to check for changes to object keywords
sendHeartbeat = 5      -- Send a heartbeat to the 'Heartbeat' script every n seconds (zero to disable heartbeat)
heartbeatConditions = { ['max'] = 20, } -- At most 20 seconds without a heartbeat or else restart
publishNoLevel = false -- For trigger app, whether to publish a level with no tag as "Level n" or raise an error in the log
selectExact = true     -- For select, if a CBus level other than in the select levels is set then adjust the CBus level to the closest select level
mqttClientId = 'nac'   -- #ditchunderscoresinvariablenames ... wherever practical please! Be kind to others, and your fingers typing...
mqttQoS = 2            -- Quality of service for MQTT messages: 0 = only once, 1 = at least once, 2 = exactly once
mqttJunk = true        -- Whether to publish junk before a blank publish message when removing topics (probably not necessary, but cleans up MQTT Explorer view)
blindKey = nil         -- If blind fully open is desirable instead of lastlevel, then change to a string contained in every blind object (e.g. 'Blind'), case sensitive

--[[
Timing variables. Adjust to taste if you know what you're doing. These provide a good compromise, but your deployment may vary.
--]]
rampTimeout = 5        -- Time beyond ramp to declare a ramp orphan in seconds
socketTimeout = 0.05   -- Lower = higher CPU, but better responsiveness (0 .05 = 1/20th of a second or 50ms, 0.005 = 5ms)
mqttTimeout = 0        -- In milliseconds, go with zero unless you know what you're doing
ignoreTimeout = 2      -- Timeout for stale MQTT ignore messages in seconds (two seconds is a long time...)

--[[
Topic prefixes for read/write/publish. The mqttDiscovery topic is recommended to be set to 'homeassistant/'
for use with HA, which is the default there. The MQTT CBus topics can be whatever you want, as discovery/subscribe
adjusts. All topic prefixes must end in '/'.
--]]
mqttCbus = 'cbus/'
mqttReadTopic = mqttCbus..'read/'
mqttWriteTopic = mqttCbus..'write/'
mqttDiscoveryTopic = 'homeassistant/'

--[[
Variables not to be messed with unless you definitely know what you're doing.
--]]
discovery = {}         -- MQTT discovery topics lookup
discoveryDelete = {}   -- If duplicate discovery topics are detected on startup then they will be removed
atDiscovery = {}       -- AT discovery topics lookup
atDiscoveryDelete = {} -- If duplicate discovery topics are detected on startup then they will be removed
mqttDevices = {}       -- CBus groups to send MQTT topics for
ac = {}                -- AC device details
acDevices = {}         -- Quick lookup to determine whether an object is an AC device
acBoards = {}          -- All physical AC boards (esp32)
at = {}                -- AT device details
atDevices = {}         -- Quick lookup to determine whether an object is an AT device
atBoards = {}          -- All physical AT boards
atArea = {}            -- Suggested area for AT boards
env = {}               -- Environment device details
envDevices = {}        -- Quick lookup to determine whether an object is an environment device
envBoards = {}         -- All physical environment boards (esp32)
cbusMessages = {}      -- Message queue
mqttMessages = {}      -- Message queue
ignoreCbus = {}        -- To prevent message loops
ignoreMqtt = {}        -- To prevent message loops
ramp = {}              -- Keeps track of ramping to ignore some zero level MQTT publish events outstandingCbusMessage()
triggers = {}          -- Trigger groups and their levels
selects = {}           -- Select groups and their options/levels
cover = {}             -- Quick lookup to determine whether an object is a cover (blind)
fan = {}               -- Quick lookup to determine whether an object is a fan (sweep fan)
bSensor = {}           -- Quick lookup to determine whether an object is a bsensor (a regular lighting group acting as status)
binarySensor = {}      -- Quick lookup to determine whether an object is a binary sensor
lightingButton = {}    -- Quick lookup to determine whether an object is a lighting group as a button
userParameter = {}     -- Quick lookup to determine whether an object is a user parameter
publishAdj = {}        -- For user parameters, holds scale and decimals to apply
unpublished = {}       -- The current set of CBus objects to publish discovery topics for
unpublishedAt = {}     -- The current set of CBus Airtopia objects to publish discovery topics for
mqttStatus = 2         -- Initially disconnected 1=connected, 2=disconnected
mqttConnected = 0      -- Timestamp of MQTT connection, initially zero which will cause an immediate connection

atmodes = {'auto', 'cool', 'heat', 'fan_only', 'dry', 'off'} -- Airtopia modes
atswings = {'Off', 'Horizontal only', 'Vertical only', 'Horizontal and Vertical'} -- Airtopia swing modes
atfans = {'Auto', '1', '2', '3', '4'} -- Airtopia fan speed (THIS IS UNTESTED, will result in 0, 1, 2, 3, 4 being set in user parameter in the order of the list)

RETAIN = true          -- Boolean aliases for MQTT retain and no-retain settings
NORETAIN = false

heartbeat = os.time()

function contains(prefix, text) local pos = text:find(prefix, 1, true); if pos then return pos >= 1 else return false end end
function trim(s) return s:match "^%s*(.-)%s*$" end -- Remove leading and trailing spaces
function tNetCBus(net) if net == 0 then return 254 else return net end end -- Translate AC network numbering to CBus
function tNetAC(net) if net == 254 then return 0 else return net end end -- Translate CBus network numbering to AC
started = socket.gettime(); function logger(msg) if logms then ts = string.format('%.3f ', socket.gettime()-started) else ts = '' end log(ts..msg) end -- Log helper
function len(dict) local i = 0; local k; for k, _ in pairs(dict) do i = i + 1 end return(i) end -- Get dictionary members
function indexOf(array, value) for i, v in ipairs(array) do if v == value then return i end end return nil end
function copy(obj, seen)
  if type(obj) ~= 'table' then return obj end
  if seen and seen[obj] then return seen[obj] end
  local s = seen or {}
  local res = setmetatable({}, getmetatable(obj))
  s[obj] = res
  for k, v in pairs(obj) do res[copy(k, s)] = copy(v, s) end
  return res
end

--[[
Register with the Heartbeat script
--]]
function isRegistered() hbeat = storage.get('heartbeat', {}) for k, _ in pairs(hbeat) do if k == _SCRIPTNAME then return true, hbeat end end return false, hbeat end
if sendHeartbeat > 0 then
  -- Check whether registration is required, and if not registered then do so
  local r, hbeat = isRegistered()
  if not r then
    if logging then log('Registering '.._SCRIPTNAME..' with Heartbeat') end
    hbeat[_SCRIPTNAME] = heartbeatConditions
    storage.set('heartbeat', hbeat)
  end
else
  local r, hbeat = isRegistered() if r then hbeat[_SCRIPTNAME] = nil storage.set('heartbeat', hbeat) end
end

--[[
UDP listener - receive messages from the event scripts 'MQTT' and 'AC'
--]]

if server then server:close() end  -- Handle script re-entry
server = require('socket').udp()
server:settimeout(socketTimeout)
server:setsockname('127.0.0.1', 5432) -- Listen on port 5432 for CBus changes

--[[
Mosquitto client and call-backs
--]]

mqtt = require('mosquitto')
client = mqtt.new(mqttClientId)
client:will_set(mqttCbus..'status', 'offline', mqttQoS, RETAIN)
if mqttUsername then client:login_set(mqttUsername, mqttPassword) end

client.ON_CONNECT = function(success)
  if success then
    logger('MQTT connected')
    client:publish(mqttCbus..'status', 'online', mqttQoS, RETAIN)
    mqttStatus = 1
    -- Subscribe to relevant topics
    client:subscribe(mqttWriteTopic..'#', mqttQoS)
    client:subscribe(mqttDiscoveryTopic..'#', mqttQoS)
    for k, _ in pairs(acBoards) do client:subscribe(k..'/#', mqttQoS) end
    for k, _ in pairs(atBoards) do client:subscribe('airtopia/'..k..'/#', mqttQoS) end
    for k, _ in pairs(envBoards) do client:subscribe(k..'/#', mqttQoS) end
  end
end

client.ON_DISCONNECT = function(...)
  logger('MQTT disconnected')
  mqttStatus = 2
end

client.ON_MESSAGE = function(mid, topic, payload)
  -- Record discovery topics to check for duplication
  local parts = string.split(topic, '/')
  if parts[1] == string.split(mqttDiscoveryTopic, '/')[1] then
    if discovery[parts[3]] ~= nil then
      if discovery[parts[3]] ~= parts[2] then
        discoveryDelete[parts[3]..'/'..parts[2]] = true
      else
        discovery[parts[3]] = parts[2] -- Dictionary of CBus addresses with type as the value
      end
    end
  else
    mqttMessages[#mqttMessages + 1] = { topic=topic, payload=payload } -- Queue the MQTT message
  end
end


--[[
Publish lighting group and user parameter objects to MQTT 
--]]
function publish(net, app, group, level)
  if level == nil then logger('Warning: Nil CBus level for '..net..'/'..app..'/'..group); do return end end
  local alias = net..'/'..app..'/'..group
  local aAlias = tNetAC(net)..'/'..app..'/'..group
  local state = ''
  if cover[alias] then
    state = 'stopped' -- For CBus blind controllers
  else
    state = (tonumber(level) ~= 0) and 'ON' or 'OFF'
  end
  if not userParameter[alias] then
    if not binarySensor[aAlias] then
      if bSensor[aAlias] then
        client:publish(mqttReadTopic..alias..'/state', level, mqttQoS, RETAIN)
        if logging then logger('Publishing state '..mqttReadTopic..alias..' to '..level) end
      elseif selects[aAlias] then
        local l
        for _, l in ipairs(selects[aAlias].allLvl) do
          if tonumber(level) <= l.lvl then
            if selectExact and tonumber(level) ~= l.lvl then
              -- Current CBus level does not match the select, so optionally adjust the CBus level
              SetCBusLevel(tNetAC(net), app, group, l.lvl, 0)
              -- Adjusting the level will result in two MQTT publish events, which could be avoided but is not
            end
            client:publish(mqttReadTopic..alias..'/select', l.sel, mqttQoS, RETAIN)
            if logging then logger('Publishing select '..mqttReadTopic..alias..' to '..l.sel..'('..l.lvl..')') end
            break
          end
        end
      else
        client:publish(mqttReadTopic..alias..'/state', state, mqttQoS, RETAIN)
        client:publish(mqttReadTopic..alias..'/level', level, mqttQoS, RETAIN)
        if logging then logger('Publishing state and level '..mqttReadTopic..alias..' to '..state..'/'..level) end
      end
    else
      client:publish(mqttReadTopic..alias..'/state', state, mqttQoS, RETAIN)
      if logging then logger('Publishing state '..mqttReadTopic..alias..' to '..state) end
    end
  else
    local adjust = publishAdj[alias]
    if adjust then v = tonumber(string.format('%.'..adjust.dec..'f', level * adjust.scale)) else v = level end
    client:publish(mqttReadTopic..alias..'/state', v, mqttQoS, RETAIN)
    if logging then logger('Publishing value '..mqttReadTopic..alias..' to '..v) end
  end
end

--[[
Publish measurement application objects to MQTT 
--]]
function publishMeasurement(net, app, group, channel, value)
  local units, v
  if value == nil then logger('Warning: Nil CBus measurement value for '..net..'/'..app..'/'..group); do return end end
  local adjust = publishAdj[net..'/'..app..'/'..group..'/'..channel]
  if adjust then v = tonumber(string.format('%.'..adjust.dec..'f', value * adjust.scale)) else v = value end
  _, units = GetCBusMeasurement(net, group, channel)
  if units == '$' then
    v = units..tostring(v)
  elseif units == '%' then
    v = v..units
  else
    v = v..' '..units
  end
  client:publish(mqttReadTopic..net..'/'..app..'/'..group..'_'..channel..'/state', v, mqttQoS, RETAIN)
  -- if logging then logger('Publishing measurement '..mqttReadTopic..net..'/'..app..'/'..group..'_'..channel..' to '..v) end
end

--[[
Publish AC objects to MQTT 
--]]
function publishAc(net, app, group, level, select)
  if level == nil then logger('Warning: Nil AC level for '..net..'/'..app..'/'..group); do return end end
  local alias = net..'/'..app..'/'..group
  if ac[alias].state ~= level then
    if ignoreMqtt[alias] and (os.time() - ignoreMqtt[alias] > ignoreTimeout) then -- Don't worry about older 'ignore' flags
      ignoreMqtt[alias] = nil
      if logging then logger('Ignoring older MQTT ignore flag for '..alias) end
    end
    if not ignoreMqtt[alias] then
      local parts = string.split(ac[alias].name, '-')
      local board = parts[1]
      local topic = ''
      if select == 'func' then
        topic = board..'/climate/panasonic/'..parts[2]..'/command'
      elseif select == 'sel' then
        topic = board..'/select/'..parts[2]..'/command'
      elseif select == 'sense' then
        if logging then logger('Warning: Not publishing sensor change for alias='..alias) end
      else
        logger('Invalid AC command for alias='..alias..', select='..tostring(select))
      end
      if topic ~= '' then client:publish(topic, level, mqttQoS, NORETAIN) end
      -- Publishing to MQTT here will result in outstandingMqttMessage() below setting the CBus state for the group.
      -- This is undesired, so ignoreCbus[alias] is used to ensure that the MQTT change received does not set CBus.
      if acState ~= ac[alias].state then ignoreCbus[alias] = os.time() end
      if logging then logger('Published AC '..ac[alias].name..' to '..level) end
    else
      ignoreMqtt[alias] = nil
      if logging then logger('Ignoring MQTT publish for '..alias) end
    end
    ac[alias].state = level
  else
    ignoreMqtt[alias] = nil
    if logging then logger('Ignoring MQTT publish for '..alias) end
  end
end

--[[
Publish AT objects to MQTT 
--]]
function publishAt(net, app, group, level)
  if level == nil then logger('Warning: Nil AT level for '..net..'/'..app..'/'..group); do return end end
  local alias = net..'/'..app..'/'..group
  if at[alias].state ~= level then
    if ignoreMqtt[alias] and (os.time() - ignoreMqtt[alias] > ignoreTimeout) then -- Don't worry about older 'ignore' flags
      ignoreMqtt[alias] = nil
      if logging then logger('Ignoring older MQTT ignore flag for '..alias) end
    end
    if not ignoreMqtt[alias] then
      local parts = string.split(at[alias].name, '-')
      local board = parts[1]
      local topic = 'airtopia/'..board..'/state/'..parts[2]
      local adjust = publishAdj[alias]
      if adjust then level = tonumber(string.format('%.'..adjust.dec..'f', level * adjust.scale)) end
      client:publish(topic, level, mqttQoS, RETAIN)
      -- Publishing to MQTT here will result in outstandingMqttMessage() below setting the CBus state for the group.
      -- This is undesired, so ignoreCbus[alias] is used to ensure that the MQTT change received does not set CBus.
      if atState ~= at[alias].state then ignoreCbus[alias] = os.time() end
      if logging then logger('Published AT '..at[alias].name..' to '..level) end
      -- Determine whether a HomeAssistant state topic needs to be also published
      local st = nil
      local prefix = nil
      local dev = nil
      for k, v in pairs(atDevices) do
        if v == alias then prefix = string.split(k, '-')[1]; st = string.split(k, '-')[2]; break end
      end
      if st == nil then
      elseif st == 'horiz_swing' then
        -- Publish swingha
        local o = atDevices[prefix..'-vert_swing']
        if o ~= nil then
          parts = string.split(o, '/'); net = parts[1]; group = parts[3]; 
          local v = bit.lshift(GetUserParam(net, group), 1)
          local topic = 'airtopia/'..prefix..'/state/swingha'
          local s = bit.bor(tonumber(level), v) + 1
          client:publish(topic, atswings[s], mqttQoS, RETAIN)
        end
      elseif st == 'vert_swing' then
        -- Publish swingha
        local o = atDevices[prefix..'-horiz_swing']
        if o ~= nil then
          parts = string.split(o, '/'); net = parts[1]; group = parts[3]; 
          local h = GetUserParam(net, group)
          local topic = 'airtopia/'..prefix..'/state/swingha'
          local v = bit.lshift(tonumber(level), 1)
          local s = bit.bor(h, v) + 1
          client:publish(topic, atswings[s], mqttQoS, RETAIN)
        end
      elseif st == 'fan' then
        -- Publish fanha
        local fanv = atfans[level+1]
        local topic = 'airtopia/'..board..'/state/fanha'
        client:publish(topic, fanv, mqttQoS, RETAIN)
      end
    else
      ignoreMqtt[alias] = nil
      if logging then logger('Ignoring MQTT publish for '..alias) end
    end
    at[alias].state = level
  else
    ignoreMqtt[alias] = nil
    if logging then logger('Ignoring MQTT publish for '..alias) end
  end
end


--[[
Build and publish a MQTT discovery topic
--]]
function addDiscover(net, app, group, channel, tags, name)
  local allow = {'light', 'fan', 'fan_pct', 'cover', 'select', 'sensor', 'switch', 'binary_sensor', 'bsensor', 'button'}
  local function allowed(val) local v; for _, v in ipairs(allow) do if v == val then return true end end return false end
  if not name then if channel == nil then do return end else name = 'measurement' end end -- Need a name from tag lookup for everything but measurement app
  local pn = name
  -- All other keywords except MQTT are optional (some exceptions), with 'light' as default discovery type. Defaults:
  local sa = ''         -- Suggested area
  local img = ''        -- Image
  local units = ''      -- Units
  local class = ''      -- HA class
  local scale = 1       -- Scale (multiplier or divider)
  local decimals = 2    -- Decimal places
  local on = 'On'       -- bsensor 'on' string
  local off = 'Off'     -- bsensor 'off' string
  local levels = {}     -- Assume lvl= keyword is blank
  local dType = 'light' -- Use light as default HA type if not specified
  
  local lvl = false
  
  -- Build an alias to refer to each group
  alias = tNetAC(net)..'/'..app..'/'..group;  if channel ~= nil then alias = alias..'/'..channel end

  -- Extract MQTT topic settings
  for _, t in ipairs(tags) do
    tp = string.split(t, '=')
    tp[1] = trim(tp[1])
    if tp[2] then
      tp[2] = trim(tp[2])
      if tp[1] == 'sa' then sa = tp[2]
      elseif tp[1] == 'pn' then pn = tp[2]
      elseif tp[1] == 'img' then img = tp[2]
      elseif tp[1] == 'unit' then units = tp[2]
      elseif tp[1] == 'class' then class = tp[2]
      elseif tp[1] == 'dec' then decimals = tonumber(tp[2])
      elseif tp[1] == 'scale' then scale = tonumber(tp[2])
      elseif tp[1] == 'on' then on = tp[2]
      elseif tp[1] == 'off' then off = tp[2]
      elseif tp[1] == 'lvl' then levels = string.split(tp[2], '-'); lvl = true
      end
    else
      if allowed(tp[1]) then dType = tp[1] end
    end
    -- Any other unrecognised keywords that may be set are ignored
  end
  
  if dtype == 'light' and app == 228 then dtype = 'sensor' end -- Measurement app sensor with incorrect/missing type
  
  if logging then
    if sa == '' then dSa = 'no preferred area' else dSa = sa end
    if dType ~= 'bsensor' then
    	logger('Publish discovery '..name..' as '..dType..':'..pn..' in area '..dSa)
    else
    	logger('Publish discovery '..name..' as sensor:'..pn..' in area '..dSa)
    end
  end

  -- Build an OID (measurement application gets a channel as well), also add to mqttDevices
  oid = 'cbus_mqtt_'..net..'_'.. app..'_'..group; if channel ~= nil then oid = oid..'_'..channel end;
  mqttDevices[alias].oid = oid
  if dType ~= 'bsensor' then
    mqttDevices[alias].type = dType
  else
    mqttDevices[alias].type = 'sensor'
  end
  aAlias = alias -- Automation controller numbered networks
  alias = net..'/'..app..'/'..group -- Will adjust for CBus numbered networks

  -- Build the type-specific payload to publish
  if dType == 'light' then
    payload = {
      stat_t = mqttReadTopic..alias..'/state',
      cmd_t = mqttWriteTopic..alias..'/switch',
      bri_stat_t = mqttReadTopic..alias..'/level',
      bri_cmd_t = mqttWriteTopic..alias..'/ramp',
      pl_off = 'OFF',
      on_cmd_type = 'brightness',
    }

  elseif dType == 'switch' then
    payload = {
      stat_t = mqttReadTopic..alias..'/state',
      cmd_t = mqttWriteTopic..alias..'/switch',
      pl_on = 'ON',
      pl_off = 'OFF',
    }

  elseif dType == 'fan' then
    payload = {
      stat_t = mqttReadTopic..alias..'/state',
      cmd_t = mqttWriteTopic..alias..'/ramp',
      pl_on = 'ON',
      pl_off = 'OFF',
      pr_mode_cmd_t = mqttWriteTopic..alias..'/ramp',
      pr_mode_cmd_tpl = '{% if value == "low" %} 86 {% elif value == "medium" %} 170 {% elif value == "high" %} 255 {% endif %}',
      pr_mode_stat_t = mqttReadTopic..alias..'/level',
      pr_mode_val_tpl = '{% if value == 0 %} OFF {% elif value == 86 %} low {% elif value == 170 %} medium {% elif value == 255 %} high {% endif %}',
      pr_modes = {'low', 'medium', 'high'}
    }
    fan[aAlias] = true

  elseif dType == 'fan_pct' then
    payload = {
      stat_t = mqttReadTopic..alias..'/state',
      cmd_t = mqttWriteTopic..alias..'/switch',
      pl_on = 'ON',
      pl_off = 'OFF',
      pct_cmd_t = mqttWriteTopic..alias..'/ramp',
      pct_stat_t = mqttReadTopic..alias..'/level',
      opt = true,
    }
    dType = 'fan'
    fan[aAlias] = true

  elseif dType == 'cover' then
    payload = {
      stat_t = mqttReadTopic..alias..'/state',
      cmd_t = mqttWriteTopic..alias..'/ramp',
      pos_open = 255,
      pos_clsd = 0,
      pl_open = 'OPEN',
      pl_cls = 'CLOSE',
      pos_t = mqttReadTopic..alias..'/level',
      set_pos_t = mqttWriteTopic..alias..'/ramp',
    }
    cover[alias] = true

  elseif dType == 'select' then
    if not lvl then
      logger('Error: lvl= keyword not specified for select at '..aAlias)
      do return end
    end
    local level, parts
    local options = {}
    selects[aAlias] = {}
    for _, level in ipairs(levels) do
      local parts = string.split(level, '/')
      if #parts == 2 then -- A select option and level
        options[#options + 1] = parts[1]
        selects[aAlias][parts[1]] = tonumber(parts[2])
      elseif #parts == 1 and tonumber(parts[1]) then -- Level numbers only
        parts[2] = parts[1]
        parts[1] = GetCBusLevelTag(tNetAC(net), app, group, tonumber(parts[2]))
        if not parts[1] then
          logger('Error: No level tag for select '..aAlias..', level '..parts[2])
          do return end
        end
        options[#options + 1] = parts[1]
        selects[aAlias][parts[1]] = tonumber(parts[2])
      elseif #parts == 1 then -- Level tags only
        parts[2] = GetCBusLevelAddress(tNetAC(net), app, group, parts[1])
        if not parts[2] then
          logger('Error: Invalid level tag for select '..aAlias..', level '..parts[1])
          do return end
        end
        options[#options + 1] = parts[1]
        selects[aAlias][parts[1]] = tonumber(parts[2])
      else
        logger('Error: Invalid lvl= format for select '..aAlias)
        do return end
      end
      if not selects[aAlias].allLvl then selects[aAlias].allLvl = {} end; selects[aAlias].allLvl[#selects[aAlias].allLvl + 1] = { lvl = tonumber(parts[2]), sel = parts[1] }
    end
    table.sort(selects[aAlias].allLvl, function (left, right) return left.lvl < right.lvl end)
    payload = {
      stat_t = mqttReadTopic..alias..'/select',
      cmd_t = mqttWriteTopic..alias..'/select',
      options = options,
    }

  elseif dType == 'sensor' then
    if channel ~= nil then
      payload = { stat_t = mqttReadTopic..alias..'_'..channel..'/state', }
      alias = alias..'/'..channel
    else
      payload = { stat_t = mqttReadTopic..alias..'/state', }
    end
    if class ~= '' then payload.dev_cla = class end
    if app == 250 then userParameter[alias] = true end
    if decimals ~= 2 or scale ~= 1 then publishAdj[alias] = { dec = decimals, scale = scale } end -- Scale, decimals and units only for sensors
    if units ~= '' then payload.unit_of_meas = units end

  elseif dType == 'bsensor' then
    dType = 'sensor'
    payload = {
      stat_t = mqttReadTopic..alias..'/state',
      val_tpl = '{% if value | float == 0 %} '..off..' {% else %} '..on..' {% endif %}',
    }
    bSensor[aAlias] = true

  elseif dType == 'binary_sensor' then
    payload = {
      stat_t = mqttReadTopic..alias..'/state',
      pl_on = 'ON',
      pl_off = 'OFF',
    }
    binarySensor[aAlias] = true

  elseif dType == 'button' and app == 202 then
    local i
    mqttDevices[aAlias].trigger = {}
    if #levels == 0 then for i = 0,255 do levels[#levels + 1] = i end end -- If no "lvl=" specified then scan all levels
    for _, i in ipairs(levels) do 
      tag = GetCBusLevelTag(tNetAC(net), 202, group, tonumber(i))
      if not tag then
        if publishNoLevel then
          if lvl then
            tag = 'Level '..i
            logger('Warning: Trigger '..alias..' has no level tag defined for level '..i..', setting to "'..tag..'"')
          end
        else
          if lvl then logger('Error: Trigger '..alias..' has no level tag defined for level '..i) end
        end
      end
      if tag then
        boid = oid..'_'..i
        action = tag:gsub("%s+", "_"):lower()
        if triggers[group] == nil then triggers[group] = {} end
        triggers[group][action] = tonumber(i)
        if pn == name then prefix = '' else prefix = pn..' ' end
        local entity = prefix..tag
        local startIdx, endIdx
        repeat
          startIdx, endIdx = entity:find(sa, 1, true)
          if startIdx and startIdx == 1 then
            entity = entity:sub(endIdx + 1):match'^%s*(.*)'
          end
        until not startIdx or startIdx > 1
        payload = {
          name = '',
          obj_id = boid,
          uniq_id = boid,
          cmd_t = mqttWriteTopic..alias..'/'..action..'/press',
          dev = { name=entity, ids=sa..' '..entity, sa=sa, mf='Schneider Electric', mdl='CBus' },
        }
        if img ~= '' then payload.ic = img end
        -- If dType has changed for an existing discovery topic then remove the previous topic
        if discovery[boid] ~= nil and discovery[boid] ~= dType then
          client:publish(mqttDiscoveryTopic..discovery[boid]..'/'..boid..'/config', '', mqttQoS, RETAIN)
        end
        -- Publish to MQTT broker
        local j = json.encode(payload)
        client:publish(mqttDiscoveryTopic..dType..'/'..boid..'/config', j, mqttQoS, RETAIN)
        table.insert(mqttDevices[aAlias].trigger, boid)
      end
    end
    do return end

  elseif dType == 'button' and lighting[tostring(app)] then
    -- Lighting group button
    payload = {
      cmd_t = mqttWriteTopic..alias..'/press',
    }
    lightingButton[aAlias] = true

  elseif dType == 'button' then
    logger('Error: MQTT button keyword used for unsupported application group '..aAlias)
    do return end
  end

  -- Add payload common to all
  local entity = pn
  local startIdx, endIdx
  repeat
    startIdx, endIdx = entity:find(sa, 1, true)
    if startIdx and startIdx == 1 then
      entity = entity:sub(endIdx + 1):match'^%s*(.*)'
    end
  until not startIdx or startIdx > 1
  payload.name = ''
  payload.obj_id = oid
  payload.uniq_id = oid
  payload.avty_t = mqttCbus..'status'
  payload.dev = { name=entity, ids=sa..' '..entity, sa=sa, mf='Schneider Electric', mdl='CBus' }
  if img ~= '' then payload.ic = img end

  -- If dType has changed for an existing discovery topic then remove the previous topic
  if discovery[oid] ~= nil and discovery[oid] ~= dType then
    client:publish(mqttDiscoveryTopic..discovery[oid]..'/'..oid..'/config', '', mqttQoS, RETAIN)
  end

  -- Publish to MQTT broker
  discovery[oid] = dType
  local j = json.encode(payload)
  client:publish(mqttDiscoveryTopic..dType..'/'..oid..'/config', j, mqttQoS, RETAIN)
end

--[[
Build and publish an AT discovery topic
--]]
function addAtDiscover(name, sa, unit)
  if logging then
    if sa == '' then dSa = 'no preferred area' else dSa = sa end
    logger('Publish discovery '..name..' in area '..dSa)
  end
  if unit == nil then unit = 'A' end

  -- Build an OID and name prefix
  local sao = ''; if sa ~= '' then sao = string.lower(sa:gsub("% ", "_"))..'_' end
  local oid = 'cbus_mqtt_'..sao..string.lower(name:gsub("% ", "_"))

  payload = {
    name = '',
    obj_id = oid,
    uniq_id = oid,
    avty_t = mqttCbus..'status',
    dev = { name=name, ids=sa..' '..name, sa=sa, mf='Schneider Electric', mdl='Airtopia' },
    mode_cmd_t = 'airtopia/'..sao..name..'/cmd/mode',
    mode_stat_t = 'airtopia/'..sao..name..'/state/modeha',
    pow_cmd_t = 'airtopia/'..sao..name..'/cmd/power',
    temp_cmd_t = 'airtopia/'..sao..name..'/cmd/target_temperature',
    temp_stat_t = 'airtopia/'..sao..name..'/state/target_temperature',
    curr_temp_t = 'airtopia/'..sao..name..'/state/current_temperature',
    swing_modes = atswings,
    swing_mode_cmd_t = 'airtopia/'..sao..name..'/cmd/swing',
    swing_mode_stat_t = 'airtopia/'..sao..name..'/state/swingha',
    fan_modes = atfans,
    fan_mode_cmd_t = 'airtopia/'..sao..name..'/cmd/fan',
    fan_mode_stat_t = 'airtopia/'..sao..name..'/state/fanha',
    temp_unit = "C",
    opt = false,
    pl_on = 'ON',
    pl_off = 'OFF',
    precision = 1.0,
  }

  -- Publish to MQTT broker
  local j = json.encode(payload)
  client:publish(mqttDiscoveryTopic..'climate/'..oid..'/config', j, mqttQoS, RETAIN)

  -- Add a power consumption sensor discovery topic
  payload = {
    name = '',
    obj_id = oid..'_power',
    uniq_id = oid..'_power',
    avty_t = mqttCbus..'status',
    dev = { name=name..' Power Consumption', ids=sa..' '..name..' Power Consumption', sa=sa, mf='Schneider Electric', mdl='Airtopia' },
    stat_t = 'airtopia/'..sao..name..'/state/power_consumption',
    unit_of_meas = unit,
  }
  local j = json.encode(payload)
  client:publish(mqttDiscoveryTopic..'sensor/'..oid..'_power'..'/config', j, mqttQoS, RETAIN)
end


--[[
Add Airtopia objects 
--]]
function addAt(grps, found)
  local k, v
  local addition = false
  local scan = {}
  local found = {}
  for k, v in pairs(grps) do
    local net = v.address[1]; local app = v.address[2]; local group = v.address[3]
    local pn = v.name
    local alias = table.concat(v.address, '/')
    local unit = 'A'
    local scale = 1
    local decimals = 2

    table.insert(found, alias)

    local dev = ''; local func = ''; local sense = ''; local sa = ''; local tags = v.keywords
    for _, t in ipairs(tags) do
      tp = string.split(t, '=')
      tp[1] = trim(tp[1])
      if tp[2] then
        tp[2] = trim(tp[2])
        if tp[1] == 'dev' then dev = tp[2] -- Device
        elseif tp[1] == 'func' then func = tp[2] -- Function
        elseif tp[1] == 'sense' then sense = tp[2] -- Sensor
        elseif tp[1] == 'dec' then decimals = tonumber(tp[2])
        elseif tp[1] == 'scale' then scale = tonumber(tp[2])
        elseif tp[1] == 'unit' then unit = tp[2]
        elseif tp[1] == 'sa' then sa = tp[2] -- Suggested area
        end
      end
    end
    if (func ~= '' or sense ~= '') and sa ~= '' then -- Found a suggested area
      if atArea[dev] == nil then
        atArea[dev] = sa
      end
    end
    if sense ~= '' then
      if scale ~= 1 or decimals ~= 2 then publishAdj[alias] = { dec=decimals, scale=scale } end
    end
    scan[#scan+1] = {alias=alias, dev=dev, func=func, sense=sense, unit=unit}
  end

  for _, v in ipairs(scan) do
    local sa = atArea[v['dev']]; if sa == nil then sa = '' end
    local sao = ''; if sa ~= '' then sao = string.lower(sa:gsub("% ", "_"))..'_' end
    local parts = string.split(v['alias'], '/')
    local net = parts[1]; local app = parts[2]; local group = parts[3]
    if v['func'] ~= '' then
      if not at[v['alias']] then
        at[v['alias']] = {}; addition = true
    	  at[v['alias']].name = sao..v['dev']..'-'..v['func']; at[v['alias']].select = 'func'; atDevices[sao..v['dev']..'-'..v['func']] = v['alias'];
        if atBoards[sao..v['dev']] == nil and v['func'] == 'power' then atBoards[sao..v['dev']] = {alias=v['alias'], dev=v['dev'], sa=sa} end
        publishAt(net, app, group, GetUserParam(net, group))
      end
    elseif sense ~= '' then
      if not at[v['alias']] then
        at[v['alias']] = {}; addition = true
    	  at[v['alias']].name = sao..v['dev']..'-'..v['sense']; at[v['alias']].select = 'sense'; at[v['alias']].sense = v['sense']; atDevices[sao..v['dev']..'-'..v['sense']] = v['alias']
        atBoards[sao..v['dev']]['unit'] = v['unit']
        publishAt(net, app, group, GetUserParam(net, group))
      end
    end
  end
  return addition, found
end

--[[
Queue up initial discovery and current state CBus objects 
--]]
function publishCurrent()
  mqttDevices = {}
  local grps = GetCBusByKW('MQTT', 'or')
  local n = 0
  local i, k, v
  for k, v in pairs(grps) do
    n = n + 1
    local alias = table.concat(v.address, '/')
    table.sort(v.keywords)
    local name; if v.name then name = v.name else name = GetCBusGroupTag(v.address[1], v.address[2], v.address[3]) end
    unpublished[n] = {net=v.address[1], app=v.address[2], group=v.address[3], channel=v.address[4], tags=v.keywords, name=name}
    if not mqttDevices[alias] then mqttDevices[alias] = {}; mqttDevices[alias].tags = table.concat(v.keywords,',') end
  end
  if logging and n > 0 then logger('Queued '..n..' objects with keyword MQTT for publication') end

  atDevices = {}
  grps = GetCBusByKW('AT', 'or')
  addAt(grps)
  local raw = {}
  local dev
  for k, v in pairs(grps) do
    local tags = v['keywords']
    for _, tag in ipairs(tags) do
      local parts = string.split(tag, '=')
      if parts[1] == 'dev' then
        if raw[parts[2]] == nil then raw[parts[2]] = {} end
        dev = parts[2]
      elseif parts[1] == 'sa' then
        sa = parts[2]
      end
    end
    if sa ~= nil then raw[dev] = sa end
  end

  n = 0
  for k, v in pairs(raw) do
    n = n + 1
    unpublishedAt[n] = {name=k, sa=v}
  end
end


--[[
Create / update / delete AC devices
--]]
function cudAc(initial)
  local grps = GetCBusByKW('AC', 'or')
  local found = {}
  local addition = false
  local k, v

  for k, v in pairs(grps) do
    local net = v.address[1]; local app = v.address[2]; local group = v.address[3]
    local pn = v.name
    local alias = table.concat(v.address, '/')

    table.insert(found, alias)

    local func = ''; local sel = ''; local sense = ''; local topic = 'sensor'; local tags = v.keywords
    for _, t in ipairs(tags) do
      tp = string.split(t, '=')
      tp[1] = trim(tp[1])
      if tp[2] then
        tp[2] = trim(tp[2])
        if tp[1] == 'dev' then dev = tp[2] -- Device
        elseif tp[1] == 'func' then func = tp[2] -- Function
        elseif tp[1] == 'sel' then sel = tp[2] -- Select
        elseif tp[1] == 'sense' then sense = tp[2] -- Sensor
        elseif tp[1] == 'topic' then topic = tp[2] -- Topic for sensor
        end
      end
    end
    if func ~= '' then
      if not ac[alias] then ac[alias] = {}; addition = true end
    	ac[alias].name = dev..'-'..func; ac[alias].select = 'func'; acDevices[dev..'-'..func] = alias; acBoards[dev] = true
    elseif sel ~= '' then
      if not ac[alias] then ac[alias] = {}; addition = true end
    	ac[alias].name = dev..'-'..sel; ac[alias].select = 'sel'; acDevices[dev..'-'..sel] = alias; acBoards[dev] = true
    elseif sense ~= '' then
      if not ac[alias] then ac[alias] = {}; addition = true end
    	ac[alias].name = dev..'-'..sel; ac[alias].select = 'sense'; ac[alias].sense = sense; ac[alias].topic = topic; acDevices[dev..'-'..sense] = alias; acBoards[dev] = true
    end
  end
    
  -- Handle deletions
  for k, _ in pairs(ac) do
    local f = false; for _, v in ipairs(found) do if k == v then f = true; break end end
    if not f then kill = ac[k].name; ac[k] = nil; acDevices[kill] = nil end
  end
  -- Handle additions, and re-subscribe all board topics to get status of newly added devices
  if addition then
    if not initial then
      -- Ensure that newly tagged/removed groups with the AC keyword send updates.
      logger('AC object keywords added, restarting event script')
      script.disable('AC'); script.enable('AC')
    end
    for k, _ in pairs(acBoards) do client:subscribe(k..'/#', 2) end
  end
end


--[[
Publish the state of AT devices
--]]
function publishAtState()
  for k, _ in pairs(atBoards) do
    local parts
    mode = atDevices[k..'-mode']
    power = atDevices[k..'-power']
    if mode ~= nil and power ~= nil then
      parts = string.split(mode, '/'); local mnet = tonumber(parts[1]); local mgroup = tonumber(parts[3])
      parts = string.split(power, '/'); local pnet = tonumber(parts[1]); local pgroup = tonumber(parts[3])
      local topic = 'airtopia/'..k..'/state/modeha'
      local level
      if GetUserParam(pnet, pgroup) == 0 then
        level = 'off'
      else
        level = atmodes[GetUserParam(mnet, mgroup)]
      end
      client:publish(topic, level, mqttQoS, RETAIN)
    end
    local hswing = atDevices[k..'-horiz_swing']
    local vswing = atDevices[k..'-vert_swing']
    if hswing ~= nil and vswing ~= nil then
      parts = string.split(hswing, '/'); local hnet = tonumber(parts[1]); local hgroup = tonumber(parts[3])
      parts = string.split(vswing, '/'); local vnet = tonumber(parts[1]); local vgroup = tonumber(parts[3])
      local topic = 'airtopia/'..k..'/state/swingha'
      local level
      local h = GetUserParam(hnet, hgroup)
      local v = bit.lshift(GetUserParam(vnet, vgroup), 1)
      local s = bit.bor(h, v) + 1
      client:publish(topic, atswings[s], mqttQoS, RETAIN)
    end
    local fan = atDevices[k..'-fan']
    if fan ~= nil then
      parts = string.split(fan, '/'); local fnet = tonumber(parts[1]); local fgroup = tonumber(parts[3])
      local topic = 'airtopia/'..k..'/state/fanha'
      local level
      local f = GetUserParam(fnet, fgroup)
      client:publish(topic, atfans[f+1], mqttQoS, RETAIN)
    end
    client:subscribe('airtopia/'..k..'/#', 2)
  end
end


--[[
Create / update / delete AT devices
--]]
function cudAt(initial)
  local grps = GetCBusByKW('AT', 'or')
  local boards = copy(atBoards)
  local k, v
  
  local addition, found = addAt(grps)

  -- Handle deletions
  local kill
  for k, _ in pairs(at) do
    local f = false; for _, v in ipairs(found) do if k == v then f = true; break end end
    if not f then kill = at[k].name; at[k] = nil; atDevices[kill] = nil end
  end
  local newBoards = {}
  for k, _ in pairs(atDevices) do
    local parts = string.split(k, '-')
    newBoards[parts[1]] = true
  end
  kill = {} for k, _ in pairs(atBoards) do if newBoards[k] == nil then table.insert(kill, k) end end
  for _, k in ipairs(kill) do
    atBoards[k] = nil;
    topic = mqttDiscoveryTopic..'climate/'..'cbus_mqtt_'..k..'/config'
    client:publish(topic, '', mqttQoS, RETAIN)
    topic = mqttDiscoveryTopic..'sensor/'..'cbus_mqtt_'..k..'_power/config'
    client:publish(topic, '', mqttQoS, RETAIN)
    --TODO iterate through all possibilities killing topics... client:publish('airtopia/'..k, '', mqttQoS, RETAIN)
    logger('Removed discovery topic '..topic)
  end

  -- Handle additions, and re-subscribe all board topics to get status of newly added devices
  for k, v in pairs(atBoards) do
    if boards[k] == nil then
      addAtDiscover(v['dev'], v['sa'], v['unit']) -- Publish discovery topic
    end
  end
      
  if addition then
    if not initial then
      -- Ensure that newly tagged/removed groups with the AT keyword send updates.
      logger('AT object keywords added, restarting event script')
      script.disable('AT'); script.enable('AT')
    end
    publishAtState()
  end
end

--[[
Create / update / delete ENV (environment) devices
--]]
function cudEnv(initial)
  local grps = GetCBusByKW('ENV', 'or')
  local found = {}
  local addition = false
  local k, v

  for k, v in pairs(grps) do
    local net = v.address[1]; local app = v.address[2]; local group = v.address[3]
    local alias = table.concat(v.address, '/')

    table.insert(found, alias)

    local func = ''; local sel = ''; local tags = v.keywords
    for _, t in ipairs(tags) do
      tp = string.split(t, '=')
      tp[1] = trim(tp[1])
      if tp[2] then
        tp[2] = trim(tp[2])
        if tp[1] == 'dev' then dev = tp[2] -- Device
        elseif tp[1] == 'func' then func = tp[2] -- Function
        end
      end
    end
    if func == '' then
      if v.name then n = v.name else n = GetCBusGroupTag(net, app, group) end
      func = n:lower():gsub("%s+", "_")
    end
    if not env[alias] then env[alias] = {}; addition = true end
    env[alias].name = dev..'-'..func; envDevices[dev..'-'..func] = alias; envBoards[dev] = true
  end
    
  -- Handle deletions
  for k, _ in pairs(env) do
    local f = false; for _, v in ipairs(found) do if k == v then f = true; break end end
    if not f then kill = env[k].name; env[k] = nil; envDevices[kill] = nil end
  end
  -- Handle additions, and re-subscribe all board topics to get status of newly added devices
  if addition then
    if not initial then logger('ENV object keyword added') end
    for k, _ in pairs(envBoards) do client:subscribe(k..'/#', 2) end
  end
end

--[[
Create / update / delete CBus MQTT discovery topics
--]]
function cudCBusTopics()
  local grps = GetCBusByKW('MQTT', 'or')
  local found = {}
  local lvlDelete = {}
  local n = 0
  unpublished = {}
  local queued = {}
  local k, v, alias, lvl

  for k, v in pairs(grps) do
    local change = false
    local net = v.address[1]; local app = v.address[2]; local group = v.address[3]; local channel = nil; if v.address[4] then channel = v.address[4] end
    alias = table.concat(v.address, '/')

    table.insert(found, alias)
    local tags = v.keywords
    table.sort(tags)
    local curr = table.concat(tags,',')
    if not mqttDevices[alias] then -- New group
      change = true
      mqttDevices[alias] = {}
      mqttDevices[alias].tags = curr
    else
      if mqttDevices[alias].tags ~= curr then -- Modified group
        lvl = nil; local i; for i = 1,#tags do local parts = string.split(tags[i], '='); if parts[1] == 'lvl' then lvl = parts[2]; break end end
        if app == 202 and lvl ~= nil then -- Check for levels being removed
          
          local function difference(a, b)
            local aa = {}; for _, v in ipairs(a) do aa[v] = true end; for _, v in ipairs(b) do aa[v] = nil end
            local ret = {}; for _, v in ipairs(a) do if aa[v] then ret[#ret+1]=v end end
            return ret
          end
          
          local oldTags = string.split(mqttDevices[alias].tags, ',')
          local i, olvl = ''; for i = 1,#oldTags do local parts = string.split(oldTags[i], '='); if parts[1] == 'lvl' then olvl = parts[2]; break end end
          local diff = difference(string.split(olvl, '-'), string.split(lvl, '-'))
          if #diff > 0 then lvlDelete[alias] = diff end
        end
        mqttDevices[alias].tags = curr
        change = true
      end
    end
    if change then
      if v.name then name = v.name else name = GetCBusGroupTag(net, app, group) end
      n = n + 1
      unpublished[n] = {net=net, app=app, group=group, channel=channel, tags=tags, name=name}
      queued[#queued + 1] = alias
    end
  end
  if n > 0 then logger('Queued '..n..' object'..(n ~= 1 and 's' or '')..' with keyword MQTT for publication: '..table.concat(queued, ', ')) end

  -- Handle deletions
  kill = {}
  for k, v in pairs(mqttDevices) do
    local topic, oid, trigger
    local f = false; for _, vv in ipairs(found) do if k == vv then f = true; break end end
    if not f then
      table.insert(kill, k)
      local parts = string.split(k, '/')
      if parts[2] == '202' then
        for _, trigger in ipairs(v.trigger) do
          topic = mqttDiscoveryTopic..v.type..'/'..trigger..'/config'
      	  client:publish(topic, '', mqttQoS, RETAIN); logger('Removed discovery topic '..topic)
          local t = tonumber(string.match(trigger, '_(%w+)$'))
          local act
          local tk, tv
          for tk, tv in pairs(triggers[tonumber(parts[3])]) do
            if t == tv then act = tk break end
          end
          t = mqttWriteTopic..tNetCBus(tonumber(parts[1]))..'/'..parts[2]..'/'..parts[3]..'/'..act..'/press'
          if mqttJunk then client:publish(t, 'junk', mqttQoS, RETAIN) end -- Publish junk to all topics to be deleted to ensure that they are actually deleted (some topics may not have been written yet)
          client:publish(t, '', mqttQoS, RETAIN)
        end
      else
        topic = mqttDiscoveryTopic..v.type..'/'..v.oid..'/config'
      	client:publish(topic, '', mqttQoS, RETAIN); logger('Removed discovery topic '..topic)
      end
      if parts[2] ~= '202' then
        local count
        _, count = k:gsub('/','')
        if count == 3 then -- Measurement application
          t = tNetCBus(tonumber(parts[1]))..'/'..parts[2]..'/'..parts[3]..'/'..parts[4]
          t = t:gsub('/', '_'); t = t:gsub('_', '/', 2) -- Convert the last slash to an underscore
          topic = mqttReadTopic..t;
        else
          topic = mqttReadTopic..tNetCBus(tonumber(parts[1]))..'/'..parts[2]..'/'..parts[3]
        end
        if mqttJunk then client:publish(topic..'/state', 'junk', mqttQoS, RETAIN) end
        client:publish(topic..'/state', '', mqttQoS, RETAIN)
        if count ~= 3 or bSensor[k] or binarySensor[k] then  -- Level not set for measurement and binary sensors
          if mqttJunk then client:publish(topic..'/level', 'junk', mqttQoS, RETAIN) end
          client:publish(topic..'/level', '', mqttQoS, RETAIN)
        end
      end
    else
      -- Handle trigger level removal
      if lvlDelete[k] ~= nil then
        for _, lvl in ipairs(lvlDelete[k]) do
          local parts = string.split(k, '/')
          local group = tonumber(parts[3])
          local a, t, act; for a, t in pairs(triggers[group]) do if t == tonumber(lvl) then act = a; break end end
          trigger = nil
          for _, t in ipairs(v.trigger) do if lvl == string.match(t, '_(%w+)$') then trigger = t; break end end
          if trigger then
            topic = mqttDiscoveryTopic..v.type..'/'..trigger..'/config'
            client:publish(topic, '', mqttQoS, RETAIN); logger('Remove discovery topic '..topic)
            t = mqttWriteTopic..tNetCBus(tonumber(parts[1]))..'/'..parts[2]..'/'..parts[3]..'/'..act..'/press'
            if mqttJunk then client:publish(t, 'junk', mqttQoS, RETAIN) end -- Publish junk to topic to be deleted (some topics may not have been written yet)
            client:publish(t, '', mqttQoS, RETAIN)
          end
        end
      end
    end
  end
  for _, k in ipairs(kill) do mqttDevices[k] = nil end
end


--[[
Publish queued discovery topics
--]]
function outstandingPublish()
  local nClock = socket.gettime()
  local u
  for _, u in ipairs(unpublished) do
    addDiscover(tNetCBus(u.net), u.app, u.group, u.channel, u.tags, u.name)
    local alias = u.net..'/'..u.app..'/'..u.group
    -- storage.set('pre'..alias, nil) -- Un-comment to clear out all previous values for testing
    -- Measurement application
    if u.app == 228 then
      local level = nil; pcall(function () level = GetCBusMeasurement(u.net, u.group, u.channel) end)
      if level ~= nil then publishMeasurement(tNetCBus(u.net), u.app, u.group, u.channel, level) end
    -- User parameters
    elseif u.app == 250 then publish(tNetCBus(u.net), u.app, u.group, GetUserParam(u.net, u.group))
    -- Trigger control
    elseif u.app == 202 then -- Do nothing
    -- Lighting and other
    else
      if not lightingButton[alias] then -- Do nothing for lighting buttons
        local level = nil; pcall(function () level = GetCBusLevel(u.net, u.app, u.group) end)
        if level ~= nil then publish(tNetCBus(u.net), u.app, u.group, level) end
      end
    end
  end
  if #unpublished > 0 then
    -- Ensure that newly tagged/removed groups with the MQTT keyword send updates
    if script.status('MQTT') ~= nil then script.disable('MQTT'); script.enable('MQTT') end
    logger('Published '..#unpublished..' CBus discovery and current level topic'..(#unpublished ~= 1 and 's' or '')..' in '..string.format('%.3f', socket.gettime()-nClock)..' seconds, event scripts restarted')
    unpublished = {}
  end
end


--[[
Publish queued Airtopia topics
--]]
function outstandingAtPublish()
  local nClock = socket.gettime()
  local u
  for _, u in ipairs(unpublishedAt) do
    addAtDiscover(u['name'], u['sa'], nil)
  end
  if #unpublishedAt > 0 then
    -- Ensure that newly tagged/removed groups with the AT keyword send updates
    if script.status('AT') ~= nil then script.disable('AT'); script.enable('AT') end
    logger('Published '..#unpublishedAt..' Airtopia discovery and current level topic'..(#unpublishedAt ~= 1 and 's' or '')..' in '..string.format('%.3f', socket.gettime()-nClock)..' seconds, event scripts restarted')
    unpublishedAt = {}
  end
  publishAtState()
end


--[[
Publish the next queued messages for CBus
--]]
function outstandingMqttMessage()
  local msg, k, v
  for _, msg in ipairs(mqttMessages) do
    topic = msg.topic
    payload = msg.payload

    local parts = string.split(topic, '/')

    -- Messages from CBus
    if parts[1] == 'cbus' and parts[2] == 'write' then

      local net = tNetAC(tonumber(parts[3])); local app = tonumber(parts[4]); local group = tonumber(parts[5])
      local alias = net..'/'..app..'/'..group
      if logging then logger(topic..' to '..payload) end

      local lastLevel = storage.get('lastlvl', '')

      if not parts[6] then
        logger('MQTT error: Invalid message format')

      elseif parts[6] == 'switch' then
        if payload == 'ON' then      SetCBusLevel(net, app, group, 255, 0); if logging then logger('Payload is ON for '..alias) end
        elseif payload == 'OFF' then SetCBusLevel(net, app, group, 0, 0);   if logging then logger('Payload is OFF for '..alias) end
        end
        
      elseif parts[6] == 'select' then
        SetCBusLevel(net, app, group, selects[alias][payload], 0); if logging then logger('Payload is '..payload..' ('..selects[alias][payload]..') for '..alias) end

      elseif contains('press', parts[6]) and payload == 'PRESS' then -- Lighting group press
        PulseCBusLevel(net, app, group, 255, 0, 1, 0); if logging then logger('Payload is PRESS') end

      elseif parts[7] ~= nil and contains('press', parts[7]) and payload == 'PRESS' then -- Trigger level press
        level = triggers[group][parts[6]]
        if level ~= nil then
          SetTriggerLevel(group, level); if logging then logger('Payload is PRESS') end
        else
          logger('Warning: MQTT trigger level received that is not published')
        end
    
      elseif parts[6] == 'measurement' then SetCBusMeasurement(net, app, group, payload, 0)

      elseif parts[6] == 'ramp' then
        if payload == 'OPEN' then      payload = '255'; if logging then logger("Payload is OPEN, so using RAMP instead") end
        elseif payload == 'CLOSE' then payload = '0';   if logging then logger("Payload is CLOSE, so using RAMP instead") end
        elseif payload == 'STOP' then
          -- Once a blind level has been set for CBus it is set regardless of the current blind
          -- position, which is not updated like a ramp, so a stop command is nonsensical
          if logging then logger("Payload for '..alias..' is STOP, which is incompatible with CBus... ignoring") end
          do return end
        elseif payload == 'ON' then
          if fan[alias] then
            if lastLevel[alias] then
              payload = lastLevel[alias]; if logging then logger("Payload is fan ON, so using lastlevel instead") end
            else
              payload = '255'; if logging then logger("Payload is fan ON, so using RAMP instead") end
            end
          else
            if logging then logger('Payload for '..alias..' is ON') end
            SetCBusLevel(net, app, group, 255, 0)
            do return end
          end
        end
        if payload == 'OFF' then
          if logging then logger('Payload for '..alias..' is OFF') end
          SetCBusLevel(net, app, group, 0, 0)
        else
          parts = string.split(payload, ',')
          local lev = tonumber(parts[1])
          local num
          if lev ~= nil then num = math.floor(lev + 0.5) else logger('Warning: non-numeric CBus level for '..alias..', level='..parts[1]); num = nil end
          if num ~= nil and num < 256 then
            if logging then logger('Payload for '..alias..' is RAMP '..payload) end
            local toSet = 0
            local ramp = 0
            if not fan[alias] then 
              if logging and lastLevel[alias] then logger('Last level '..lastLevel[alias]) end
              if lastLevel[alias] and num == 255 then
                if blindKey and contains(blindKey, GetCBusGroupTag(net, app, group)) then
                  toSet = num; if logging then logger("Payload is 'Blind' ramp on, so ignoring lastlevel") end
                else
                  toSet = lastLevel[alias]
                end
              else
                toSet = num
              end
            else
              if logging then logger("Payload is 'Fan' ramp, so ignoring lastlevel") end
              toSet = num
            end
            if parts[2] ~= nil then ramp = tonumber(parts[2]) else ramp = 0 end
            SetCBusLevel(net, app, group, toSet, ramp)
          end
        end
      end

    -- Messages from AC boards
    elseif parts[2] == 'climate' or parts[2] == 'select' or parts[2] == 'sensor' then
      local sel = 'func'
      -- for loop finding items parts[2] or parts[3] matches a 'sense'... is topic important??? Prolly not...
      for _, a in pairs(ac) do
        if a.sense and (a.sense == parts[3] or a.sense == parts[4]) and a.topic == parts[2] then
          sel = 'sense'
          if a.sense == parts[3] then device = parts[1]..'-'..parts[3]
          elseif a.sense == parts[4] then device = parts[1]..'-'..parts[4] end
          break
        end
      end
      if parts[2] == 'select' then sel = 'sel' end
      if sel == 'func' then device = parts[1]..'-'..parts[4] elseif sel == 'select' then device = parts[1]..'-'..parts[3] end
      local net, app, group
      if acDevices[device] then
        alias = acDevices[device]
        local p = string.split(alias, '/'); net = tonumber(p[1]); app = tonumber(p[2]); group = tonumber(p[3])
        if (sel == 'func' and parts[5] == 'state') or (sel == 'sel' and parts[4] == 'state') or sel == 'sense' then
          if ignoreCbus[alias] and os.time() - ignoreCbus[alias] > ignoreTimeout then -- Don't worry about older 'ignore' flags
            ignoreCbus[alias] = nil
            if logging then logger('Ignoring older CBus ignore flag for '..alias) end
          end
          if not ignoreCbus[alias] then -- Only set the CBus status/level if this script did not initiate the change, and if it is different to the current value
            local set = false
            local extant = GetUserParam(net, group)
            local e = tonumber(extant)
            if e ~= nil then
              if string.format('%.3f', e) ~= string.format('%.3f', tonumber(payload)) then SetUserParam(net, group, payload); set = true end
            else
              if extant ~= payload then SetUserParam(net, group, payload); set = true end
            end
            -- Setting CBus here will result in the AC event script requesting publication of the state using publishAc() above.
            -- This is undesired, so ignoreMqtt[alias] is used to ensure that the CBus change received does not publish to MQTT.
            if set then ignoreMqtt[alias] = os.time() if logging then logger('Setting ignoreMqtt for '..alias..', oldState='..extant..' payload='..payload) end end
          else
            ignoreCbus[alias] = nil
            if logging then logger('Ignoring CBus publish for '..alias) end
          end
          ac[alias].state = payload
        end
      end
    
    -- Messages from AT boards
    elseif parts[1] == 'airtopia' and parts[3] == 'cmd' then
      device = parts[2]..'-'..parts[4]
      local net, app, group
      
      function pub(alias, payload) -- State publish to MQTT
        local parts = string.split(at[alias].name, '-')
        local board = parts[1]
        local topic = 'airtopia/'..board..'/state/'..parts[2]
        client:publish(topic, payload, mqttQoS, RETAIN)
      end

      if parts[4] == 'mode' then
        if atDevices[device] then
          alias = atDevices[device]
          local p = string.split(alias, '/'); net = tonumber(p[1]); app = tonumber(p[2]); group = tonumber(p[3])
          i = indexOf(atmodes, payload)
          if i ~= nil then
            local set = false
            local pwrgrp = tonumber(string.split(atBoards[parts[2]]['alias'], '/')[3]) -- Get the power user parameter
            local extant = GetUserParam(net, pwrgrp)
            local pld = nil
            if payload ~= 'off' then
              pub(alias, i)
              pub(atBoards[parts[2]]['alias'], 1) -- Power on
              if extant ~= 1 then set = true; pld = 1 end
            else
              pub(atBoards[parts[2]]['alias'], 0) -- Power off
              if extant ~= 0 then set = true; pld = 0 end
            end
            if set and pld ~= nil then
              -- Send to CBus, ensuring MQTT ignore is set...
              local alias = atBoards[parts[2]]['alias']
              ignoreMqtt[alias] = os.time() if logging then logger('Setting ignoreMqtt for '..alias..', oldState='..extant..' payload='..pld) end
              SetUserParam(net, pwrgrp, pld)
            end
            -- publish to CBus
            local extant = GetUserParam(net, group)
            if i ~= extant and payload ~= 'off' then -- Set mode, but not if it is 'off'
              ignoreMqtt[alias] = os.time() if logging then logger('Setting ignoreMqtt for '..alias..', oldState='..extant..' payload='..payload) end
              SetUserParam(net, group, i)
            end
          end
          -- Publish state to broker
          local parts = string.split(at[alias].name, '-')
          local board = parts[1]
          local topic = 'airtopia/'..board..'/state/modeha'
          client:publish(topic, payload, mqttQoS, RETAIN)
        end

      elseif parts[4] == 'swing' then
        local hswing = atDevices[parts[2]..'-horiz_swing']
        local vswing = atDevices[parts[2]..'-vert_swing']
        if hswing ~= nil and vswing ~= nil then
          local i, h, v
          local s = 0; for i, v in ipairs(atswings) do if v == payload then s = i - 1; break; end end -- Get the swing index
          h = bit.band(s, 1)
          v = bit.rshift(bit.band(s, 2), 1)
          local board = parts[2]
          local topic = 'airtopia/'..board..'/state/swingha'
          client:publish(topic, payload, mqttQoS, RETAIN)
          parts = string.split(hswing, '/'); SetUserParam(parts[1], parts[3], h)
          parts = string.split(vswing, '/'); SetUserParam(parts[1], parts[3], v)
        end
        
      elseif parts[4] == 'fan' then
        local fan = atDevices[parts[2]..'-fan']
        if fan ~= nil then
          local i, f
          local f = 0; for i, v in ipairs(atfans) do if v == payload then f = i - 1; break; end end -- Get the fan index
          local board = parts[2]
          local topic = 'airtopia/'..board..'/state/fanha'
          client:publish(topic, payload, mqttQoS, RETAIN)
          parts = string.split(fan, '/'); SetUserParam(parts[1], parts[3], f)
        end
        
      else -- Set target temp
        if atDevices[device] then
          alias = atDevices[device]
          local p = string.split(alias, '/'); net = tonumber(p[1]); app = tonumber(p[2]); group = tonumber(p[3])
          pub(alias, payload)
          -- publish to CBus
          local extant = GetUserParam(net, group)
          if payoad ~= extant then
            ignoreMqtt[alias] = os.time() if logging then logger('Setting ignoreMqtt for '..alias..', oldState='..extant..' payload='..payload) end
            SetUserParam(net, group, payload)
          end
        end
      end
    end
    
    -- Messages from ENV boards - simpler, only messages inbound
    if parts[2] == 'sensor' and parts[4] == 'state' then
      device = parts[1]..'-'..parts[3]
      if envDevices[device] then
        parts = string.split(envDevices[device], '/')
        local net = parts[1]; local app = parts[2]; local group = parts[3]
        local alias = net..'/'..app..'/'..group
        local extant = GetUserParam(net, group)
        if type(extant) == 'number' then
          -- Deal with real number imprecision, assuming three decimal places for change detection
          if string.format('%.3f', extant) ~= string.format('%.3f', tonumber(payload)) then SetUserParam(net, group, payload) end
        else
          if extant ~= payload then SetUserParam(net, group, payload) end
        end
        env[alias].state = payload
      end
    end
    ::next::
  end
  mqttMessages = {}
end


--[[
Publish the next queued messages for MQTT
--]]
function outstandingCbusMessage()
  local cmd
  for _, cmd in ipairs(cbusMessages) do
    local parts = string.split(cmd, '/')
    local alias = parts[1]..'/'..parts[2]..'/'..parts[3]
    
    if ac[alias] then -- AC message to MQTT (no ramping involved for AC groups)
      publishAc(parts[1], parts[2], parts[3], parts[4], ac[alias].select)
    elseif at[alias] then -- AT message to MQTT (no ramping involved for AT groups)
      publishAt(parts[1], parts[2], parts[3], parts[4])
    else -- CBus message to MQTT
      local net = tonumber(parts[1]); local app = tonumber(parts[2]); local group = tonumber(parts[3]);
      if app ~= 228
        then -- i.e. not measurement application
        local setting = true
        local payload = tonumber(parts[4]) -- Always a number for lighting app, but payload could be nil for user param at this point if a string
        if lighting[parts[2]] then -- Lighting application, so check for ramp
          if logging then logger('Alias: '..alias..', payload: '..tostring(payload)..', ramp rate: '..tostring(GetCBusRampRate(net, app, group))..', target level: '..tostring(GetCBusTargetLevel(net, app, group))) end
          -- A CBus ramp up and down can annoyingly begin with a zero level, then steadily converge to the target level. This initial
          -- zero should not be published to MQTT so it is ignored. If an initial zero is not seen then the ramp will be orphaned (and
          -- ultimately cleaned up/published, albeit a bit late after rampTimeout seconds).
          if not ramp[alias] then
            if GetCBusRampRate(net, app, group) > 0 then
              ramp[alias] = { ts=os.time(), ramp=GetCBusRampRate(net, app, group), target=GetCBusTargetLevel(net, app, group) }
              if payload == 0 then
                setting = false
                if logging then logger('Set ramp for '..alias..' and suppress zero send') end
              else
                if logging then logger('Set ramp for '..alias) end
              end
            end
          else
            if ramp[alias].target ~= GetCBusTargetLevel(net, app, group) then -- Target level has changed so cancel ramp
              ramp[alias] = nil
              if logging then logger('Cancel ramp for '..alias) end
              if payload == 0 and GetCBusRampRate(net, app, group) > 0 then setting = false end -- Ignore initial zero if ramp on
            end
          end
        else
          if payload == nil then
            payload = parts[4]
            local pt = 5 -- Accommodate an unlimited number of slashes in a string payload
            while parts[pt] ~= nil do
              payload = payload..'/'..parts[pt]
              pt = pt + 1
            end
          end -- Possibly a string payload for user parameter
          -- Groups other than lighting are never ramped, so setting is always true
        end
        if setting then
          publish(tNetCBus(net), app, group, payload)
          if ramp[alias] and payload == ramp[alias].target then
            ramp[alias] = nil
            if logging then logger('Clear ramp for '..alias) end
          end
          if app ~= 202 then -- Not trigger
            sKey = 'pre'..alias
            local p = payload
            if tonumber(payload) ~= nil then p = string.format('%.3f', payload) end
            storage.set(sKey, p) -- Save payload as 'previous' for use in the MQTT event-based script
          end
        end
      else -- Special case for measurement app
        publishMeasurement(tNetCBus(tonumber(parts[1])), tonumber(parts[2]), tonumber(parts[3]), tonumber(parts[4]), tonumber(parts[5]))
        if tonumber(parts[5]) ~= nil then
          sKey = 'pre'..parts[1]..'/'..parts[2]..'/'..parts[3]..'/'..parts[4]
          local p = string.format('%.3f', tonumber(parts[5]))
          storage.set(sKey, p)
        end
      end
    end
  end
  cbusMessages = {}
end

--[[
Remove any orphaned ramp flags
--]]
function checkRampOrphans()
  local k, v; local orphan = {}
  for k, v in pairs(ramp) do
    if os.time() > v.ts + v.ramp + rampTimeout then
      -- Is an older ramp timestamp beyond ramp duration plus margin (should never occur, but does occasionally)
      -- Remove the orphan, and publish the final target, which will be zero
      -- Occurs when a ramp to off does not begin with a zero level during the ramp, or if a ramp to zero starts
      -- when the group is already at zero.
      table.insert(orphan, k)
      parts = string.split(k, '/')
      local net = tonumber(parts[1]); local app = tonumber(parts[2]); local group = tonumber(parts[3]);
      publish(tNetCBus(net), app, group, v.target)
    end
  end
  for _, k in ipairs(orphan) do ramp[k] = nil; if logging then logger('Removing orphaned ramp for '..k) end end
end


--[[
Main loop
--]]

-- Create/update/delete scripts spread evenly over the period 'trackChanges'
cud = {
  { func = cudCBusTopics, init = false },
  { func = cudAc, init = true, script = 'AC' },
  { func = cudEnv, init = true },
  { func = cudAt, init = false, script = 'AT' },
}
for i, c in ipairs(cud) do c.t = os.time() - checkChanges * 1/#cud * i + checkChanges/#cud end

-- Initial load of devices excluding CBus, suppressing MQTT re-subscribe
for _, c in ipairs(cud) do if c.init then c.func(true); if c.script and script.status(c.script) ~= nil then script.disable(c.script); script.enable(c.script) end end end

function validateIncoming(cmd) -- Reject any weird socket messages received
  local _, count = cmd:gsub("/", ''); if count < 3 or count > 4 then return false end
  local parts = string.split(cmd, '/')
  local dstC, payload
  if parts[2] and parts[2] == '228' then dstC = 4; payload = parts[5] else dstC = 3; payload = parts[4] end -- Measurement app is four dest parts, else three
  if payload == nil then return false end
  for i = 1,dstC,1 do n = tonumber(parts[i], 10); if n == nil then return false end end -- Test whether any dst parts are not whole decimal numbers
  return true
end


while true do
  -- Check for new messages from CBus. The entire socket buffer is collected each iteration for efficiency.
  local more = false
  local stat, err = pcall(function ()
    ::checkAgain::
    local cmd = nil
	  cmd = server:receive()
    if cmd and type(cmd) == 'string' then
      if validateIncoming(cmd) then
        cbusMessages[#cbusMessages + 1] = cmd -- Queue the new message
      else
        logger('Invalid command received: '..cmd)
      end
      server:settimeout(0); more = true; goto checkAgain -- Immediately check for more buffered inbound messages to queue
    else
      if more then server:settimeout(socketTimeout) end
    end
  end)
  if not stat then logger('Socket receive error: '..err) end

  -- Process MQTT message buffers synchronously - sends and receives
  client:loop(mqttTimeout)

  if mqttStatus == 1 then
    -- When connected to the broker
    if #mqttMessages > 0 then outstandingMqttMessage() end -- Send outstanding messages to CBus
    if #cbusMessages > 0 then outstandingCbusMessage() end -- Send outstanding messages to MQTT
    if #unpublished > 0 then outstandingPublish() end      -- Publish outstanding CBus discovery topics
    if #unpublishedAt > 0 then outstandingAtPublish() end  -- Publish outstanding Airtopia discovery topics
    if len(ramp) > 0 then checkRampOrphans() end           -- Some scenarios create ramp orphans
    if checkForChanges then                                -- Periodically create/update/delete device items that change
      for _, c in ipairs(cud) do if os.time() - c.t >=checkChanges then c.t = os.time(); c.func() end end
    end
  elseif mqttStatus == 2 and os.time() - mqttConnected >= 5 then
    -- MQTT is disconnected, so attempt a connection every five seconds
    mqttConnected = os.time()
    client:connect(mqttBroker, 1883, 25) -- Requested keep-alive 25 seconds, broker at port 1883
    -- Allow some settling time for subscriptions with retain flag
    time = socket.gettime() while socket.gettime() - time < 2 do client:loop(0) end
    if mqttStatus == 1 then
      -- If duplicate discovery topics are detected then remove them
      if len(discoveryDelete) > 0 then
        logger('Warning: Removing '..len(discoveryDelete)..' duplicate discovery topics')
        for toDelete, _ in pairs(discoveryDelete) do
          local parts = string.split(toDelete, '/')
          local oid = parts[1]
          local dType = parts[2]
          logger('Removing '..mqttDiscoveryTopic..dType..'/'..oid..'/config')
          client:publish(mqttDiscoveryTopic..dType..'/'..oid..'/config', '', mqttQoS, RETAIN)
        end
        discoveryDelete = {}
      end
      -- Full publish CBus topics
      publishCurrent()
    end
  end

  --[[
  Send a heartbeat periodically to port 5433, listened to by the Heartheat script.
  If execution is disrupted by any error or lockup then this script will be re-started.
  If sending the heartbeat faults, then the loop is exited, which will also re-start this
  script (it being resident/sleep zero).
  --]]
  
  if sendHeartbeat > 0 then
    local stat, err = pcall(function ()
      if os.time() - heartbeat >= sendHeartbeat then
        heartbeat = os.time(); require('socket').udp():sendto(_SCRIPTNAME..'+'..heartbeat, '127.0.0.1', 5433)
      end
    end)
    if not stat then logger('A fault occurred sending heartbeat. Restarting...'); do return end end
  end
end