--[[ CHANGE TO SUIT ENVIRONMENT --]]
local mqttBroker = '192.168.10.21'
local mqttUsername = 'mqtt'
local mqttPassword = 'password'
local lighting = { ['56'] = true, } -- Array of applications that are used for lighting (do not remove should lastLevel not be required)
local checkForChanges = true       -- When true the script will periodically check for create/update/delete of object keywords (disable to lower CPU load, and manually restart on keyword change)
local checkChanges = 30            -- Interval in seconds to check for changes to object keywords

--[[ SET AS APPROPRIATE TO SUIT ENVIRONMENT --]]
local airtopiaSupport = false      -- Monitor keyword 'AT' for Airtopia devices - set to true if support is desired
local panasonicSupport = false     -- Monitor keyword 'AC' for Panasonic devices - set to true if support is desired
local environmentSupport = false   -- Monitor keyword 'ENV' for ESPHome environment sensors - set to true if support is desired

--[[ NOTE: cbus/read/254 and cbus/write/254 HAVE CHANGED to cbus/read/0 and cbus/write/0 (done for improved efficiency). Clean up old topics using MQTT Explorer. --]]
--[[ NOTE: !!!+++BREAKING CHANGE+++!!! Keywords for the lvl= tag have CHANGED. Use '/' instead of '-', and ':' where '/' was previously used. See the README for updated examples. --]]

--[[
Resident, zero sleep interval, name: 'MQTT send receive'

Manage CBus, Panasonic and Airtopia AC and environment events for MQTT, and publish discovery topics. Used with Home Assistant.

Documentation available at https://github.com/autoSteve/acMqtt
--]]

--[[
General configuration variables follow. Change as required, but probably no need to.
--]]
local logging = false        -- Enable detailed logging
local logms = false          -- Display timestamp duration of certain operations

local setCoverLevelAtStop = true -- As the name implies, for tracked covers in level translation mode, set the stop value to the estimated level at stop
local sendHeartbeat = 30     -- Send a heartbeat to the 'Heartbeat' script every n seconds (zero to disable heartbeat)
local heartbeatConditions = { max = 120, } -- At most 120 seconds without a heartbeat or else get restarted
local publishNoLevel = false -- For trigger app, whether to publish a level with no tag as "Level n" or raise an error in the log
local selectExact = true     -- For select, if a CBus level other than in the select levels is set then adjust the CBus level to the next higher select level
local blindKey               -- If blind fully open is desirable instead of lastlevel, then change to a string contained in every blind object (e.g. 'Blind'), case sensitive
local mqttClientId = 'nac'   -- The Mosquitto client ID, which must be unique on the broker - this can be set to nil, in which case a unique name will automatically be generated by the broker
local mqttQoS = 2            -- Quality of service for MQTT messages: 0 = only once, 1 = at least once, 2 = exactly once
local mqttJunk = true        -- Whether to publish junk before a blank publish message when removing topics (not necessary, but cleans up MQTT Explorer view)

--[[
Timing variables. Adjust to taste if you know what you're doing. These provide a good compromise, but your deployment may vary.
--]]
local socketTimeout = 0.1    -- Lower = higher CPU, but better responsiveness (0 .05 = 1/20th of a second or 50ms, 0.005 = 5ms)
local mqttTimeout = 0        -- In milliseconds, go with zero unless you know what you're doing
local ignoreTimeout = 2      -- Timeout for stale MQTT ignore messages in seconds (two seconds is a long time...)
local rampTimeout = 5        -- Time beyond ramp to declare a ramp orphan in seconds (legacy firmware only)

--[[
Topic prefixes for read/write/publish. The mqttDiscovery topic is recommended to be set to 'homeassistant/'
for use with HA, which is the default here. The MQTT CBus topics can be called whatever you want, as discovery/subscribe
adjusts. All topic prefixes must end in '/'.
--]]
local mqttCbus = 'cbus/'
local mqttReadTopic = mqttCbus..'read/'
local mqttWriteTopic = mqttCbus..'write/'
local mqttDiscoveryTopic = 'homeassistant/'

--[[
Variables not to be messed with unless you definitely know what you're doing.
--]]
local EVENTVERSION = 3       -- MQTT/MQTT final event script compatible version
local ACVERSION = 1          -- Panasonic event script compatible version
local ATVERSION = 1          -- Airtoipia event script compatible version
local init = true            -- Initialisation
local reconnect = false      -- Reconnection does not perform a full publish
local discovery = {}         -- MQTT discovery topics lookup
local discoveryDelete = {}   -- If duplicate discovery topics are detected on startup then they will be removed
local discoveryName = {}     -- Device names (used for rename detection)
local mqttDevices = {}       -- CBus groups to send MQTT topics for
local ac = {}                -- Panasonic AC device details
local acDevices = {}         -- Quick lookup to determine whether an object is an AC device
local acBoards = {}          -- All physical AC boards (esp32)
local acSense = {}           -- Quick lookup for AC sensors
local at = {}                -- Airtopia device details
local atDevices = {}         -- Quick lookup to determine whether an object is an AT device
local atBoards = {}          -- All physical AT boards
local atDiscovery = {}       -- AT discovery topics lookup
local atDiscoveryDelete = {} -- If duplicate discovery topics are detected on startup then they will be removed
local env = {}               -- Environment device details
local envDevices = {}        -- Quick lookup to determine whether an object is an environment device
local envBoards = {}         -- All physical environment boards (esp32)
local cbusMessages = {}      -- Message queue
local mqttMessages = {}      -- Message queue
local ignoreCbus = {}        -- To prevent message loops
local ignoreMqtt = {}        -- To prevent message loops
local ramp = {}              -- Keeps track of ramping to ignore some zero level MQTT publish events outstandingCbusMessage()
local triggers = {}          -- Trigger groups and their levels
local selects = {}           -- Select groups and their options/levels
local cover = {}             -- Quick lookup to determine whether an object is a cover (blind)
local fan = {}               -- Quick lookup to determine whether an object is a fan (sweep fan)
local bSensor = {}           -- Quick lookup to determine whether an object is a bsensor (a regular lighting group acting as status)
local binarySensor = {}      -- Quick lookup to determine whether an object is a binary sensor
local button = {}            -- Quick lookup to determine whether an object is a button
local lightingButton = {}    -- Quick lookup to determine whether an object is a lighting group as a button
local userParameter = {}     -- Quick lookup to determine whether an object is a user parameter
local unitParameter = {}     -- Quick lookup to determine whether an object is a unit parameter
local storeLevel = {}        -- Instruct MQTT Final/MQTT event script to store the last level for certain object types (fan, fan_pct)
local publishAdj = {}        -- Holds scale and decimals to apply
local includeUnits = {}      -- Holds table of booleans to add sensor unit (%, $, Â°C, etc.) to MQTT value
local transition = {}        -- Covers that are transitioning
local unpublished = {}       -- The outstanding set of CBus objects to publish discovery topics for
local unpublishedAt = {}     -- The outstanding set of CBus Airtopia objects to publish discovery topics for
local mqttStatus = 2         -- The status of the MQTT connection. Initially disconnected, which will cause an immediate connection. 1=connected, 2=disconnected
local mqttConnected = 0      -- Timestamp of MQTT connection
local imgDefault = {         -- Defaults for images - Simple image name, or a table of 'also contains' keywords (which must include an #else entry)
  heat            = 'mdi:radiator',
  blind           = 'mdi:blinds',
  ['under floor'] = {enable = 'mdi:radiator-disabled', ['#else'] = 'mdi:radiator'},
  ['towel rail']  = {enable = 'mdi:radiator-disabled', ['#else'] = 'mdi:radiator'},
  fan             = {sweep = 'mdi:ceiling-fan', ['#else'] = 'mdi:fan'},
  exhaust         = 'mdi:fan',
  gate            = {open = 'mdi:gate-open', ['#else'] = 'mdi:gate'},
}
local acMsg = { climate = true, select = true, sensor = true, }
local cudRaw = {             -- All possible keywords for MQTT types, used in CUD function to exclude unrelated keywords for change detection
  'MQTT', 'light', 'switch', 'cover', 'fan', 'fan_pct', 'fanpct', 'sensor', 'binary_sensor', 'binarysensor', 'bsensor', 'button', 'select',
  'pn=', 'sa=', 'img=', 'unit=', 'class=', 'dec=', 'scale=', 'on=', 'off=', 'lvl=', 'rate=', 'delay=',
  'includeunit', 'preset', 'noleveltranslate',
}
local cudAll = {} local param for _, param in ipairs(cudRaw) do cudAll[param] = true end cudRaw = nil

-- local coverLevel = {} storage.set('coverLevel', coverLevel) -- Clear stored coverLevel
local coverLevel = storage.get('coverLevel', {}) -- Holds the current level of covers (survives restart)

local airtopiaCmds = { 'power', 'fan', 'swing', 'mode', 'target_temperature', } -- All command topics (used for clean up)
local atmodes = { 'auto', 'cool', 'heat', 'fan_only', 'dry', 'off', } -- Airtopia modes
local atswings = { 'Off', 'Horizontal only', 'Vertical only', 'Horizontal and Vertical', } -- Airtopia swing modes
local atfans = { 'Auto', '1', '2', '3', '4', } -- Airtopia fan speed (THIS IS UNTESTED, will result in 0, 1, 2, 3, 4 being set in the user parameter in the order of the table)
local airtopiaStates = {}    -- Current state topics in use (used for clean up)

local RETAIN = true          -- Boolean aliases for MQTT retain and no-retain settings
local NORETAIN = false

local started = socket.gettime()
local heartbeat = started

-- Runtime global variable checking. Globals must be explicitly declared, which will catch variable name typos
local declaredNames = { vprint = true, vprinthex = true, maxgroup = true, mosquitto = true, rr = true, _ = true, }
local function declare(name, initval) rawset(_G, name, initval) declaredNames[name] = true end
local exclude = { ngx = true, }
setmetatable(_G, {
  __newindex = function (t, n, v) if not declaredNames[n] then log('Warning: Write to undeclared global variable "'..n..'"') end rawset(t, n, v) end,
  __index = function (_, n) if not exclude[n] and not declaredNames[n] then log('Warning: Read undeclared global variable "'..n..'"') end return nil end,
})

local function len(tbl) local i = 0 for _, _ in pairs(tbl) do i = i + 1 end return i end -- Get number of table members
local function hasMembers(tbl) for _, _ in pairs(tbl) do return true end return false end -- Get whether any table members
string.contains = function (text, prefix) local pos = text:find(prefix, 1, true); if pos then return pos >= 1 else return false end end -- Test whether a string contains a substring, ignoring nil
--string.trim = function (s) if s ~= nil then return s:match('^%s*(.-)%s*$') else return nil end end -- Remove leading and trailing spaces
local function sleep(sec) socket.select(nil, nil, sec) end
local function tNetCBus(net) if net == 0 then return 254 else return net end end -- Translate AC network numbering to CBus
local function indexOf(array, value) for i, v in ipairs(array) do if v == value then return i end end return nil end -- Find the index number of an array member
local function lastSlashToUnderscore(alias) local cnt alias, cnt = alias:gsub('/', '_') return alias:gsub('_', '/', cnt-1) end -- Convert the last slash character to an underscore
local function copy(obj, seen) -- Copy tables, 'seen' is for recursive use
  if type(obj) ~= 'table' then return obj end
  if seen and seen[obj] then return seen[obj] end
  local s = seen or {}
  local res = setmetatable({}, getmetatable(obj))
  s[obj] = res
  for k, v in pairs(obj) do res[copy(k, s)] = copy(v, s) end
  return res
end
local function equals(o1, o2, ignoreMt) -- Compare two variables (simple, tables, anything). Default ignore metatables.
  if ignoreMt == nil then ignoreMt = true end
  if o1 == o2 then return true end
  local o1Type = type(o1) local o2Type = type(o2)
  if o1Type ~= o2Type then return false end if o1Type ~= 'table' then return false end
  if not ignoreMt then local mt1 = getmetatable(o1) if mt1 and mt1.__eq then return o1 == o2 end end
  local keySet = {}
  for key1, value1 in pairs(o1) do local value2 = o2[key1] if value2 == nil or equals(value1, value2, ignoreMt) == false then return false end keySet[key1] = true end
  for key2, _ in pairs(o2) do if not keySet[key2] then return false end end
  return true
end
local function removeIrrelevant(keywords)
  local curr = {}
  for _, k in ipairs(keywords:split(',')) do
    local parts = k:split('=') if parts[2] ~= nil then parts[1] = parts[1]:trim()..'=' end
    if cudAll[parts[1]] then table.insert(curr, k) end
  end
  return table.concat(curr, ',')
end


--[[
Register with the Heartbeat script
--]]
local function isRegistered() local hbeat = storage.get('heartbeat', {}); local k; for k, _ in pairs(hbeat) do if k == _SCRIPTNAME then return true, hbeat end end return false, hbeat end
if sendHeartbeat > 0 then
  -- Check whether registration is required, and if not registered (or conditions changed) then register
  local r, hbeat = isRegistered()
  if not r or (r and not equals(hbeat[_SCRIPTNAME], heartbeatConditions)) then
    local k, v, vals
    vals = '' for k, v in pairs(heartbeatConditions) do vals = vals..k..'='..v..' ' end
    log('Registering '.._SCRIPTNAME..' with heartbeat of '..vals)
    hbeat[_SCRIPTNAME] = heartbeatConditions
    storage.set('heartbeat', hbeat)
  end
else -- Remove script from hearbeat registration
  local r, hbeat = isRegistered() if r then hbeat[_SCRIPTNAME] = nil storage.set('heartbeat', hbeat) end
end


--[[
Warn for firmware >= 1.15.0 that using MQTT final is preferred, and also halt regarding settings for execute during ramping / missing scripts / wrong version
--]]
local eventScripts = db:getall("SELECT name FROM scripting WHERE type = 'event'")
local eventName, finalName, acName, atName, s = nil, nil, nil, nil
for _, s in ipairs(eventScripts) do
  if s.name:lower() == 'mqtt' then eventName = s.name end
  if s.name:lower() == 'mqtt final' then finalName = s.name end
  if s.name:lower() == 'ac' then acName = s.name end
  if s.name:lower() == 'at' then atName = s.name end
end

local finalInstalled = finalName ~= nil and not (script.status(finalName) == nil or script.status(finalName) == false)
local eventInstalled = eventName ~= nil and not (script.status(eventName) == nil or script.status(eventName) == false)

if not eventInstalled and not finalInstalled then
  log("Error: The event script 'MQTT' or 'MQTT final' is not installed or enabled. Not starting.")
  while true do sleep(1) end
end

local version = string.split(io.readfile('/lib/genohm-scada/version'):trim(), '.')
local legacyFirmware = false
if tonumber(version[1]) >= 1 and tonumber(version[2]) >= 15 and tonumber(version[3]) >= 0 then
  if not finalInstalled then
    log('Warning firmware > 1.15.0: Script MQTT final is not installed, or is disabled. This script avoids ramp detection, and is recommended.')
    legacyFirmware = true
  end

  if eventInstalled and finalInstalled then
    log("Warning: Both 'MQTT' and 'MQTT final' are installed. Disabling MQTT event script...")
    script.disable(eventName)
    eventInstalled = false
  end

  local edr
  if eventInstalled then
    edr = db:getall("SELECT subparams FROM scripting WHERE name = '"..eventName.."'")
    edr = edr[1] if edr ~= nil then edr = edr.subparams end
    if edr ~= '1' then
      log("Error firmware > 1.15.0: Event script 'MQTT' is not set to execute during ramping. Not starting. Consider using 'MQTT final' instead.")
      while true do sleep(1) end
    end
  end
  if finalInstalled then
    edr = db:getall("SELECT subparams FROM scripting WHERE name = '"..finalName.."'")
    edr = edr[1] if edr ~= nil then edr = edr.subparams end
    if edr ~= '0' then
      log("Error firmware > 1.15.0: Event script 'MQTT final' is set to execute during ramping. Turn this off. Not starting.")
      while true do sleep(1) end
    end
  end
else
  legacyFirmware = true
  log('Warning: An upgrade to firmware 1.15.0+ is highly recommended. See the README at https://github.com/autoSteve/acMqtt.')

  if not eventInstalled and finalInstalled then
    log("Error: The script 'MQTT' is not installed. Do not use 'MQTT final' for 1.15.0+. Not starting.")
    while true do sleep(1) end
  end

  if eventInstalled and finalInstalled then
    log("Warning: Both 'MQTT' and 'MQTT final' are installed. Disabling MQTT final event script...")
    script.disable(finalName)
    finalInstalled = false
  end
end
if tonumber(version[1]) <= 1 and tonumber(version[2]) <= 6 then
  log('Warning: Untested on firmware 1.6.0 or below. An upgrade is highly recommended.')
end
-- By now, if both event scripts were installed then one of them will have been forced disabled, so re-check installed status before checking compatibility
finalInstalled = finalName ~= nil and not (script.status(finalName) == nil or script.status(finalName) == false)
eventInstalled = eventName ~= nil and not (script.status(eventName) == nil or script.status(eventName) == false)
local compatibleEvent = false
if eventInstalled then compatibleEvent = db:getall("SELECT script FROM scripting WHERE name = '"..eventName.."'")[1].script:contains('VERSION: '..EVENTVERSION) end
if finalInstalled then compatibleEvent = db:getall("SELECT script FROM scripting WHERE name = '"..finalName.."'")[1].script:contains('VERSION: '..EVENTVERSION) end
if not compatibleEvent then
  local scriptInUse = ''
  if finalInstalled then scriptInUse = finalName end
  if eventInstalled then scriptInUse = eventName end
  log("Error: Incompatible '"..scriptInUse.."' script version detected, so update it. Not starting.")
  while true do sleep(1) end
end
if panasonicSupport then
  local acInstalled = acName ~= nil and not (script.status(acName) == nil or script.status(acName) == false)
  local compatibleAc = false
  if acInstalled then compatibleAc = db:getall("SELECT script FROM scripting WHERE name = '"..acName.."'")[1].script:contains('VERSION: '..ACVERSION) end
  if not compatibleAc and ACVERSION ~= 1 then log("Error: Incompatible '"..acName.."' script version detected, so update it. Not starting.") while true do sleep(1) end end
end
if airtopiaSupport then
  local atInstalled = atName ~= nil and not (script.status(atName) == nil or script.status(atName) == false)
  local compatibleAt = false
  if atInstalled then compatibleAt = db:getall("SELECT script FROM scripting WHERE name = '"..atName.."'")[1].script:contains('VERSION: '..ATVERSION) end
  if not compatibleAt and ATVERSION ~= 1 then log("Error: Incompatible '"..atName.."' script version detected, so update it. Not starting.") while true do sleep(1) end end
end


--[[
UDP listener - receive messages from CBus level change event scripts
--]]
declare('server')
pcall(function () server:close() end)
server = require('socket').udp()
server:settimeout(socketTimeout)
server:setsockname('127.0.0.1', 5432) -- Listen on port 5432 for CBus changes


--[[
Mosquitto client and call-backs
--]]

local mqtt = require('mosquitto')
local client = mqtt.new(mqttClientId)
client:will_set(mqttCbus..'status', 'offline', mqttQoS, RETAIN) -- Last will and testament is to set status offline
if mqttUsername then client:login_set(mqttUsername, mqttPassword) end

client.ON_CONNECT = function(success)
  local k
  if success then
    log('Connected to Mosquitto broker')
    client:publish(mqttCbus..'status', 'online', mqttQoS, RETAIN)
    mqttStatus = 1
  end
end

client.ON_DISCONNECT = function(...)
  log('Mosquitto broker disconnected')
  mqttStatus = 2
  init = true
  reconnect = true
end

client.ON_MESSAGE = function(mid, topic, payload)
  if topic:contains('/cbus_mqtt_') then
    -- Record discovery topics to check for duplication
    local parts = string.split(topic, '/')
    if parts[1] == string.split(mqttDiscoveryTopic, '/')[1] then
      if payload ~= '' and discovery[parts[3]] ~= nil then
        if discovery[parts[3]] ~= parts[2] then
          discoveryDelete[parts[3]..'/'..parts[2]] = true
        else
          discovery[parts[3]] = parts[2] -- Table of CBus addresses with type as the value
          discoveryName[parts[3]] = json.decode(payload).dev.name -- Used for rename detection
        end
      end
    end
  else
    mqttMessages[#mqttMessages + 1] = { topic=topic, payload=payload } -- Queue the message
  end
end


--[[
Publish lighting, user parameter and trigger objects to MQTT 
--]]
local function publish(alias, app, level, noPre)
  if noPre == nil then noPre = false end
  if level == nil then log('Warning: Nil CBus level for '..alias); do return end end
  local state = ''
  if cover[alias] then
    if mqttDevices[alias].noleveltranslate then
      state = (tonumber(level) ~= 0) and 'open' or 'closed'
    else
      -- For CBus blind controllers report level unless it is 5, which is a preset for stop in level translation mode
      state = 'stopped'
      if level == 5 then level = -1 end
    end
  else
    state = (tonumber(level) ~= 0) and 'ON' or 'OFF'
  end
  if not userParameter[alias] then
    if not binarySensor[alias] then
      if bSensor[alias] then -- It's a bSensor
        client:publish(mqttReadTopic..alias..'/level', level, mqttQoS, RETAIN)
        if logging then log('Publishing '..mqttReadTopic..alias..' to '..level) end
      elseif selects[alias] then -- It's a select
        local l
        for _, l in ipairs(selects[alias].allLvl) do
          if tonumber(level) <= l.lvl then
            if selectExact and tonumber(level) ~= l.lvl and app ~= 202 then
              -- Current CBus level does not match the select, so optionally adjust the CBus level
              if logging then log('Warning: Forcing level to set for select '..alias..' to nearest level '..l.lvl..' ('..tonumber(level)..' requested, but selectExact=true)') end
              SetCBusLevel(net, app, group, l.lvl, 0)
              -- Adjusting the level will result in two MQTT publish events, which could be avoided but is not
            end
            client:publish(mqttReadTopic..alias..'/select', l.sel, mqttQoS, RETAIN)
            client:publish(mqttReadTopic..alias..'/level', l.lvl, mqttQoS, RETAIN)
            if logging then log('Publishing select '..mqttReadTopic..alias..' to '..l.sel..' ('..l.lvl..')') end
            break
          end
        end
      elseif button[alias] then -- It's a button, so do nothing as it has no state
      elseif cover[alias] then -- It's a cover, so vary state behaviour based on level translation mode
        if mqttDevices[alias].noleveltranslate then
          client:publish(mqttReadTopic..alias..'/state', state, mqttQoS, RETAIN)
          if level ~= -1 then client:publish(mqttReadTopic..alias..'/level', level, mqttQoS, RETAIN) end
          if logging then log('Publishing state and level '..mqttReadTopic..alias..' to '..state..'/'..level) end
        else
          local v
          if hasMembers(mqttDevices[alias].rate) then
            state = (coverLevel[alias] ~= 0) and 'open' or 'closed'
            v = coverLevel[alias]
          else
            state = (level ~= 0) and 'open' or 'closed'
            v = (level < 0) and 128 or level
          end
          client:publish(mqttReadTopic..alias..'/state', state, mqttQoS, RETAIN)
          client:publish(mqttReadTopic..alias..'/open', v, mqttQoS, RETAIN)
          if logging then log('Publishing state and open '..mqttReadTopic..alias..' to '..state..'/'..v) end
        end
      else -- It's a bog standard group
        local v
        client:publish(mqttReadTopic..alias..'/state', state, mqttQoS, RETAIN)
        if publishAdj[alias] then v = tonumber(string.format('%.'..publishAdj[alias].dec..'f', level * publishAdj[alias].scale)) else v = level end
        client:publish(mqttReadTopic..alias..'/level', v, mqttQoS, RETAIN)
        if logging then log('Publishing state and level '..mqttReadTopic..alias..' to '..state..'/'..v) end
      end
    else -- It's a binary sensor / trigger
      client:publish(mqttReadTopic..alias..'/state', state, mqttQoS, RETAIN)
      client:publish(mqttReadTopic..alias..'/level', level, mqttQoS, RETAIN)
      if logging then log('Publishing '..mqttReadTopic..alias..' to '..state..' ('..level..')') end
    end
  else -- It's a user parameter
    local v
    if publishAdj[alias] then v = tonumber(string.format('%.'..publishAdj[alias].dec..'f', level * publishAdj[alias].scale)) else v = level end
    client:publish(mqttReadTopic..alias..'/level', v, mqttQoS, RETAIN)
    if logging then log('Publishing '..mqttReadTopic..alias..' to '..v) end
  end
  if not noPre then
    if app ~= 202 then -- Not trigger
      local p = level
      if tonumber(level) ~= nil then p = string.format('%.3f', level) end
      storage.set('pre'..alias, p) -- Save payload as 'previous' for use in the MQTT event-based script
    end
  end
end


--[[
Tracking of cover transitions, estimating with time travelled
--]]
local function trackTransitions()
  local k, v
  local t = socket.gettime()
  local kill = {}
  
  for k, v in pairs(transition) do
    if t < v.ts then goto next end
    local closing = v.state == 'closing'
    local rate = closing and tonumber(mqttDevices[k].rate[2]) or tonumber(mqttDevices[k].rate[1])
    local increment = (t - v.ts) / rate * 256
    if closing then v.level = v.level - increment else v.level = v.level + increment end
    coverLevel[k] = math.floor(v.level + 0.5)
    v.ts = t
    if coverLevel[k] < 0 then coverLevel[k] = 0 elseif coverLevel[k] > 255 then coverLevel[k] = 255 end
    if (coverLevel[k] == 0 and closing) or (coverLevel[k] == 255 and not closing) then kill[k] = true end
    client:publish(mqttReadTopic..k..'/state', v.state, mqttQoS, RETAIN)
    client:publish(mqttReadTopic..k..'/open', coverLevel[k], mqttQoS, RETAIN)
    if logging then log('Publishing state and open '..mqttReadTopic..k..' to '..state..'/'..coverLevel[k]) end
    ::next::
  end
  if hasMembers(kill) then storage.set('coverLevel', coverLevel) end
  for k, _ in pairs(kill) do
    client:publish(mqttReadTopic..k..'/state', (coverLevel[k] ~= 0) and 'open' or 'closed', mqttQoS, RETAIN)
    transition[k] = nil
  end
end


--[[
Publish measurement application objects to MQTT 
--]]
local function publishMeasurement(alias, net, group, channel, value, noPre)
  if noPre == nil then noPre = false end
  if value == nil then log('Warning: Nil CBus measurement value for '..alias); do return end end
  local units, v
  local adjust = publishAdj[alias]
  if adjust then v = tonumber(string.format('%.'..adjust.dec..'f', value * adjust.scale)) else v = value end
  if includeUnits[alias] then
    _, units = GetCBusMeasurement(net, group, channel)
    if units == '$' then
      v = units..v
    elseif units == '%' then
      v = v..units
    else
      v = v..' '..units
    end
  end
  local mAlias = lastSlashToUnderscore(alias)
  client:publish(mqttReadTopic..mAlias..'/level', v, mqttQoS, RETAIN)
  if logging then log('Publishing measurement '..mqttReadTopic..mAlias..' to '..v) end
  if not noPre and value ~= nil then
    storage.set('pre'..alias, string.format('%.3f', value))
  end
end


--[[
Publish unit parameter objects to MQTT 
--]]
local function publishUnitParam(alias, value, noPre)
  if noPre == nil then noPre = false end
  if value == nil then log('Warning: Nil unit parameter value for '..alias); do return end end
  local adjust = publishAdj[alias]
  local v
  if adjust then v = tonumber(string.format('%.'..adjust.dec..'f', value * adjust.scale)) else v = value end
  local mAlias = lastSlashToUnderscore(alias)
  client:publish(mqttReadTopic..mAlias..'/level', v, mqttQoS, RETAIN)
  if logging then log('Publishing unit parameter '..mqttReadTopic..mAlias..' to '..v) end
  if not noPre and value ~= nil then
    storage.set('pre'..alias, string.format('%.3f', value))
  end
end


--[[
Publish Panasonic ESPHome objects to MQTT 
--]]
local function publishAc(alias, level, select)
  if level == nil then log('Warning: Nil AC level for '..alias); do return end end
  if ac[alias].state ~= level then
    if ignoreMqtt[alias] and (socket.gettime() - ignoreMqtt[alias] > ignoreTimeout) then -- Don't worry about older 'ignore' flags
      ignoreMqtt[alias] = nil
      if logging then log('Ignoring older MQTT ignore flag for '..alias) end
    end
    if not ignoreMqtt[alias] then
      local parts = string.split(ac[alias].name, '-')
      local topic = ''
      if select == 'func' then
        topic = parts[1]..'/climate/panasonic/'..parts[2]..'/command'
      elseif select == 'sel' then
        topic = parts[1]..'/select/'..parts[2]..'/command'
      elseif select == 'sense' then
        if logging then log('Warning: Not publishing sensor change for alias='..alias) end
      else
        log('Invalid AC command for alias='..alias..', select='..select)
      end
      if topic ~= '' then client:publish(topic, level, mqttQoS, NORETAIN) end
      -- Publishing to MQTT here will result in outstandingMqttMessage() below setting the CBus state for the group.
      -- This is undesired, so ignoreCbus[alias] is used to ensure that the MQTT change received does not set CBus.
      ignoreCbus[alias] = socket.gettime(); if logging then log('Setting ignore CBus for '..alias) end
      if logging then log('Published AC '..ac[alias].name..' to '..level) end
    else
      ignoreMqtt[alias] = nil
      -- if logging then log('Intentionally ignoring MQTT publish for '..alias) end
    end
    ac[alias].state = level
  else
    ignoreMqtt[alias] = nil
    if logging then log('Ignoring MQTT publish for '..alias..' because already at level '..level) end
  end
end


--[[
Publish Airtopia MODBUS objects to MQTT 
--]]
local function publishAt(alias, level)
  if level == nil then log('Warning: Nil AT level for '..alias); do return end end
  if at[alias].state ~= level then
    if ignoreMqtt[alias] and (socket.gettime() - ignoreMqtt[alias] > ignoreTimeout) then -- Don't worry about older 'ignore' flags
      ignoreMqtt[alias] = nil
      if logging then log('Ignoring older MQTT ignore flag for '..alias) end
    end
    if not ignoreMqtt[alias] then
      local parts = string.split(at[alias].name, '-')
      local topic = 'airtopia/'..parts[1]..'/state/'..parts[2]
      local adjust = publishAdj[alias]
      if adjust then level = tonumber(string.format('%.'..adjust.dec..'f', level * adjust.scale)) end
      client:publish(topic, level, mqttQoS, RETAIN)
      -- Publishing to MQTT here will result in outstandingMqttMessage() below setting the CBus state for the group.
      -- This is undesired, so ignoreCbus[alias] is used to ensure that the MQTT change received does not set CBus.
      if level ~= at[alias].state then ignoreCbus[alias] = socket.gettime(); if logging then log('Setting ignore CBus for '..alias) end end
      if logging then log('Published AT '..at[alias].name..' to '..level) end
      -- Determine whether a HomeAssistant state topic needs to be also published
      local st = nil
      local prefix = nil
      local dev = nil
      for k, v in pairs(atDevices) do
        if v == alias then prefix = string.split(k, '-')[1]; st = string.split(k, '-')[2]; break end
      end
      if st == nil then
      elseif st == 'horiz_swing' then
        -- Publish swingha
        local o = atDevices[prefix..'-vert_swing']
        if o ~= nil then
          parts = string.split(o, '/'); local net = tonumber(parts[1]); local group = tonumber(parts[3]); 
          local v = bit.lshift(GetUserParam(net, group), 1)
          local topic = 'airtopia/'..prefix..'/state/swingha'
          local s = bit.bor(tonumber(level), v) + 1
          client:publish(topic, atswings[s], mqttQoS, RETAIN)
        end
      elseif st == 'vert_swing' then
        -- Publish swingha
        local o = atDevices[prefix..'-horiz_swing']
        if o ~= nil then
          parts = string.split(o, '/'); local net = tonumber(parts[1]); local group = tonumber(parts[3]); 
          local h = GetUserParam(net, group)
          local topic = 'airtopia/'..prefix..'/state/swingha'
          local v = bit.lshift(tonumber(level), 1)
          local s = bit.bor(h, v) + 1
          client:publish(topic, atswings[s], mqttQoS, RETAIN)
        end
      elseif st == 'fan' then
        -- Publish fanha
        local fanv = atfans[level+1]
        local topic = 'airtopia/'..parts[1]..'/state/fanha'
        client:publish(topic, fanv, mqttQoS, RETAIN)
      end
    else
      ignoreMqtt[alias] = nil
      if logging then log('Intentionally ignoring MQTT publish for '..alias) end
    end
    at[alias].state = level
  else
    ignoreMqtt[alias] = nil
    if logging then log('Ignoring MQTT publish for '..alias..' because already at level '..level) end
  end
end


--[[
Get level name and value
--]]
local function decodeLevel(net, app, group, level, default)
  if level:contains('/') then log('Error: Legacy separator "/" being used for '..net..'/'..app..'/'..group..'! Use ":" instead') return nil, nil end
  local parts = string.split(level, ':')
  local lvl = -1
  if #parts == 2 then -- A select option and level
    lvl = tonumber(parts[2])
    if lvl == nil then log('Error: Invalid lvl= for '..net..'/'..app..'/'..group..', level "'..parts[2]..'" is probably not numeric') return nil, nil end
    if lvl < 0 or lvl > 255  then log('Error: Invalid lvl= for '..net..'/'..app..'/'..group..', level "'..parts[2]..'" is outside acceptable range') return nil, nil end
    return parts[1], lvl
  elseif #parts == 1 and tonumber(parts[1]) then -- Level numbers only
    lvl = tonumber(parts[1])
    if lvl < 0 or lvl > 255 then log('Error: Invalid lvl= for '..net..'/'..app..'/'..group..', level '..lvl..' is outside acceptable range') return nil, nil end
    parts[1] = GetCBusLevelTag(net, app, group, lvl)
    if parts[1] == nil then
      if default == nil then
        log('Error: No level tag for '..net..'/'..app..'/'..group..', level '..lvl..' which is required when specifying numeric only for lvl=') return nil, nil
      else
        parts[1] = default
        log('Warning: Trigger '..net..'/'..app..'/'..group..' has no level tag defined for level '..level..', setting to "'..default..'"')
      end
    end
    return parts[1], lvl
  elseif #parts == 1 then -- Level tags only
    lvl = GetCBusLevelAddress(net, app, group, parts[1])
    if lvl == nil then log('Error: Invalid lvl= for '..net..'/'..app..'/'..group..', level '..parts[1]) return nil end
    return parts[1], lvl
  end
end


--[[
Get key/value pairs. Returns a keyword if found in 'allow'. (allow, synonym and special parameters are optional).
--]]
local function getKeyValue(alias, tags, _L, synonym, special, allow)
  if synonym == nil then synonym = {} end
  if special == nil then special = {} end
  if allow == nil then allow = {} end
  local dType = nil
  for k, t in pairs(tags) do
    k = k:trim()
    if t ~= -1 then
      if special[k] ~= nil then special[k] = true end
      local v = t:trim()
      if _L[k] then
        if type(_L[k]) == 'number' then _L[k] = tonumber(v) if _L[k] == nil then error('Error: Bad numeric value for '..alias..', keyword "'..k..'="') end
        elseif type(_L[k]) == 'table' then
          _L[k] = string.split(v, '/')
          local i, tv for i, tv in ipairs(_L[k]) do _L[k][i] = tv:trim() end
        else _L[k] = v end
      end
    else
      if synonym[k] then k = synonym[k] end
      if special[k] ~= nil then special[k] = true end
      if allow[k] then
        if dType == nil then dType = k else error('Error: More than one "type" keyword used for '..alias) end
      end
    end
  end
  return dType
end


--[[
Build and publish a CBus MQTT discovery topic
--]]
local function addDiscover(net, app, group, channel, tags, name)
  -- Build an alias to refer to each group
  local alias = net..'/'..app..'/'..group
  if channel ~= nil then alias = alias..'/'..channel end

  if not name then -- Need a name from tag lookup for everything but measurement app
    if channel == nil then
      error('Error: nil channel for name '..str(name)..' at '..net..'/'..app..'/'..group..'... a name is required')
    else
      if app == 228 then name = 'Measurement '..alias else name = 'Unit parameter '..alias end
    end
  end

  -- All keywords except MQTT are optional (some exceptions), with 'light' as default discovery type. Defaults:
  local _L = {
    pn = name,      -- Preferred name
    sa = '',        -- Suggested area
    img = '',       -- Image
    unit = '',      -- Units
    class = '',     -- HomeAssistant class
    dec = 2,        -- Decimal places
    scale = 1,      -- Scale (multiplier or divider)
    on = 'On',      -- bsensor 'on' string
    off = 'Off',    -- bsensor 'off' string
    lvl = {},       -- Levels
    rate = {},      -- Rate of open/close for cover
    delay = 0,      -- Delay before starting cover tracking
  }
  local synonym = { binarysensor = 'binary_sensor', fanpct = 'fan_pct' }
  local special = { includeunit = false, preset = false, dec = false, noleveltranslate = false }

  local lvl = false
  local dType, action, boid, dSa, payload, prefix, tag, k, t

  local function getEntity(entity)
    if _L.sa ~= '' then
      local startIdx, endIdx
      repeat
        startIdx, endIdx = entity:find(_L.sa, 1, true)
        if startIdx and startIdx == 1 then
          entity = entity:sub(endIdx + 1):match'^%s*(.*)'
        end
      until not startIdx or startIdx > 1
    end
    return entity
  end

  local function addCommonPayload(payload, oid, entity)
    -- Add payload common to all
    payload.name = ''
    payload.obj_id = oid
    payload.uniq_id = oid
    payload.avty_t = mqttCbus..'status'
    payload.dev = { name=entity, ids=_L.sa..' '..entity:trim(), sa=_L.sa, mf='Schneider Electric', mdl='CBus' }
    if _L.img ~= '' then payload.ic = _L.img end
    return payload
  end

  local function removeOld(dType, oid)
    -- If dType has changed for an existing discovery topic then remove the previous topic
    local oldDiscovery = discovery[oid]
    if oldDiscovery ~= nil and oldDiscovery ~= dType then
      client:publish(mqttDiscoveryTopic..oldDiscovery..'/'..oid..'/config', '', mqttQoS, RETAIN)
      if logging then log('Removed discovery topic '..mqttDiscoveryTopic..oldDiscovery..'/'..oid..'/config') end
    end
    discovery[oid] = dType
  end

  local function publish(payload, oid, entity)
    -- Publish to MQTT broker
    local j = json.encode(payload)
    if _L.sa == '' then dSa = 'no preferred area' else dSa = _L.sa end
    if logging then log('Publishing '..mqttDiscoveryTopic..dType..'/'..oid..'/config as '.._L.pn..' in area '..dSa) end
    if discoveryName[oid] ~= nil and discoveryName[oid] ~= entity then client:publish(mqttDiscoveryTopic..dType..'/'..oid..'/config', '', mqttQoS, RETAIN) end -- Remove old discovery topic
    client:publish(mqttDiscoveryTopic..dType..'/'..oid..'/config', j, mqttQoS, RETAIN)
  end

  -- Build an OID (measurement application / unit parameter gets a channel as well), also add to mqttDevices
  local oid = 'cbus_mqtt_'..tNetCBus(net)..'_'.. app..'_'..group if channel ~= nil then oid = oid..'_'..channel end
  mqttDevices[alias].oid = oid
  mqttDevices[alias].net = net
  mqttDevices[alias].app = app
  mqttDevices[alias].group = group
  if channel then mqttDevices[alias].channel = channel end

  -- Clear any previous lookup table entries
  cover[alias] = nil
  fan[alias] = nil
  bSensor[alias] = nil
  binarySensor[alias] = nil
  button[alias] = nil
  local oldLightingButton = lightingButton[alias] lightingButton[alias] = nil
  userParameter[alias] = nil
  unitParameter[alias] = nil
  storeLevel[alias] = nil
  for s, _ in pairs(special) do mqttDevices[s] = nil end

  local allow = {
    light = {getPayload = function()
      return {stat_t = mqttReadTopic..alias..'/state', cmd_t = mqttWriteTopic..alias..'/switch', bri_stat_t = mqttReadTopic..alias..'/level', bri_cmd_t = mqttWriteTopic..alias..'/ramp', pl_off = 'OFF', on_cmd_type = 'brightness',}
      end },
    switch = {getPayload = function()
      return {stat_t = mqttReadTopic..alias..'/state', cmd_t = mqttWriteTopic..alias..'/switch', pl_on = 'ON', pl_off = 'OFF',}
      end },
    cover = {getPayload = function()
      cover[alias] = true
      if special.noleveltranslate then
        mqttDevices[alias].noleveltranslate = true
        return {stat_t = mqttReadTopic..alias..'/state', cmd_t = mqttWriteTopic..alias..'/ramp', pos_open = 255, pos_clsd = 0, pl_open = 'OPEN', pl_cls = 'CLOSE', pos_t = mqttReadTopic..alias..'/level', set_pos_t = mqttWriteTopic..alias..'/ramp',}
      else
        mqttDevices[alias].noleveltranslate = false
        if _L.rate[2] == nil then _L.rate[2] = _L.rate[1] end
        mqttDevices[alias].rate = _L.rate
        mqttDevices[alias].delay = _L.delay
        if not hasMembers(_L.rate) then log('Warning: No cover open/cose rate specified for '..alias..'. Transition tracking disabled.') end
        if coverLevel[alias] == nil then coverLevel[alias] = grp.getvalue(alias) log('Warning: Initialising cover level for '..alias..' with '..grp.getvalue(alias)..'. This may not be correct.') end
        return {stat_t = mqttReadTopic..alias..'/state', cmd_t = mqttWriteTopic..alias..'/ramp', pos_open = 255, pos_clsd = 0, pl_open = 'OPEN', pl_cls = 'CLOSE', pos_t = mqttReadTopic..alias..'/open', set_pos_t = mqttWriteTopic..alias..'/ramp',}
      end
      end },
    fan = {getPayload = function() fan[alias] = true storeLevel[alias] = true return {
      pl_on = 'ON', pl_off = 'OFF',
      stat_t = mqttReadTopic..alias..'/state', cmd_t = mqttWriteTopic..alias..'/ramp',
      pr_modes = {'off', 'low', 'medium', 'high'},
      pr_mode_cmd_t = mqttWriteTopic..alias..'/ramp', pr_mode_cmd_tpl = '{% if value == "off" %} 0 {% elif value == "low" %} 86 {% elif value == "medium" %} 170 {% elif value == "high" %} 255 {% endif %}',
      pr_mode_stat_t = mqttReadTopic..alias..'/level', pr_mode_val_tpl = '{% if value | int == 0 %} off {% elif value | int == 86 %} low {% elif value | int == 170 %} medium {% elif value | int == 255 %} high {% endif %}',
    } end },
    fan_pct = {getPayload = function()
      dType = 'fan' fan[alias] = true storeLevel[alias] = true local payload = {
      pl_on = 'ON', pl_off = 'OFF',
      stat_t = mqttReadTopic..alias..'/state', cmd_t = mqttWriteTopic..alias..'/ramp',
      pct_cmd_t = mqttWriteTopic..alias..'/ramp', pct_cmd_tpl = '{% if value | int == 0 %} 0 {% elif value | int == 1 %} 86 {% elif value | int == 2 %} 170 {% elif value | int == 3 %} 255 {% endif %}',
      pct_stat_t = mqttReadTopic..alias..'/level', pct_val_tpl = '{% if value | int == 0 %} 0 {% elif value | int == 86 %} 1 {% elif value | int == 170 %} 2 {% elif value | int == 255 %} 3 {% endif %}',
      spd_rng_min = 1,
      spd_rng_max = 3,
      opt = false,
      }
      if special.preset then
        payload.pr_modes = {'off', 'low', 'medium', 'high'}
        payload.pr_mode_cmd_t = mqttWriteTopic..alias..'/ramp'
        payload.pr_mode_cmd_tpl = '{% if value == "off" %} 0 {% elif value == "low" %} 86 {% elif value == "medium" %} 170 {% elif value == "high" %} 255 {% endif %}'
        payload.pr_mode_stat_t = mqttReadTopic..alias..'/level'
        payload.pr_mode_val_tpl = '{% if value | int == 0 %} off {% elif value | int == 86 %} low {% elif value | int == 170 %} medium {% elif value | int == 255 %} high {% endif %}'
      end
      return payload
    end },
    sensor = {getPayload = function()
      local payload
      local str = false
      if channel ~= nil then payload = { stat_t = mqttReadTopic..net..'/'..app..'/'..group..'_'..channel..'/level', } else payload = { stat_t = mqttReadTopic..alias..'/level', } end
      if lighting[tostring(app)] and not special.dec then _L.dec = 0 end
      if _L.class ~= '' then payload.dev_cla = _L.class end
      if app == 250 then userParameter[alias] = true end
      if app == 255 then unitParameter[alias] = true end
      if #_L.lvl == 0 then
        if app == 250 then _, _ = pcall(function () if tonumber(GetUserParam(net, group)) ~= nil then payload.val_tpl = '{{ value | float | round ('.._L.dec..') }}' end end)
        else payload.val_tpl = '{{ value | float | round ('.._L.dec..') }}'
        end
        if not payload.val_tpl then str = true end
      else
        str = true
        local count = 0
        local tpl
        for _, level in ipairs(_L.lvl) do
          local tag, lvl = decodeLevel(net, app, group, level)
          if tag ~= nil then
            if count == 0 then tpl = '{% if value | float == '..lvl..' %}'..tag else tpl = tpl..'{% elif value | float == '..lvl..' %}'..tag end
            count = count + 1
          else
            return nil
          end
        end
        payload.val_tpl = tpl..'{% else %}Unknown{% endif %}'
      end
      if _L.dec ~= 2 or _L.scale ~= 1 then publishAdj[alias] = { dec = _L.dec, scale = _L.scale } end -- Scale, decimals and units only for sensors
      if _L.unit ~= '' and not special.includeUnit then payload.unit_of_meas = _L.unit else if not str then payload.unit_of_meas = '' end end
      return payload
      end },
    binary_sensor = {getPayload = function()
      binarySensor[alias] = true
      return {stat_t = mqttReadTopic..alias..'/state', pl_on = 'ON', pl_off = 'OFF',}
      end },
    bsensor = {getPayload = function()
      bSensor[alias] = true dType = 'sensor'
      return {stat_t = mqttReadTopic..alias..'/level', val_tpl = '{% if value | float == 0 %} '.._L.off..' {% else %} '.._L.on..' {% endif %}',}
      end },
    button = {getPayload = function()
      button[alias] = true
      if lighting[tostring(app)] then
        lightingButton[alias] = true
        return {cmd_t = mqttWriteTopic..alias..'/press',}
      elseif app == 202 then
        local i
        mqttDevices[alias].trigger = {}
        mqttDevices[alias].type = 'button'
        if #_L.lvl == 0 then for i = 0,255 do _L.lvl[#_L.lvl + 1] = i end end -- If no "lvl=" specified then scan all levels, which is most inefficient!
        for _, i in ipairs(_L.lvl) do
          local tag, lvl = decodeLevel(net, app, group, i, publishNoLevel and 'Level '..i or nil)
          if tag then
            boid = oid..'_'..lvl
            table.insert(mqttDevices[alias].trigger, boid)
            action = tag:gsub("%s+", "_"):lower() -- Replace spaces with underscores
            if triggers[group] == nil then triggers[group] = {} end
            triggers[group][action] = lvl
            if _L.pn == name then prefix = '' else prefix = _L.pn..' ' end
            local entity = getEntity(prefix..tag)
            payload = addCommonPayload({ cmd_t = mqttWriteTopic..alias..'/'..action..'/press', }, boid, entity)
            removeOld(dType, boid)
            publish(payload, boid, entity)
          end
        end
        return 'buttons'
      else
        log('Warning: MQTT button keyword used for unsupported application group '..alias)
        return nil
      end
      end },
    select = {getPayload = function()
      if #_L.lvl == 0 then log('Error: lvl= keyword not specified for select at '..alias..', which is required') return nil end
      local level
      local options = {}
      selects[alias] = {}
      for _, level in ipairs(_L.lvl) do
        local opt, sel = decodeLevel(net, app, group, level)
        if opt ~= nil then
          options[#options + 1] = opt
          selects[alias][opt] = sel
          if not selects[alias].allLvl then selects[alias].allLvl = {} end; selects[alias].allLvl[#selects[alias].allLvl + 1] = { lvl = sel, sel = opt }
        else
          return nil
        end
      end
      table.sort(selects[alias].allLvl, function (left, right) return left.lvl < right.lvl end)
      return {stat_t = mqttReadTopic..alias..'/select', cmd_t = mqttWriteTopic..alias..'/select', options = options,}
      end },
  }

  -- Extract MQTT topic settings
  dType = getKeyValue(alias, tags, _L, synonym, special, allow)
  if dType == nil then dType = 'light' end -- Use light as default HomeAssistant type if not specified
  
  -- Default images for a lighting group
  if _L.img == '' and lighting[tostring(app)] then
    local pnl = _L.pn:lower()
    for k, v in pairs(imgDefault) do
      if pnl:contains(k) then
        if type(v) == 'string' then _L.img = v
        else
          local ik, iv, theElse
          for ik, iv in pairs(v) do if ik ~= '#else' then if pnl:contains(ik) then _L.img = iv end else theElse = v['#else'] end end
          if _L.img == '' then _L.img = theElse end
        end
      end
    end
    if _L.img == '' then _L.img = 'mdi:lightbulb' end
  end

  if dType == 'light' and app == 228 then dType = 'sensor'; log('Warning: publishing measurement app '..alias..' as a sensor, not light') end -- Measurement app sensor with incorrect/missing type
  if special.includeUnit then includeUnits[alias] = true if logging then log('Including units for '..alias) end else includeUnits[alias] = nil end

  payload = allow[dType].getPayload()

  if payload ~= nil and payload ~= 'buttons' then -- If payload recieved then publish
    mqttDevices[alias].type = dType
    local entity = getEntity(_L.pn)
    payload = addCommonPayload(payload, oid, entity)
    removeOld(dType, oid)
    publish(payload, oid, entity)
    if not oldLightingButton and lightingButton[alias] then -- If changing to a lighting button then clear status topics
      local t = mqttReadTopic..alias..'/state'
      if mqttJunk then client:publish(t, 'junk', mqttQoS, RETAIN) end client:publish(t, '', mqttQoS, RETAIN)
      t = mqttReadTopic..alias..'/level'
      if mqttJunk then client:publish(t, 'junk', mqttQoS, RETAIN) end client:publish(t, '', mqttQoS, RETAIN)
    end
    return
  elseif payload == 'buttons' then
    -- Trigger app buttons have already been published, so do nothing
  else
    mqttDevices[alias] = nil
    error('Warning: a publish payload for '..name..' could not be built, so not published')
  end
end


--[[
Build and publish an Airtopia discovery topic
--]]
local function addAtDiscover(name, sa, unit)
  local dSa, payload

  if sa == '' then dSa = 'no preferred area' else dSa = sa end
  if logging then log('Publish discovery '..name..' in area '..dSa) end

  -- Build an OID and name prefix
  local sao = ''; if sa ~= '' then sao = string.lower(sa:gsub("% ", "_"))..'_' end
  local oid = 'cbus_mqtt_'..sao..string.lower(name:gsub("% ", "_"))

  payload = {
    name = '',
    obj_id = oid,
    uniq_id = oid,
    avty_t = mqttCbus..'status',
    dev = { name=name, ids=sa..' '..name, sa=sa, mf='Schneider Electric', mdl='Airtopia' },
    mode_cmd_t = 'airtopia/'..sao..name..'/cmd/mode',
    mode_stat_t = 'airtopia/'..sao..name..'/state/modeha',
    pow_cmd_t = 'airtopia/'..sao..name..'/cmd/power',
    temp_cmd_t = 'airtopia/'..sao..name..'/cmd/target_temperature',
    temp_stat_t = 'airtopia/'..sao..name..'/state/target_temperature',
    curr_temp_t = 'airtopia/'..sao..name..'/state/current_temperature',
    swing_modes = atswings,
    swing_mode_cmd_t = 'airtopia/'..sao..name..'/cmd/swing',
    swing_mode_stat_t = 'airtopia/'..sao..name..'/state/swingha',
    fan_modes = atfans,
    fan_mode_cmd_t = 'airtopia/'..sao..name..'/cmd/fan',
    fan_mode_stat_t = 'airtopia/'..sao..name..'/state/fanha',
    temp_unit = "C",
    opt = false,
    pl_on = 'ON',
    pl_off = 'OFF',
    precision = 1.0,
  }

  -- Publish to MQTT broker
  local j = json.encode(payload)
  if logging then log('Publishing '..mqttDiscoveryTopic..'climate/'..oid..'/config') end
  client:publish(mqttDiscoveryTopic..'climate/'..oid..'/config', j, mqttQoS, RETAIN)

  -- Add a power consumption sensor discovery topic
  if unit == nil then unit = 'A' end
  payload = {
    name = '',
    obj_id = oid..'_power',
    uniq_id = oid..'_power',
    avty_t = mqttCbus..'status',
    dev = { name=name..' Power Consumption', ids=sa..' '..name..' Power Consumption', sa=sa, mf='Schneider Electric', mdl='Airtopia' },
    stat_t = 'airtopia/'..sao..name..'/state/power_consumption',
    unit_of_meas = unit,
  }
  local j = json.encode(payload)
  if logging then log('Publishing'..mqttDiscoveryTopic..'sensor/'..oid..'_power'..'/config') end
  client:publish(mqttDiscoveryTopic..'sensor/'..oid..'_power'..'/config', j, mqttQoS, RETAIN)
end


--[[
Add Airtopia objects 
--]]
local atLog = {}
local atLogGrp = {}
local function addAt(grps, found)
  local atArea = {}
  local atDevs = {}
  local alias, k, v
  local addition = false
  local scan = {}
  local found = {}
  local stat, err

  for alias, v in pairs(grps) do
    local _L = { sa = '', dev = '', func = '', sense = '', unit = 'A', scale = 1, decimals = 2, }
    getKeyValue(alias, v.tags, _L)
    if _L.dev ~= '' then atDevs[_L.dev] = true end
    if atArea[_L.dev] == nil and _L.sa ~= '' then
      atArea[_L.dev] = _L.sa  -- The suggested area found is noted as being applicable for all user params of the device; only one needs be tagged
      atLog[_L.dev] = nil
    end

    if _L.sense ~= '' then
      if _L.scale ~= 1 or _L.decimals ~= 2 then publishAdj[alias] = { dec=_L.decimals, scale=_L.scale } end
    end
    scan[alias] = { dev=_L.dev, func=_L.func, sense=_L.sense, unit=_L.unit, net=v.net, app=v.app, group=v.group }
  end

  for alias, v in pairs(scan) do
    if v.dev ~= '' then
      if atLog[v.dev] == nil and atArea[v.dev] == nil then
        log('Error: No suggested area set for Airtopia device '..v.dev..'. At least one user parameter needs "sa="')
        atLog[v.dev] = true -- Logged for the device, so do not log any further related user param issues for the device
        goto nextAt
      end
      if at[alias] == nil and atArea[v.dev] ~= nil then
        local sa = atArea[v.dev]; if sa == nil then sa = '' end
        local sao = ''; if sa ~= '' then sao = string.lower(sa:gsub("% ", "_"))..'_' end
        if v.func ~= '' then
          if not at[alias] then
            at[alias] = {}; addition = true
            at[alias].name = sao..v.dev..'-'..v.func; at[alias].select = 'func'; atDevices[sao..v.dev..'-'..v.func] = alias;
            if atBoards[sao..v.dev] == nil and v.func == 'power' then atBoards[sao..v.dev] = {alias=alias, dev=v.dev, sa=sa} end
            stat, err = pcall(publishAt, alias, GetUserParam(v.net, v.group)) if not stat then log(err) end
            atLog[v.dev] = nil
            atLogGrp[alias] = nil
          end
        elseif sense ~= '' then
          if not at[alias] then
            if atBoards[sao..v.dev] ~= nil then
              at[alias] = {}; addition = true
              at[alias].name = sao..v.dev..'-'..v.sense; at[alias].select = 'sense'; at[alias].sense = v.sense; atDevices[sao..v.dev..'-'..v.sense] = alias
              atBoards[sao..v.dev].unit = v.unit
              stat, err = pcall(publishAt, alias, GetUserParam(v.net, v.group)) if not stat then log(err) end
              atLog[v.dev] = nil
              atLogGrp[alias] = nil
            end
          end
        end
      end
    else
      if not atLogGrp[alias] then log('Error: No device specified for Airtopia group '..alias); atLogGrp[alias] = true end
    end
    ::nextAt::
    if at[alias] ~= nil and atArea[v.dev] ~= nil then
      found[alias] = true -- Valid, having a sa=, so found (otherwise removed elsewhere if an existing device)
    end
  end
  return addition, found
end


--[[
Get applicable groups and keywords
--]]
local function getGroups(kw)
  local t
  local grps = {}
  for _, t in ipairs(db:getall("SELECT o.address, o.tagcache, o.name FROM objects AS o JOIN objecttags AS ot ON o.id=ot.object WHERE ot.tag='"..kw.."'")) do
    local alias = knxlib.decodega(t.address)
    local parts = load("return {"..alias:gsub('/',',').."}")()
    grps[alias] = { tags = {}, name = t.name, keywords = t.tagcache:gsub(', ',','), net = parts[1], app = parts[2], group = parts[3], channel = parts[4], }
    if parts[2] == 228 then -- Get the measurement app channel name from the CBus tag map
      local resp = db:getall('SELECT tag FROM cbus_tag_map WHERE tagtype="S" AND net='..parts[1]..' AND app='..parts[2]..' AND grp='..parts[3]..' AND tagid='..parts[4])
      if resp ~= nil and resp[1] ~= nil and resp[1]['tag'] ~= nil then grps[alias].name = resp[1]['tag'] else grps[alias].name = alias end
    end
    local tags = {}
    local tg
    for _, tg in ipairs(grps[alias].keywords:split(',')) do
      parts = tg:split('=')
      if parts[2] then tags[parts[1]:trim()] = parts[2]:trim() else tags[parts[1]:trim()] = -1 end
    end
    grps[alias].tags = tags
  end
  return grps
end


--[[
Queue up initial discovery and current state CBus objects, plus Airtopia if used
--]]
local function publishCurrent()
  -- CBus
  mqttDevices = {}
  local grps = getGroups('MQTT')
  local n = 0
  local i, k, v, alias, name
  for alias, v in pairs(grps) do
    n = n + 1
    if v.name then name = v.name else
      if v.app ~= 228 then
        name = GetCBusGroupTag(v.net, v.app, v.group)
      else
        name = nil
      end
    end
    unpublished[n] = {net=v.net, app=v.app, group=v.group, channel=v.channel, tags=v.tags, name=name}
    if not mqttDevices[alias] then mqttDevices[alias] = {}; mqttDevices[alias].tags = v.tags; mqttDevices[alias].keywords = removeIrrelevant(v.keywords) end
  end
  if n > 0 then if logging then log('Queued '..n..' objects with keyword MQTT for publication') end end

  if airtopiaSupport then
    atDevices = {}
    grps = getGroups('AT')
    addAt(grps)
    local raw = {}
    local dev
    for alias, v in pairs(grps) do
      dev = ''; local sa = nil; local vv
      for tag, vv in pairs(v.tags) do
        if tag == 'dev' then
          dev = vv
        elseif tag == 'sa' then
          sa = vv
        end
      end
      if dev ~= '' then
        if sa ~= nil then raw[dev] = sa end
      else
        if not atLogGrp[alias] then
          log('Error: No device specified for Airtopia group '..alias)
          atLogGrp[alias] = true
        end
      end
    end
    n = 0
    for k, v in pairs(raw) do
      n = n + 1
      unpublishedAt[n] = {name=k, sa=v}
    end
    if n > 0 then if logging then log('Queued '..n..' objects with keyword AT for publication') end end
  end
end


--[[
Create / update / delete AC devices
--]]
local acLogGrp = {}
local function cudAc()
  local nClock = socket.gettime()
  local grps = getGroups('AC')
  local found = {}
  local addition = false
  local count = 0
  local alias, k, v, kill

  for alias, v in pairs(grps) do
    found[alias] = true

    local _L = { dev = '', func = '', sel = '', sense = '', topic = 'sensor', }
    getKeyValue(alias, v.tags, _L)

    if _L.dev ~= '' then
      if _L.func ~= '' then
        if not ac[alias] then ac[alias] = {} addition = true count = count + 1 end
      	ac[alias].name = _L.dev..'-'.._L.func; ac[alias].select = 'func'; acDevices[_L.dev..'-'.._L.func] = alias; acBoards[_L.dev] = true
      elseif _L.sel ~= '' then
        if not ac[alias] then ac[alias] = {} addition = true count = count + 1 end
      	ac[alias].name = _L.dev..'-'.._L.sel; ac[alias].select = 'sel'; acDevices[_L.dev..'-'.._L.sel] = alias; acBoards[_L.dev] = true
      elseif _L.sense ~= '' then
        if not ac[alias] then ac[alias] = {} addition = true count = count + 1 end
      	ac[alias].name = _L.dev..'-'.._L.sense; ac[alias].select = 'sense'; ac[alias].sense = _L.sense; ac[alias].topic = _L.topic; acDevices[_L.dev..'-'.._L.sense..'-sense'] = alias; acBoards[_L.dev] = true; acSense[_L.dev..'-'.._L.sense] = alias
      end
      ac[alias].net = v.net
      ac[alias].group = v.group
      acLogGrp[alias] = nil
    else
      if not acLogGrp[alias] then log('Error: No device specified for Panasonic '..alias); acLogGrp[alias] = true end
    end
  end

  -- Handle deletions
  local removed = 0
  for k, _ in pairs(ac) do
    if not found[k] then
      local name if ac[k].select == 'sense' then name = ac[k].name..'-sense' else name = ac[k].name end
      log('Removing '..k..' AC '..name) kill = name; ac[k] = nil; acDevices[kill] = nil removed = removed + 1
    end
  end
  if removed > 0 then
    log('Removed '..removed..' Panasonic A/C object'..(removed ~= 1 and 's' or '')..(logms and ' in '..string.format('%.3f', socket.gettime()-nClock)..' seconds' or '')..', event script \''..acName..'\' restarted')
    script.disable(acName); script.enable(acName)
  end
  -- Handle additions, and re-subscribe all board topics to get status of newly added devices
  if addition then
    for k, _ in pairs(acBoards) do client:subscribe(k..'/#', 2) end
    if acName then
      log('Added '..count..' Panasonic A/C object'..(count ~= 1 and 's' or '')..(logms and ' in '..string.format('%.3f', socket.gettime()-nClock)..' seconds' or '')..', event script \''..acName..'\' restarted')
      -- Ensure that newly tagged/removed groups with the AC keyword send updates.
      script.disable(acName); script.enable(acName)
    else
      error('Panasonic A/C event script \'AC\' not found')
    end
  end
end


--[[
Publish the state of Airtopia devices
--]]
local function publishAtState()
  local k
  for k, _ in pairs(atBoards) do
    local parts, topic, level
    local mode = atDevices[k..'-mode']
    local power = atDevices[k..'-power']
    if mode ~= nil and power ~= nil then
      parts = string.split(mode, '/'); local mnet = tonumber(parts[1]); local mgroup = tonumber(parts[3])
      parts = string.split(power, '/'); local pnet = tonumber(parts[1]); local pgroup = tonumber(parts[3])
      topic = 'airtopia/'..k..'/state/modeha'
      if GetUserParam(pnet, pgroup) == 0 then
        level = 'off'
      else
        level = atmodes[GetUserParam(mnet, mgroup)]
      end
      client:publish(topic, level, mqttQoS, RETAIN)
    end
    local hswing = atDevices[k..'-horiz_swing']
    local vswing = atDevices[k..'-vert_swing']
    if hswing ~= nil and vswing ~= nil then
      parts = string.split(hswing, '/'); local hnet = tonumber(parts[1]); local hgroup = tonumber(parts[3])
      parts = string.split(vswing, '/'); local vnet = tonumber(parts[1]); local vgroup = tonumber(parts[3])
      topic = 'airtopia/'..k..'/state/swingha'
      local h = GetUserParam(hnet, hgroup)
      local v = bit.lshift(GetUserParam(vnet, vgroup), 1)
      local s = bit.bor(h, v) + 1
      client:publish(topic, atswings[s], mqttQoS, RETAIN)
    end
    local fan = atDevices[k..'-fan']
    if fan ~= nil then
      parts = string.split(fan, '/'); local fnet = tonumber(parts[1]); local fgroup = tonumber(parts[3])
      topic = 'airtopia/'..k..'/state/fanha'
      local f = GetUserParam(fnet, fgroup)
      client:publish(topic, atfans[f+1], mqttQoS, RETAIN)
    end
    client:subscribe('airtopia/'..k..'/#', 2)
  end
end


--[[
Create / update / delete Airtopia devices
--]]
local function cudAt()
  local grps = getGroups('AT')
  local boards = copy(atBoards)
  local k, v, topic, kill
  unpublishedAt = {}

  local addition, found = addAt(grps)

  -- Handle deletions
  for k, _ in pairs(at) do
    if not found[k] then kill = at[k].name; at[k] = nil; atDevices[kill] = nil end
  end
  local newBoards = {}
  for k, _ in pairs(atDevices) do
    local parts = string.split(k, '-')
    newBoards[parts[1]] = true
  end
  kill = {} for k, _ in pairs(atBoards) do if newBoards[k] == nil then table.insert(kill, k) end end
  for _, k in ipairs(kill) do
    atBoards[k] = nil;
    -- Clean up discovery topics
    topic = mqttDiscoveryTopic..'climate/'..'cbus_mqtt_'..k..'/config'; client:publish(topic, '', mqttQoS, RETAIN) log('Removed discovery topic '..topic)
    topic = mqttDiscoveryTopic..'sensor/'..'cbus_mqtt_'..k..'_power/config'; client:publish(topic, '', mqttQoS, RETAIN) log('Removed discovery topic '..topic)
    -- Clean up state and cmd topics under airtopia/device
    for _, v in ipairs(airtopiaStates) do client:publish('airtopia/'..k..'/state/'..v, '', mqttQoS, RETAIN) end
    for _, v in ipairs(airtopiaCmds) do client:publish('airtopia/'..k..'/cmd/'..v, '', mqttQoS, RETAIN) end
    log('Removed device command and state topics')
  end

  -- Handle additions
  local n = 0
  for k, v in pairs(atBoards) do
    if boards[k] == nil then
      if v.sa ~= nil then
        n = n + 1
        unpublishedAt[n] = {name=v.dev, sa=v.sa, unit=v.unit}
        addition = true
      else
        log('Error publishing Airtopia '..k..'. No suggested area given')
      end
    end
  end

  if addition then
    if atName then
      -- Ensure that newly tagged/removed groups with the AT keyword send updates.
      log('AT object keywords added, restarting event script')
      script.disable(atName); script.enable(atName)
    else
      error('Airtopia event script \'AT\' not found')
    end
  end
end


--[[
Create / update / delete ENV (environment) devices
--]]
local envLogGrp = {}
local function cudEnv()
  local nClock = socket.gettime()
  local grps = getGroups('ENV')
  local found = {}
  local addition = false
  local count = 0
  local alias, k, v, kill

  for alias, v in pairs(grps) do
    found[alias] = true

    local _L = { dev = '', func = '', }
    getKeyValue(alias, v.tags, _L)

    if _L.dev ~= '' then
      if _L.func == '' then
        local n
        if v.name then n = v.name else n = GetCBusGroupTag(v.net, v.app, v.group) end
        _L.func = n:lower():gsub("%s+", "_")
      end
      if not env[alias] then env[alias] = {}; addition = true count = count + 1 end
      env[alias].name = _L.dev..'-'.._L.func; envDevices[_L.dev..'-'.._L.func] = {v.net, v.group, alias}; envBoards[_L.dev] = true
      envLogGrp[alias] = nil
    else
      if not envLogGrp[alias] then log('Error: No device specified for environment sensor '..alias); envLogGrp[alias] = true end
    end
  end

  -- Handle deletions
  local removed = 0
  for k, _ in pairs(env) do
    if not found[k] then kill = env[k].name; env[k] = nil; envDevices[kill] = nil; removed = removed + 1 end
  end
  if removed > 0 then
    log('Removed '..removed..' environment sensor object'..(removed ~= 1 and 's' or '')..(logms and ' in '..string.format('%.3f', socket.gettime()-nClock)..' seconds' or ''))
  end
  -- Handle additions, and re-subscribe all board topics to get status of newly added devices
  if addition then
    for k, _ in pairs(envBoards) do client:subscribe(k..'/#', 2) end
    log('Added '..count..' environment sensor object'..(count ~= 1 and 's' or '')..(logms and ' in '..string.format('%.3f', socket.gettime()-nClock)..' seconds' or ''))
  end
end


--[[
Create / update / delete CBus MQTT discovery topics
--]]
local function cudCBusTopics()
  local function difference(a, b)
    local aa = {}; for _, v in ipairs(a) do aa[v] = true end; for _, v in ipairs(b) do aa[v] = nil end
    local ret = {}; for _, v in ipairs(a) do if aa[v] then ret[#ret+1]=v end end
    return ret
  end

  unpublished = {}
  local nClock = socket.gettime()
  local grps = getGroups('MQTT')
  local found, lvlDelete, queued = {}, {}, {}
  local n = 0
  local k, v, alias, lvl, olvl, name

  for alias, v in pairs(grps) do
    local change = false

    found[alias] = true
    local curr = removeIrrelevant(v.keywords)

    if not mqttDevices[alias] then -- New group
      change = true
      mqttDevices[alias] = {}
      mqttDevices[alias].keywords = curr
    else
      if mqttDevices[alias].keywords ~= curr then -- Modified group
        if v.app == 202 then
          lvl = nil
          if v.tags.lvl then
            lvl = {} local l local p = string.split(v.tags.lvl, '/')
            for _, l in ipairs(p) do _, lvl[#lvl+1] = decodeLevel(v.net, v.app, v.group, l) end
          end
          if lvl ~= nil then -- Check for levels being changed
            olvl = {}
            if mqttDevices[alias].tags.lvl then
              olvl = {} local l local p = string.split(mqttDevices[alias].tags.lvl, '/')
              for _, l in ipairs(p) do _, olvl[#olvl+1] = decodeLevel(v.net, v.app, v.group, l) end
            end
            local diff = difference(olvl, lvl)
            if #diff > 0 then lvlDelete[alias] = diff end
            if len(lvl) > len(olvl) then change = true end
          else
            change = true
          end
        else
          change = true
        end
        mqttDevices[alias].tags = v.tags
        mqttDevices[alias].keywords = curr
      end
    end
    if change then
      if v.name then name = v.name else name = GetCBusGroupTag(v.net, v.app, v.group) end
      n = n + 1
      unpublished[n] = {net=v.net, app=v.app, group=v.group, channel=v.channel, tags=v.tags, name=name}
      queued[#queued + 1] = alias
    end
  end
  if n > 0 then log('Queued '..n..' object'..(n ~= 1 and 's' or '')..' with keyword MQTT for publication: '..table.concat(queued, ', ')) end

  -- Handle deletions
  local kill = {}
  for alias, v in pairs(mqttDevices) do
    local topic, oid, trigger
    if not found[alias] then
      table.insert(kill, alias)
      if v.app == 202 and v.type == 'button' then
        for _, trigger in ipairs(v.trigger) do
          topic = mqttDiscoveryTopic..v.type..'/'..trigger..'/config'
      	  client:publish(topic, '', mqttQoS, RETAIN); log('Removed discovery topic '..topic)
          local t = tonumber(string.match(trigger, '_(%w+)$'))
          local act, tk, tv
          for tk, tv in pairs(triggers[v.group]) do
            if t == tv then act = tk break end
          end
          t = mqttWriteTopic..alias..'/'..act..'/press'
          if mqttJunk then client:publish(t, 'junk', mqttQoS, RETAIN) end -- Publish junk to all topics to be deleted to ensure that they are actually deleted (some topics may not have been written yet)
          client:publish(t, '', mqttQoS, RETAIN)
        end
      else
        topic = mqttDiscoveryTopic..v.type..'/'..v.oid..'/config'
      	client:publish(topic, '', mqttQoS, RETAIN); log('Removed discovery topic '..topic)
        local count
        _, count = alias:gsub('/','')
        if count == 3 then -- Measurement application
          topic = mqttReadTopic..lastSlashToUnderscore(alias)
        else
          topic = mqttReadTopic..alias
        end
        if mqttJunk then client:publish(topic..'/state', 'junk', mqttQoS, RETAIN) end
        client:publish(topic..'/state', '', mqttQoS, RETAIN)
        if mqttJunk then client:publish(topic..'/level', 'junk', mqttQoS, RETAIN) end
        client:publish(topic..'/level', '', mqttQoS, RETAIN)
        if v.type == 'select' then
          if mqttJunk then client:publish(topic..'/select', 'junk', mqttQoS, RETAIN) end
          client:publish(topic..'/select', '', mqttQoS, RETAIN)
        end
        includeUnits[alias] = nil
      end
    else
      -- Handle trigger level removal
      if lvlDelete[alias] ~= nil and triggers[v.group] then
        for _, lvl in ipairs(lvlDelete[alias]) do
          local a, i, t, act = nil
          for a, t in pairs(triggers[v.group]) do if t == lvl then act = a; break end end
          local remove = nil
          if act then
            trigger = nil
            for i, t in ipairs(v.trigger) do if lvl == tonumber(string.match(t, '_(%w+)$')) then trigger = t; remove = i; break end end
            if trigger then
              topic = mqttDiscoveryTopic..v.type..'/'..trigger..'/config'
              client:publish(topic, '', mqttQoS, RETAIN); log('Remove discovery topic for '..topic..' (trigger level '..lvl..')')
              t = mqttWriteTopic..alias..'/'..act..'/press'
              if mqttJunk then client:publish(t, 'junk', mqttQoS, RETAIN) end -- Publish junk to topic to be deleted (some topics may not have been written yet)
              client:publish(t, '', mqttQoS, RETAIN)
              triggers[v.group][act] = nil
            end
            if remove then table.remove(v.trigger, remove) end
          end
        end
      end
    end
  end
  for _, k in ipairs(kill) do mqttDevices[k] = nil end
  if logging then log('cudCBusTopics() completed in '..string.format('%.3f', socket.gettime()-nClock)..' seconds') end
end


--[[
Publish queued CBus discovery topics
--]]
local function outstandingPublish()
  local nClock = socket.gettime()
  local u
  local failed = 0
  local stat, err

  for _, u in ipairs(unpublished) do
    stat, err = pcall(addDiscover, u.net, u.app, u.group, u.channel, u.tags, u.name)
    if not stat then
      failed = failed + 1
      log(err)
    end
    -- Publish current levels
    local alias = u.net..'/'..u.app..'/'..u.group
    -- Measurement application
    if u.app == 228 then
      alias = alias..'/'..u.channel
      local level = nil; pcall(function () level = GetCBusMeasurement(u.net, u.group, u.channel) end)
      if level ~= nil then stat, err = pcall(publishMeasurement, alias, u.net, u.group, u.channel, level, true) if not stat then log(err) end end
    -- User parameters
    elseif u.app == 250 then stat, err = pcall(publish, alias, u.app, GetUserParam(u.net, u.group), true) if not stat then log(err) end
    -- Unit parameters
    elseif u.app == 255 then
      alias = alias..'/'..u.channel
      local level = nil; pcall(function () level = GetUnitParameter(u.net, u.group, u.channel) end)
      if level ~= nil then stat, err = pcall(publishUnitParam, alias, level, true) if not stat then log(err) end end
    -- Lighting and other
    else
      if not lightingButton[u.net..'/'..u.app..'/'..u.group] then -- Do nothing for lighting buttons
        local level = nil;
        if u.app == 202 then
          pcall(function () level = GetTriggerLevel(u.group) end)
        else
          pcall(function () level = GetCBusLevel(u.net, u.app, u.group) end)
        end
        if level ~= nil then stat, err = pcall(publish, alias, u.app, level, true) if not stat then log(err) end end
      end
    end
  end
  storage.set('storeLevel', storeLevel)
  if #unpublished > 0 then
    -- Ensure that newly tagged/removed groups with the MQTT keyword send updates
    local scriptName
    if eventInstalled then if script.status(eventName) ~= nil then scriptName = eventName end end
    if finalInstalled then if script.status(finalName) ~= nil then scriptName = finalName end end
    script.disable(scriptName); script.enable(scriptName)
    log('Published '..#unpublished - failed..' CBus discovery and current level topic'..(#unpublished - failed ~= 1 and 's' or '')..(logms and ' in '..string.format('%.3f', socket.gettime()-nClock)..' seconds' or '')..(failed ~= 0 and ' ('..failed..' failed)' or '')..', event script \''..scriptName..'\' restarted')
    unpublished = {}
  end
end


--[[
Publish queued Airtopia topics
--]]
local function outstandingAtPublish()
  local nClock = socket.gettime()
  local u
  local failed = 0
  local stat, err

  for _, u in ipairs(unpublishedAt) do
    stat, err = pcall(addAtDiscover, u.name, u.sa, nil)
    if not stat then
      failed = failed + 1
      log(err)
    end
  end
  if #unpublishedAt > 0 then
    if atName then
      -- Ensure that newly tagged/removed groups with the AT keyword send updates
      if script.status(atName) ~= nil then script.disable(atName); script.enable(atName) end
      log('Published '..#unpublishedAt..' Airtopia discovery topic and current levels'..(#unpublishedAt ~= 1 and 's' or '')..(logms and ' in '..string.format('%.3f', socket.gettime()-nClock)..' seconds' or '')..(failed ~= 0 and ' ('..failed..' failed)' or '')..', event script \''..atName..'\' restarted')
      unpublishedAt = {}
    else
      error('Airtopia event script \'AT\' not found')
    end
  end
  stat, err = pcall(publishAtState) if not stat then log(err) end
end


--[[
Publish the next queued messages for CBus
--]]
local function outstandingMqttMessage()
  local msg, k, v, device
  for _, msg in ipairs(mqttMessages) do
    local topic = msg.topic
    local payload = msg.payload

    local parts = string.split(topic, '/')

    -- Messages from CBus write topics
    if parts[1] == 'cbus' and parts[2] == 'write' then
      local net = tonumber(parts[3]) local app = tonumber(parts[4]) local group = tonumber(parts[5])
      local alias = net..'/'..app..'/'..group
      if logging then log('Set '..topic..' to '..payload) end

      -- ignoreMqtt[alias] = socket.gettime(); if logging then log('Setting ignoreMqtt for '..alias) end

      local lastLevel = storage.get('lastlvl', {})

      if not parts[6] then
        log('MQTT error: Invalid message format: '..topic)

      elseif parts[6] == 'switch' then
        if payload == 'ON' then      SetCBusLevel(net, app, group, 255, 0); if logging then log('Payload is ON for '..alias) end
        elseif payload == 'OFF' then SetCBusLevel(net, app, group, 0, 0);   if logging then log('Payload is OFF for '..alias) end
        end

      elseif parts[6] == 'select' then
        if app ~= 202 then
          SetCBusLevel(net, app, group, selects[alias][payload], 0); if logging then log('Payload is '..payload..' ('..selects[alias][payload]..') for '..alias) end
        else
          SetTriggerLevel(group, selects[alias][payload], 0); if logging then log('Payload is '..payload..' ('..selects[alias][payload]..') for '..alias) end
        end

      elseif parts[6]:contains('press') and payload == 'PRESS' then -- Lighting group press
        PulseCBusLevel(net, app, group, 255, 0, 1, 0); if logging then log('Payload for '..alias..' is PRESS') end

      elseif parts[7] ~= nil and parts[7]:contains('press') and payload == 'PRESS' then -- Trigger level press
        local level = triggers[group][parts[6]]
        if level ~= nil then
          SetTriggerLevel(group, level); if logging then log('Payload for '..alias..' is PRESS') end
        else
          log('Warning: MQTT trigger level received that is not published')
        end

      elseif parts[6] == 'measurement' then SetCBusMeasurement(net, app, group, payload, 0)

      elseif parts[6] == 'ramp' then
        if payload == 'OPEN' then
          SetCBusLevel(net, app, group, 255, 0)
          if cover[alias] and not mqttDevices[alias].noleveltranslate and hasMembers(mqttDevices[alias].rate) and not transition[alias] then transition[alias] = { state='opening', level=coverLevel[alias], ts=socket.gettime() + mqttDevices[alias].delay, } if logging then log('Transitioning '..alias..' to open') end end
          goto next
        elseif payload == 'CLOSE' then
          SetCBusLevel(net, app, group, 0, 0)
          if cover[alias] and not mqttDevices[alias].noleveltranslate and hasMembers(mqttDevices[alias].rate) and not transition[alias] then transition[alias] = { state='closing', level=coverLevel[alias], ts=socket.gettime() + mqttDevices[alias].delay, } if logging then log('Transitioning '..alias..' to close') end end
          goto next
        elseif payload == 'STOP' then
          if not mqttDevices[alias].noleveltranslate then
            storage.set('coverLevel', coverLevel) transition[alias] = nil if logging then log('Cancel transition for '..alias) end
            if hasMembers(mqttDevices[alias].rate) then client:publish(mqttReadTopic..alias..'/state', (coverLevel[alias] ~= 0) and 'open' or 'closed', mqttQoS, RETAIN) end
            if setCoverLevelAtStop and hasMembers(mqttDevices[alias].rate) then SetCBusLevel(net, app, group, coverLevel[alias], 0) else SetCBusLevel(net, app, group, 5, 0) end
          end
          goto next
        elseif payload == 'ON' then
          if fan[alias] then
            if lastLevel[alias] then
              payload = lastLevel[alias]; if logging then log('Payload for '..alias..' is fan ON, so using lastlevel instead') end
            else
              payload = '255'; if logging then log('Payload for '..alias..' is fan ON') end
            end
          else
            if logging then log('Payload for '..alias..' is ON') end
            SetCBusLevel(net, app, group, 255, 0)
            goto next
          end
        end
        if payload == 'OFF' then
          if logging then log('Payload for '..alias..' is OFF') end
          SetCBusLevel(net, app, group, 0, 0)
        else -- Ramp
          parts = string.split(payload, ',')
          local lev = tonumber(parts[1])
          local num
          if lev ~= nil then num = math.floor(lev + 0.5) else log('Warning: non-numeric CBus level for '..alias..', level='..parts[1]); num = nil end
          if num ~= nil and num < 256 then
            if logging then log('Payload for '..alias..' is RAMP '..payload) end
            local toSet = 0
            local ramp = 0
            if not fan[alias] then
              if lastLevel[alias] and not storeLevel[alias] then lastLevel[alias] = nil storage.set('lastlvl', lastLevel) log('Clear legacy lastLevel for '..alias) end
              if storeLevel[alias] and lastLevel[alias] then if logging then log('Last level '..lastLevel[alias]) end end
              if storeLevel[alias] and lastLevel[alias] and num == 255 then
                if blindKey and GetCBusGroupTag(net, app, group):contains(blindKey) then
                  toSet = num; if logging then log('Payload is blind ramp on for '..alias) end
                else
                  if lastLevel[alias] then toSet = lastLevel[alias] else toSet = num end
                end
              else
                toSet = num
              end
              if cover[alias] then
                coverLevel[alias] = toSet storage.set('coverLevel', coverLevel) mqttDevices[alias].transition = nil
                if hasMembers(mqttDevices[alias].rate) then client:publish(mqttReadTopic..alias..'/state', (coverLevel[alias] ~= 0) and 'open' or 'closed', mqttQoS, RETAIN) end
              end
            else
              toSet = num
            end
            if parts[2] ~= nil then ramp = tonumber(parts[2]) else ramp = 0 end
            SetCBusLevel(net, app, group, toSet, ramp)
          end
          goto next
        end
      end

      -- Messages from ENV board sensor topics - simpler, only messages inbound
    elseif environmentSupport and envBoards[parts[1]] and parts[2] == 'sensor' and parts[4] == 'state' then
      device = parts[1]..'-'..parts[3]
      if envDevices[device] then
        local extant = GetUserParam(envDevices[device][1], envDevices[device][2])
        if type(extant) == 'number' then
          -- Deal with real number imprecision, assuming three decimal places for change detection
          if string.format('%.3f', extant) ~= string.format('%.3f', tonumber(payload)) then SetUserParam(envDevices[device][1], envDevices[device][2], payload) end
        else
          if extant ~= payload then SetUserParam(net, group, payload) end
        end
        env[envDevices[device][3]].state = payload
      end

    -- Messages from AC board select/sensor topics
    elseif panasonicSupport and acBoards[parts[1]] and acMsg[parts[2]] then
      local sel = 'func'
      if parts[2] == 'select' then
        sel = 'sel'
      else
        local a = acSense[parts[1]..'-'..parts[3]] if a and ac[a].sense == parts[3] and ac[a].topic == parts[2] then sel = 'sense' device = parts[1]..'-'..parts[3]..'-sense' end
        if not a then if parts[4] then a = acSense[parts[1]..'-'..parts[4]] end if a and ac[a].sense == parts[4] and ac[a].topic == parts[2] then sel = 'sense' device = parts[1]..'-'..parts[4]..'-sense' end end
      end
      if sel == 'func' then device = parts[1]..'-'..parts[4] elseif sel == 'select' then device = parts[1]..'-'..parts[3] end
      local net, group
      if acDevices[device] then
        local alias = acDevices[device]
        net = ac[alias].net
        group = ac[alias].group
        if (sel == 'func' and parts[5] == 'state') or (sel == 'sel' and parts[4] == 'state') or sel == 'sense' then
          if ignoreCbus[alias] and socket.gettime() - ignoreCbus[alias] > ignoreTimeout then -- Don't worry about older 'ignore' flags
            ignoreCbus[alias] = nil
            if logging then log('Ignoring older CBus ignore flag for '..alias) end
          end
          if not ignoreCbus[alias] then -- Only set the CBus status/level if this script did not initiate the change, and if it is different to the current value
            local set = false
            if payload ~= nil then
              local extant = GetUserParam(net, group)
              local e = tonumber(extant)
              local p = tonumber(payload)
              if e ~= nil and p ~= nil then
                if string.format('%.3f', e) ~= string.format('%.3f', p) then SetUserParam(net, group, p); set = true end
              elseif p ~= nil then
                if e ~= string.format('%.3f', p) then SetUserParam(net, group, p); set = true end
              elseif e ~= nil then
                if string.format('%.3f', e) ~= payload then SetUserParam(net, group, payload); set = true end
              else
                if extant ~= payload then SetUserParam(net, group, payload); set = true end
              end
            else
              log('Warning: nil payload for '..alias..', ignoring')
            end
            -- Setting CBus here will result in the AC event script requesting publication of the state using publishAc() above.
            -- This is undesired, so ignoreMqtt[alias] is used to ensure that the CBus change received does not publish to MQTT.
            if set then
              ignoreMqtt[alias] = socket.gettime()
              -- if logging then log('Setting ignoreMqtt for '..alias..', oldState='..extant..' payload='..payload) end
            end
          else
            ignoreCbus[alias] = nil
            if logging then log('Ignoring CBus publish for '..alias) end
          end
          ac[alias].state = payload
        end
      end

    -- Messages from AT board cmd topics
    elseif airtopiaSupport and parts[1] == 'airtopia' and parts[3] == 'cmd' then
      device = parts[2]..'-'..parts[4]
      local net, group

      local function pub(alias, payload) -- State publish to MQTT
        local parts = string.split(at[alias].name, '-')
        local board = parts[1]
        local topic = 'airtopia/'..board..'/state/'..parts[2]
        client:publish(topic, payload, mqttQoS, RETAIN)
      end

      if parts[4] == 'mode' then
        if atDevices[device] then
          alias = atDevices[device]
          local p = string.split(alias, '/'); net = tonumber(p[1]); group = tonumber(p[3])
          i = indexOf(atmodes, payload)
          if i ~= nil then
            local set = false
            local pwrgrp = tonumber(string.split(atBoards[parts[2]].alias, '/')[3]) -- Get the power user parameter
            local extant = GetUserParam(net, pwrgrp)
            local pld = nil
            if payload ~= 'off' then
              pub(alias, i)
              pub(atBoards[parts[2]].alias, 1) -- Power on
              if extant ~= 1 then set = true; pld = 1 end
            else
              pub(atBoards[parts[2]].alias, 0) -- Power off
              if extant ~= 0 then set = true; pld = 0 end
            end
            if set and pld ~= nil then
              -- Send to CBus, ensuring MQTT ignore is set...
              local alias = atBoards[parts[2]].alias
              ignoreMqtt[alias] = socket.gettime(); if logging then log('Setting ignoreMqtt for '..alias..', oldState='..extant..' payload='..pld) end
              SetUserParam(net, pwrgrp, pld)
            end
            -- publish to CBus
            local extant = GetUserParam(net, group)
            if i ~= extant and payload ~= 'off' then -- Set mode, but not if it is 'off'
              ignoreMqtt[alias] = socket.gettime(); if logging then log('Setting ignoreMqtt for '..alias..', oldState='..extant..' payload='..payload) end
              SetUserParam(net, group, i)
            end
          end
          -- Publish state to broker
          local parts = string.split(at[alias].name, '-')
          local board = parts[1]
          local topic = 'airtopia/'..board..'/state/modeha'
          client:publish(topic, payload, mqttQoS, RETAIN)
        end

      elseif parts[4] == 'swing' then
        local hswing = atDevices[parts[2]..'-horiz_swing']
        local vswing = atDevices[parts[2]..'-vert_swing']
        if hswing ~= nil and vswing ~= nil then
          local i, h, v
          local s = 0; for i, v in ipairs(atswings) do if v == payload then s = i - 1; break; end end -- Get the swing index
          h = bit.band(s, 1)
          v = bit.rshift(bit.band(s, 2), 1)
          local board = parts[2]
          local topic = 'airtopia/'..board..'/state/swingha'
          client:publish(topic, payload, mqttQoS, RETAIN)
          parts = string.split(hswing, '/'); SetUserParam(parts[1], parts[3], h)
          parts = string.split(vswing, '/'); SetUserParam(parts[1], parts[3], v)
        end

      elseif parts[4] == 'fan' then
        local fan = atDevices[parts[2]..'-fan']
        if fan ~= nil then
          local i, f
          local f = 0; for i, v in ipairs(atfans) do if v == payload then f = i - 1; break; end end -- Get the fan index
          local board = parts[2]
          local topic = 'airtopia/'..board..'/state/fanha'
          client:publish(topic, payload, mqttQoS, RETAIN)
          parts = string.split(fan, '/'); SetUserParam(parts[1], parts[3], f)
        end

      else -- Set target temp
        if atDevices[device] then
          alias = atDevices[device]
          local p = string.split(alias, '/'); net = tonumber(p[1]); group = tonumber(p[3])
          pub(alias, payload)
          -- publish to CBus
          local extant = GetUserParam(net, group)
          if payoad ~= extant then
            ignoreMqtt[alias] = socket.gettime(); if logging then log('Setting ignoreMqtt for '..alias..', oldState='..extant..' payload='..payload) end
            SetUserParam(net, group, payload)
          end
        end
      end
    elseif airtopiaSupport and parts[1] == 'airtopia' and parts[3] == 'state' then
      if indexOf(airtopiaStates, parts[4]) == nil then table.insert(airtopiaStates, parts[4]) end
    end
    ::next::
  end
  mqttMessages = {}
end


--[[
Publish the next queued messages for MQTT
--]]
local function outstandingCbusMessage()
  local cmd, stat, err, parts, alias, final

  local lastLevel = storage.get('lastlvl', {})
  for _, cmd in ipairs(cbusMessages) do
    -- Check for final levels
    if cmd:contains('>') then
      cmd = cmd:gsub('>', '/')
      final = true
      parts = string.split(cmd, '/')
      alias = parts[1]..'/'..parts[2]..'/'..parts[3]
      if logging and lighting[parts[2]] then log('Final level achieved, '..cmd) end
    else
      final = false
      parts = string.split(cmd, '/')
      alias = parts[1]..'/'..parts[2]..'/'..parts[3]
    end

    if panasonicSupport and ac[alias] then -- AC message to MQTT (no ramping involved for AC groups)
      stat, err = pcall(publishAc, alias, parts[4], ac[alias].select)
      if not stat then log(err) end
    elseif airtopiaSupport and at[alias] then -- AT message to MQTT (no ramping involved for AT groups)
      stat, err = pcall(publishAt, alias, parts[4])
      if not stat then log(err) end
    else -- CBus message to MQTT
      local net = tonumber(parts[1]) local app = tonumber(parts[2]) local group = tonumber(parts[3]);
      if app ~= 228 and app ~= 255 then -- i.e. not measurement application / unit parameter
        local setting = true
        local payload = tonumber(parts[4]) -- Always a number for lighting app, but payload could be nil for user param at this point if a string
        if lighting[parts[2]] then -- Lighting application, so check for ramp
          if legacyFirmware then
            if logging then log('Alias: '..alias..', payload: '..payload..', ramp rate: '..GetCBusRampRate(net, app, group)..', target level: '..GetCBusTargetLevel(net, app, group)) end
            -- A CBus ramp up and down can annoyingly begin with a zero level, then steadily converge to the target level. This initial
            -- zero should not be published to MQTT so it is ignored. If an initial zero is not seen then the ramp will be orphaned (and
            -- ultimately cleaned up/published, albeit a bit late after rampTimeout seconds).
            if not ramp[alias] then
              if GetCBusRampRate(net, app, group) > 0 then
                -- if lastLevel[alias] ~= GetCBusTargetLevel(net, app, group) or not lastLevel[alias] then
                  ramp[alias] = { ts=socket.gettime(), ramp=GetCBusRampRate(net, app, group), target=GetCBusTargetLevel(net, app, group) }
                -- end
                if payload == 0 then
                  setting = false
                  if ramp[alias] then if logging then log('Set ramp for '..alias..' and suppress zero send') end end
                else
                  if ramp[alias] then if logging then log('Set ramp for '..alias) end end
                end
              end
            else
              if ramp[alias].target ~= GetCBusTargetLevel(net, app, group) then -- Target level has changed so cancel ramp
                ramp[alias] = nil
                if logging then log('Cancel ramp for '..alias) end
                if payload == 0 and GetCBusRampRate(net, app, group) > 0 then setting = false end -- Ignore initial zero if ramp on
              end
            end
          end
        else -- Possibly a string payload for user parameter
          if payload == nil then
            payload = parts[4]
            local pt = 5 -- Accommodate an unlimited number of slashes in a string payload
            while parts[pt] ~= nil do
              payload = payload..'/'..parts[pt]
              pt = pt + 1
            end
          end
          -- Groups other than lighting are never ramped, so setting is always true
        end
        if setting then
          if legacyFirmware then
            if ramp[alias] then
              if final then
                ramp[alias] = nil
                if logging then log('Clear ramp for '..alias) end
                -- Only update MQTT at the end of a ramp, not during it (avoids HomeAssistant remembering an implausible level)
                stat, err = pcall(publish, alias, app, payload) if not stat then log(err) end
              end
            else
              stat, err = pcall(publish, alias, app, payload) if not stat then log(err) end
            end
          else
            stat, err = pcall(publish, alias, app, payload) if not stat then log(err) end
          end
          if cover[alias] and not mqttDevices[alias].noleveltranslate and hasMembers(mqttDevices[alias].rate) then
            if not transition[alias] then
              if payload == 0 then transition[alias] = { state='closing', level=coverLevel[alias], ts=socket.gettime() + mqttDevices[alias].delay, } if logging then log('Transitioning '..alias..' to open') end
              elseif payload == 255 then transition[alias] = { state='opening', level=coverLevel[alias], ts=socket.gettime() + mqttDevices[alias].delay, } if logging then log('Transitioning '..alias..' to closed') end
              end
            else
              if payload == 5 then
                storage.set('coverLevel', coverLevel) transition[alias] = nil if logging then log('Cancel transition for '..alias) end
                if hasMembers(mqttDevices[alias].rate) then client:publish(mqttReadTopic..alias..'/state', (coverLevel[alias] ~= 0) and 'open' or 'closed', mqttQoS, RETAIN) end
              end
            end
          end
        end
      elseif app == 228 then -- Special case for measurement app
        alias = alias..'/'..parts[4]
        stat, err = pcall(publishMeasurement, alias, net, group, tonumber(parts[4]), tonumber(parts[5])) if not stat then log(err) end
      elseif app == 255 then -- Special case for unit param
        alias = alias..'/'..parts[4]
        stat, err = pcall(publishUnitParam, alias, tonumber(parts[5])) if not stat then log(err) end
      end
    end
  end
  cbusMessages = {}
end


--[[
Remove any orphaned ramp flags (legacy firmware)
--]]
local function checkRampOrphans()
  local k, v; local orphan = {}
  for k, v in pairs(ramp) do
    if socket.gettime() > v.ts + v.ramp + rampTimeout then
      -- Is an older ramp timestamp beyond ramp duration plus margin (should never occur, but does occasionally when set up for firmware < 1.15.0).
      -- Remove the orphan, and publish the final target, which will be zero.
      -- Will occur when a ramp to off does not begin with a zero level during the ramp, or if a ramp to zero starts when the group is already at zero.
      table.insert(orphan, k)
      local parts = string.split(k, '/')
      local net = tonumber(parts[1]) local app = tonumber(parts[2]) local group = tonumber(parts[3])
      publish(k, app, v.target)
    end
  end
  for _, k in ipairs(orphan) do ramp[k] = nil; if logging then log('Removing orphaned ramp for '..k) end end
end


--[[
Duplicate discovery delete
--]]
local function dupDelete()
  -- If duplicate discovery topics are detected then remove them (discoveryDelete is set in broker ON_MESSAGE call-back)
  log('Warning: Removing '..len(discoveryDelete)..' duplicate discovery topics')
  local toDelete
  for toDelete, _ in pairs(discoveryDelete) do
    local parts = string.split(toDelete, '/')
    local oid = parts[1]
    local dType = parts[2]
    client:publish(mqttDiscoveryTopic..dType..'/'..oid..'/config', '', mqttQoS, RETAIN)
    log('Removed discovery topic '..mqttDiscoveryTopic..dType..'/'..oid..'/config')
  end
  discoveryDelete = {}
end


local function checkHeartbeat()
  if sendHeartbeat > 0 then
    local stat, err = pcall(function ()
      if socket.gettime() - heartbeat >= sendHeartbeat then
        heartbeat = socket.gettime(); require('socket').udp():sendto(_SCRIPTNAME..'+'..heartbeat, '127.0.0.1', 5433)
      end
    end)
    if not stat then
      log('A fault occurred sending heartbeat. Restarting...')
      pcall(function () server:close() end)
      return false
    else
      return true
    end
  end
  return true
end


--[[
Main loop
--]]

-- Create/update/delete functions spread evenly over the period 'checkChanges'
local cud = {
  { name = 'CBus', func = cudCBusTopics, init = false },
}
if environmentSupport then table.insert(cud, { name = 'environment sensor', func = cudEnv, init = true }) end
if panasonicSupport then table.insert(cud, { name = 'Panasonic', func = cudAc, init = true }) end
if airtopiaSupport then table.insert(cud, { name = 'Airtopia', func = cudAt, init = false }) end

local i, c
for i, c in ipairs(cud) do c.t = socket.gettime() - checkChanges * 1/#cud * i + checkChanges/#cud end -- Set the time to next discover for each function

local function validateIncoming(cmd) -- Reject any weird socket messages received
  if cmd:contains('>') then
    local incoming = string.split(cmd, '>')
    local _, count = incoming[1]:gsub('/', ''); if count < 2 or count > 3 then return false end
    local parts = string.split(incoming[1], '/')
    local payload = incoming[2]
    local dstC, n
    if parts[2] and (parts[2] == '228' or parts[2] == '255') then dstC = 4 else dstC = 3 end -- Measurement/Unit param app is four dest parts, else three
    if payload == nil then return false end
    for i = 1,dstC,1 do n = tonumber(parts[i], 10); if n == nil then return false end end -- Test whether any dest parts are not whole decimal numbers
    return true
  else
    local _, count = cmd:gsub('/', ''); if count < 3 or count > 4 then return false end
    local parts = string.split(cmd, '/')
    local dstC, payload, n
    if parts[2] and (parts[2] == '228' or parts[2] == '255') then dstC = 4; payload = parts[5] else dstC = 3; payload = parts[4] end -- Measurement/Unit param app is four dest parts, else three
    if payload == nil then return false end
    for i = 1,dstC,1 do n = tonumber(parts[i], 10); if n == nil then return false end end -- Test whether any dest parts are not whole decimal numbers
    return true
  end
  return false
end

local warningTimeout = 30
local timeout = 1
local timeoutStart, connectStart

while true do
  -- Check for new messages from CBus. The entire socket buffer is collected each iteration for efficiency.
  local stat, err
  local more = false
  stat, err = pcall(function ()
    ::checkAgain::
    local cmd = nil
	  cmd = server:receive()
    if cmd and type(cmd) == 'string' then
      if validateIncoming(cmd) then
        cbusMessages[#cbusMessages + 1] = cmd -- Queue the new message
      else
        log('Invalid command received: '..cmd)
      end
      server:settimeout(0); more = true; goto checkAgain -- Immediately check for more buffered inbound messages to queue
    else
      if more then server:settimeout(socketTimeout) end
    end
  end)
  if not stat then log('Socket receive error: '..err) end

  if mqttStatus == 1 then -- When connected to the broker
    -- Process MQTT message buffers synchronously - sends and receives
    client:loop(mqttTimeout)

    if #mqttMessages > 0 then
      -- Send outstanding messages to CBus
      stat, err = pcall(outstandingMqttMessage)
      if not stat then log('Error processing outstanding MQTT messages: '..err) mqttMessages = {} end -- Log error and clear the queue
    end
    if #cbusMessages > 0 then
      -- Send outstanding messages to MQTT
      stat, err = pcall(outstandingCbusMessage)
      if not stat then log('Error processing outstanding CBus messages: '..err) cbusMessages = {} end -- Log error and clear the queue, continue
    end
    if #unpublished > 0 then
      -- Publish outstanding CBus discovery topics
      stat, err = pcall(outstandingPublish)
      if not stat then log('Error publishing outstanding CBus discovery topics: '..err) unpublished = {} end -- Log error and clear the queue, continue
    end
    if #unpublishedAt > 0 then
      -- Publish outstanding Airtopia discovery topics
      stat, err = pcall(outstandingAtPublish)
      if not stat then log('Error publishing outstanding Airtopia discovery topics: '..err) unpublishedAt = {} end -- Log error and clear the queue, continue
    end
    if hasMembers(transition) then
      -- Tracking progress of open/close of covers
      stat, err = pcall(trackTransitions)
      if not stat then log('Error tracking transitions: '..err) transition = {} end -- Log error and clear the transition list, continue
    end
    if legacyFirmware and hasMembers(ramp) then
      -- Some scenarios can create ramp orphans when using a legacy firmware setup
      stat, err = pcall(checkRampOrphans)
      if not stat then log('Error checking ramp orphans: '..err) end -- Log and continue
    end
    if hasMembers(discoveryDelete) then
      -- A type has changed for existing topics, so clean up discovery for the old topics
      stat, err = pcall(dupDelete)
      if not stat then log('Error processing delete discovery duplicates: '..err) discoveryDelete = {} end -- Log error and clear the queue, continue
    end
    if checkForChanges then
      -- Periodically create/update/delete device items that change
      for _, c in ipairs(cud) do if socket.gettime() - c.t >=checkChanges then c.t = socket.gettime() local stat, err = pcall(c.func) if not stat then log('Error calling '..c.name..' create/update/delete function: '..err) end end end
    end
  elseif mqttStatus == 2 or not mqttStatus then
    -- MQTT is disconnected, so attempt a connection, waiting. If fail to connect then retry.
    if init then
      log('Connecting to Mosquitto broker')
      timeoutStart = socket.gettime()
      connectStart = timeoutStart
      init = false
    end
    stat, err = pcall(function (b, p, k) client:connect(b, p, k) end, mqttBroker, 1883, 25) -- Requested keep-alive 25 seconds, broker at port 1883
    if not stat then -- Log and abort
      log('Error calling connect to broker: '..err)
      pcall(function () server:close() end)
      do return end
    end
    while mqttStatus ~= 1 do
      client:loop(1) -- Service the client with a generous timeout
      if socket.gettime() - connectStart > timeout then
        if socket.gettime() - timeoutStart > warningTimeout then
          log('Failed to connect to the Mosquitto broker, retrying continuously')
          timeoutStart = socket.gettime()
        end
        connectStart = socket.gettime()
        goto next -- Exit to the main loop to keep socket messages monitored
      end
    end
    mqttConnected = socket.gettime()
    -- Subscribe to relevant topics
    client:subscribe(mqttWriteTopic..'#', mqttQoS)
    client:subscribe(mqttDiscoveryTopic..'#', mqttQoS)
    if panasonicSupport then for k, _ in pairs(acBoards) do client:subscribe(k..'/#', mqttQoS) end end
    if airtopiaSupport then for k, _ in pairs(atBoards) do client:subscribe('airtopia/'..k..'/#', mqttQoS) end end
    if environmentSupport then for k, _ in pairs(envBoards) do client:subscribe(k..'/#', mqttQoS) end end
    -- Connected... Now loop briefly to allow retained value retrieval for subscribed topics because synchronous
    while socket.gettime() - mqttConnected < 0.5 do client:loop(0) end
    if not reconnect then
      -- Full publish CBus topics
      stat, err = pcall(publishCurrent)
      if not stat then log('Error publishing current values: '..err) end -- Log and continue
      -- Initial load of devices excluding CBus/Airtopia
      for _, c in ipairs(cud) do if c.init then local stat, err = pcall(c.func) if not stat then log('Error calling '..c.name..' create/update/delete function: '..err) end end end
    end
  else
    log('Error: Invalid mqttStatus: '..mqttStatus)
    pcall(function () server:close() end)
    do return end
  end

  ::next::

  --[[
  Send a heartbeat periodically to port 5433, listened to by the heartheat script.
  If execution is disrupted by any error or lockup then this script will be re-started.
  If sending the heartbeat faults, then the loop is exited, which will also re-start this
  script (it being resident/sleep zero).
  --]]
  if not checkHeartbeat() then do return end end
end